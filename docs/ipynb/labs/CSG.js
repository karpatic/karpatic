export class CSG{constructor(){this.polygons=[]}clone(){var e=new CSG;return e.polygons=this.polygons.map((function(e){return e.clone()})),e}toPolygons(){return this.polygons}union(e){var o=new Node(this.clone().polygons),t=new Node(e.clone().polygons);return o.clipTo(t),t.clipTo(o),t.invert(),t.clipTo(o),t.invert(),o.build(t.allPolygons()),CSG.fromPolygons(o.allPolygons())}subtract(e){var o=new Node(this.clone().polygons),t=new Node(e.clone().polygons);return o.invert(),o.clipTo(t),t.clipTo(o),t.invert(),t.clipTo(o),t.invert(),o.build(t.allPolygons()),o.invert(),CSG.fromPolygons(o.allPolygons())}intersect(e){var o=new Node(this.clone().polygons),t=new Node(e.clone().polygons);return o.invert(),t.clipTo(o),t.invert(),o.clipTo(t),t.clipTo(o),o.build(t.allPolygons()),o.invert(),CSG.fromPolygons(o.allPolygons())}inverse(){var e=this.clone();return e.polygons.map((function(e){e.flip()})),e}}CSG.fromPolygons=function(e){var o=new CSG;return o.polygons=e,o};class Vector extends THREE.Vector3{constructor(e,o,t){if(3==arguments.length)super(e,o,t);else if(Array.isArray(e))super(e[0],e[1],e[2]);else{if("object"!=typeof e)throw"Invalid constructor to vector";super().copy(e)}}clone(){return new Vector(this)}negated(){return this.clone().multiplyScalar(-1)}plus(e){return this.clone().add(e)}minus(e){return this.clone().sub(e)}times(e){return this.clone().multiplyScalar(e)}dividedBy(e){return this.clone().divideScalar(e)}lerp(e,o){return this.plus(e.minus(this).times(o))}unit(){return this.dividedBy(this.length())}cross(e){return THREE.Vector3.prototype.cross.call(this.clone(),e)}}class Vertex{constructor(e,o,t){this.pos=new Vector(e),this.normal=new Vector(o),this.uv=new Vector(t)}clone(){return new Vertex(this.pos.clone(),this.normal.clone(),this.uv.clone())}flip(){this.normal=this.normal.negated()}interpolate(e,o){return new Vertex(this.pos.lerp(e.pos,o),this.normal.lerp(e.normal,o),this.uv.lerp(e.uv,o))}}class Plane{constructor(e,o){this.normal=e,this.w=o}clone(){return new Plane(this.normal.clone(),this.w)}flip(){this.normal=this.normal.negated(),this.w=-this.w}splitPolygon(e,o,t,n,r){for(var s=0,l=[],i=0;i<e.vertices.length;i++){var a=(y=this.normal.dot(e.vertices[i].pos)-this.w)<-Plane.EPSILON?2:y>Plane.EPSILON?1:0;s|=a,l.push(a)}switch(s){case 0:(this.normal.dot(e.plane.normal)>0?o:t).push(e);break;case 1:n.push(e);break;case 2:r.push(e);break;case 3:var c=[],h=[];for(i=0;i<e.vertices.length;i++){var p=(i+1)%e.vertices.length,u=l[i],v=l[p],m=e.vertices[i],f=e.vertices[p];if(2!=u&&c.push(m),1!=u&&h.push(2!=u?m.clone():m),3==(u|v)){var y=(this.w-this.normal.dot(m.pos))/this.normal.dot(f.pos.minus(m.pos)),g=m.interpolate(f,y);c.push(g),h.push(g.clone())}}c.length>=3&&n.push(new Polygon(c,e.shared)),h.length>=3&&r.push(new Polygon(h,e.shared))}}}Plane.EPSILON=1e-5,Plane.fromPoints=function(e,o,t){var n=o.minus(e).cross(t.minus(e)).unit();return new Plane(n,n.dot(e))};class Polygon{constructor(e,o){this.vertices=e,this.shared=o,this.plane=Plane.fromPoints(e[0].pos,e[1].pos,e[2].pos)}clone(){var e=this.vertices.map((function(e){return e.clone()}));return new Polygon(e,this.shared)}flip(){this.vertices.reverse().map((function(e){e.flip()})),this.plane.flip()}}class Node{constructor(e){this.plane=null,this.front=null,this.back=null,this.polygons=[],e&&this.build(e)}clone(){var e=new Node;return e.plane=this.plane&&this.plane.clone(),e.front=this.front&&this.front.clone(),e.back=this.back&&this.back.clone(),e.polygons=this.polygons.map((function(e){return e.clone()})),e}invert(){for(var e=0;e<this.polygons.length;e++)this.polygons[e].flip();this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();var o=this.front;this.front=this.back,this.back=o}clipPolygons(e){if(!this.plane)return e.slice();for(var o=[],t=[],n=0;n<e.length;n++)this.plane.splitPolygon(e[n],o,t,o,t);return this.front&&(o=this.front.clipPolygons(o)),t=this.back?this.back.clipPolygons(t):[],o.concat(t)}clipTo(e){this.polygons=e.clipPolygons(this.polygons),this.front&&this.front.clipTo(e),this.back&&this.back.clipTo(e)}allPolygons(){var e=this.polygons.slice();return this.front&&(e=e.concat(this.front.allPolygons())),this.back&&(e=e.concat(this.back.allPolygons())),e}build(e){if(e.length){this.plane||(this.plane=e[0].plane.clone());for(var o=[],t=[],n=0;n<e.length;n++)this.plane.splitPolygon(e[n],this.polygons,this.polygons,o,t);o.length&&(this.front||(this.front=new Node),this.front.build(o)),t.length&&(this.back||(this.back=new Node),this.back.build(t))}}}CSG.fromGeometry=function(e){e.isBufferGeometry&&(e=(new THREE.Geometry).fromBufferGeometry(e));for(var o=e.faces,t=e.vertices,n=[],r=["a","b","c"],s=0;s<o.length;s++){for(var l=o[s],i=[],a=0;a<3;a++)i.push(new Vertex(t[l[r[a]]],l.vertexNormals[a],e.faceVertexUvs[0][s][a]));n.push(new Polygon(i))}return CSG.fromPolygons(n)},CSG._tmpm3=new THREE.Matrix3,CSG.fromMesh=function(e){var o=CSG.fromGeometry(e.geometry);CSG._tmpm3.getNormalMatrix(e.matrix);for(var t=0;t<o.polygons.length;t++)for(var n=o.polygons[t],r=0;r<n.vertices.length;r++){var s=n.vertices[r];s.pos.applyMatrix4(e.matrix),s.normal.applyMatrix3(CSG._tmpm3)}return o},CSG.toMesh=function(e,o){for(var t=new THREE.Geometry,n=e.polygons,r=t.vertices,s=t.faceVertexUvs[0],l=0;l<n.length;l++){for(var i=n[l],a=i.vertices,c=r.length,h=a.length,p=0;p<h;p++)r.push((new THREE.Vector3).copy(a[p].pos));for(p=3;p<=h;p++){var u=new THREE.Face3,v=[];s.push(v);var m=u.vertexNormals;u.a=c,u.b=c+p-2,u.c=c+p-1,m.push((new THREE.Vector3).copy(a[0].normal)),m.push((new THREE.Vector3).copy(a[p-2].normal)),m.push((new THREE.Vector3).copy(a[p-1].normal)),v.push((new THREE.Vector3).copy(a[0].uv)),v.push((new THREE.Vector3).copy(a[p-2].uv)),v.push((new THREE.Vector3).copy(a[p-1].uv)),u.normal=(new THREE.Vector3).copy(i.plane.normal),t.faces.push(u)}}var f=(new THREE.Matrix4).getInverse(o);t.applyMatrix(f),t.verticesNeedUpdate=t.elementsNeedUpdate=t.normalsNeedUpdate=!0,t.computeBoundingSphere(),t.computeBoundingBox();var y=new THREE.Mesh(t);return y.matrix.copy(o),y.matrix.decompose(y.position,y.rotation,y.scale),y.updateMatrixWorld(),y},CSG.ieval=function(e,o=0){if("string"==typeof e)CSG.currentOp=e;else if(e instanceof Array)for(let o=0;o<e.length;o++)CSG.ieval(e[o],0);else if("object"==typeof e){var t=CSG.currentOp;e.updateMatrix(),e.updateMatrixWorld(),CSG.sourceMesh?(CSG.nextPrim=CSG.fromMesh(e),CSG.currentPrim=CSG.currentPrim[t](CSG.nextPrim)):CSG.currentPrim=CSG.fromMesh(CSG.sourceMesh=e),CSG.doRemove&&e.parent.remove(e)}},CSG.eval=function(e,o){CSG.currentOp=null,CSG.sourceMesh=null,CSG.doRemove=o,CSG.ieval(e);var t=CSG.toMesh(CSG.currentPrim,CSG.sourceMesh.matrix);return t.material=CSG.sourceMesh.material,t.castShadow=t.receiveShadow=!0,t};