!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).jscadModeling=e()}}((function(){return function r(e,t,s){function o(l,h){if(!t[l]){if(!e[l]){var f="function"==typeof require&&require;if(!h&&f)return f(l,!0);if(c)return c(l,!0);var g=new Error("Cannot find module '"+l+"'");throw g.code="MODULE_NOT_FOUND",g}var p=t[l]={exports:{}};e[l][0].call(p.exports,(function(t){return o(e[l][1][t]||t)}),p,p.exports,r,e,t,s)}return t[l].exports}for(var c="function"==typeof require&&require,l=0;l<s.length;l++)o(s[l]);return o}({1:[function(e,t,s){const c=e("./cssColors");t.exports=e=>c[e.toLowerCase()]},{"./cssColors":3}],2:[function(e,t,s){const c=e("../utils/flatten"),l=e("../geometries/geom2"),h=e("../geometries/geom3"),f=e("../geometries/path2"),g=e("../geometries/poly3");t.exports=(e,...t)=>{if(!Array.isArray(e))throw new Error("color must be an array");if(e.length<3)throw new Error("color must contain R, G and B values");if(3===e.length&&(e=[e[0],e[1],e[2],1]),0===(t=c(t)).length)throw new Error("wrong number of arguments");const s=t.map((t=>l.isA(t)?((e,t)=>{const s=l.clone(t);return s.color=e,s})(e,t):h.isA(t)?((e,t)=>{const s=h.clone(t);return s.color=e,s})(e,t):f.isA(t)?((e,t)=>{const s=f.clone(t);return s.color=e,s})(e,t):g.isA(t)?((e,t)=>{const s=g.clone(t);return s.color=e,s})(e,t):(t.color=e,t)));return 1===s.length?s[0]:s}},{"../geometries/geom2":25,"../geometries/geom3":40,"../geometries/path2":61,"../geometries/poly3":78,"../utils/flatten":396}],3:[function(e,t,s){t.exports={black:[0,0,0],silver:[192/255,192/255,192/255],gray:[128/255,128/255,128/255],white:[1,1,1],maroon:[128/255,0,0],red:[1,0,0],purple:[128/255,0,128/255],fuchsia:[1,0,1],green:[0,128/255,0],lime:[0,1,0],olive:[128/255,128/255,0],yellow:[1,1,0],navy:[0,0,128/255],blue:[0,0,1],teal:[0,128/255,128/255],aqua:[0,1,1],aliceblue:[240/255,248/255,1],antiquewhite:[250/255,235/255,215/255],aquamarine:[127/255,1,212/255],azure:[240/255,1,1],beige:[245/255,245/255,220/255],bisque:[1,228/255,196/255],blanchedalmond:[1,235/255,205/255],blueviolet:[138/255,43/255,226/255],brown:[165/255,42/255,42/255],burlywood:[222/255,184/255,135/255],cadetblue:[95/255,158/255,160/255],chartreuse:[127/255,1,0],chocolate:[210/255,105/255,30/255],coral:[1,127/255,80/255],cornflowerblue:[100/255,149/255,237/255],cornsilk:[1,248/255,220/255],crimson:[220/255,20/255,60/255],cyan:[0,1,1],darkblue:[0,0,139/255],darkcyan:[0,139/255,139/255],darkgoldenrod:[184/255,134/255,11/255],darkgray:[169/255,169/255,169/255],darkgreen:[0,100/255,0],darkgrey:[169/255,169/255,169/255],darkkhaki:[189/255,183/255,107/255],darkmagenta:[139/255,0,139/255],darkolivegreen:[85/255,107/255,47/255],darkorange:[1,140/255,0],darkorchid:[.6,50/255,.8],darkred:[139/255,0,0],darksalmon:[233/255,150/255,122/255],darkseagreen:[143/255,188/255,143/255],darkslateblue:[72/255,61/255,139/255],darkslategray:[47/255,79/255,79/255],darkslategrey:[47/255,79/255,79/255],darkturquoise:[0,206/255,209/255],darkviolet:[148/255,0,211/255],deeppink:[1,20/255,147/255],deepskyblue:[0,191/255,1],dimgray:[105/255,105/255,105/255],dimgrey:[105/255,105/255,105/255],dodgerblue:[30/255,144/255,1],firebrick:[178/255,34/255,34/255],floralwhite:[1,250/255,240/255],forestgreen:[34/255,139/255,34/255],gainsboro:[220/255,220/255,220/255],ghostwhite:[248/255,248/255,1],gold:[1,215/255,0],goldenrod:[218/255,165/255,32/255],greenyellow:[173/255,1,47/255],grey:[128/255,128/255,128/255],honeydew:[240/255,1,240/255],hotpink:[1,105/255,180/255],indianred:[205/255,92/255,92/255],indigo:[75/255,0,130/255],ivory:[1,1,240/255],khaki:[240/255,230/255,140/255],lavender:[230/255,230/255,250/255],lavenderblush:[1,240/255,245/255],lawngreen:[124/255,252/255,0],lemonchiffon:[1,250/255,205/255],lightblue:[173/255,216/255,230/255],lightcoral:[240/255,128/255,128/255],lightcyan:[224/255,1,1],lightgoldenrodyellow:[250/255,250/255,210/255],lightgray:[211/255,211/255,211/255],lightgreen:[144/255,238/255,144/255],lightgrey:[211/255,211/255,211/255],lightpink:[1,182/255,193/255],lightsalmon:[1,160/255,122/255],lightseagreen:[32/255,178/255,170/255],lightskyblue:[135/255,206/255,250/255],lightslategray:[119/255,136/255,.6],lightslategrey:[119/255,136/255,.6],lightsteelblue:[176/255,196/255,222/255],lightyellow:[1,1,224/255],limegreen:[50/255,205/255,50/255],linen:[250/255,240/255,230/255],magenta:[1,0,1],mediumaquamarine:[.4,205/255,170/255],mediumblue:[0,0,205/255],mediumorchid:[186/255,85/255,211/255],mediumpurple:[147/255,112/255,219/255],mediumseagreen:[60/255,179/255,113/255],mediumslateblue:[123/255,104/255,238/255],mediumspringgreen:[0,250/255,154/255],mediumturquoise:[72/255,209/255,.8],mediumvioletred:[199/255,21/255,133/255],midnightblue:[25/255,25/255,112/255],mintcream:[245/255,1,250/255],mistyrose:[1,228/255,225/255],moccasin:[1,228/255,181/255],navajowhite:[1,222/255,173/255],oldlace:[253/255,245/255,230/255],olivedrab:[107/255,142/255,35/255],orange:[1,165/255,0],orangered:[1,69/255,0],orchid:[218/255,112/255,214/255],palegoldenrod:[238/255,232/255,170/255],palegreen:[152/255,251/255,152/255],paleturquoise:[175/255,238/255,238/255],palevioletred:[219/255,112/255,147/255],papayawhip:[1,239/255,213/255],peachpuff:[1,218/255,185/255],peru:[205/255,133/255,63/255],pink:[1,192/255,203/255],plum:[221/255,160/255,221/255],powderblue:[176/255,224/255,230/255],rosybrown:[188/255,143/255,143/255],royalblue:[65/255,105/255,225/255],saddlebrown:[139/255,69/255,19/255],salmon:[250/255,128/255,114/255],sandybrown:[244/255,164/255,96/255],seagreen:[46/255,139/255,87/255],seashell:[1,245/255,238/255],sienna:[160/255,82/255,45/255],skyblue:[135/255,206/255,235/255],slateblue:[106/255,90/255,205/255],slategray:[112/255,128/255,144/255],slategrey:[112/255,128/255,144/255],snow:[1,250/255,250/255],springgreen:[0,1,127/255],steelblue:[70/255,130/255,180/255],tan:[210/255,180/255,140/255],thistle:[216/255,191/255,216/255],tomato:[1,99/255,71/255],turquoise:[64/255,224/255,208/255],violet:[238/255,130/255,238/255],wheat:[245/255,222/255,179/255],whitesmoke:[245/255,245/255,245/255],yellowgreen:[154/255,205/255,50/255]}},{}],4:[function(e,t,s){t.exports=e=>{if((e=e.replace("#","")).length<6)throw new Error("the given notation must contain 3 or more hex values");const t=parseInt(e.substring(0,2),16)/255,s=parseInt(e.substring(2,4),16)/255,c=parseInt(e.substring(4,6),16)/255;return e.length>=8?[t,s,c,parseInt(e.substring(6,8),16)/255]:[t,s,c]}},{}],5:[function(e,t,s){const c=e("../utils/flatten"),l=e("./hueToColorComponent");t.exports=(...e)=>{if((e=c(e)).length<3)throw new Error("values must contain H, S and L values");const t=e[0],s=e[1],h=e[2];let f=h,g=h,p=h;if(0!==s){const e=h<.5?h*(1+s):h+s-h*s,c=2*h-e;f=l(c,e,t+1/3),g=l(c,e,t),p=l(c,e,t-1/3)}return e.length>3?[f,g,p,e[3]]:[f,g,p]}},{"../utils/flatten":396,"./hueToColorComponent":7}],6:[function(e,t,s){const c=e("../utils/flatten");t.exports=(...e)=>{if((e=c(e)).length<3)throw new Error("values must contain H, S and V values");const t=e[0],s=e[1],l=e[2];let h=0,f=0,g=0;const p=Math.floor(6*t),d=6*t-p,x=l*(1-s),w=l*(1-d*s),b=l*(1-(1-d)*s);switch(p%6){case 0:h=l,f=b,g=x;break;case 1:h=w,f=l,g=x;break;case 2:h=x,f=l,g=b;break;case 3:h=x,f=w,g=l;break;case 4:h=b,f=x,g=l;break;case 5:h=l,f=x,g=w}return e.length>3?[h,f,g,e[3]]:[h,f,g]}},{"../utils/flatten":396}],7:[function(e,t,s){t.exports=(e,t,s)=>(s<0&&(s+=1),s>1&&(s-=1),s<1/6?e+6*(t-e)*s:s<.5?t:s<2/3?e+(t-e)*(2/3-s)*6:e)},{}],8:[function(e,t,s){t.exports={colorize:e("./colorize"),colorNameToRgb:e("./colorNameToRgb"),cssColors:e("./cssColors"),hexToRgb:e("./hexToRgb"),hslToRgb:e("./hslToRgb"),hsvToRgb:e("./hsvToRgb"),hueToColorComponent:e("./hueToColorComponent"),rgbToHex:e("./rgbToHex"),rgbToHsl:e("./rgbToHsl"),rgbToHsv:e("./rgbToHsv")}},{"./colorNameToRgb":1,"./colorize":2,"./cssColors":3,"./hexToRgb":4,"./hslToRgb":5,"./hsvToRgb":6,"./hueToColorComponent":7,"./rgbToHex":9,"./rgbToHsl":10,"./rgbToHsv":11}],9:[function(e,t,s){const c=e("../utils/flatten");t.exports=(...e)=>{if((e=c(e)).length<3)throw new Error("values must contain R, G and B values");const t=255*e[0],s=255*e[1],l=255*e[2];let h=`#${Number(16777216+65536*t+256*s+l).toString(16).substring(1,7)}`;return e.length>3&&(h+=Number(255*e[3]).toString(16)),h}},{"../utils/flatten":396}],10:[function(e,t,s){const c=e("../utils/flatten");t.exports=(...e)=>{if((e=c(e)).length<3)throw new Error("values must contain R, G and B values");const t=e[0],s=e[1],l=e[2],h=Math.max(t,s,l),f=Math.min(t,s,l);let g,p;const d=(h+f)/2;if(h===f)g=p=0;else{const e=h-f;switch(p=d>.5?e/(2-h-f):e/(h+f),h){case t:g=(s-l)/e+(s<l?6:0);break;case s:g=(l-t)/e+2;break;case l:g=(t-s)/e+4}g/=6}return e.length>3?[g,p,d,e[3]]:[g,p,d]}},{"../utils/flatten":396}],11:[function(e,t,s){const c=e("../utils/flatten");t.exports=(...e)=>{if((e=c(e)).length<3)throw new Error("values must contain R, G and B values");const t=e[0],s=e[1],l=e[2],h=Math.max(t,s,l),f=Math.min(t,s,l);let g;const p=h,d=h-f,x=0===h?0:d/h;if(h===f)g=0;else{switch(h){case t:g=(s-l)/d+(s<l?6:0);break;case s:g=(l-t)/d+2;break;case l:g=(t-s)/d+4}g/=6}return e.length>3?[g,x,p,e[3]]:[g,x,p]}},{"../utils/flatten":396}],12:[function(e,t,s){const c=e("./lengths");t.exports=(e,t)=>{const{distance:s,segments:l}=Object.assign({},{distance:0,segments:100},e),h=c(l,t);let f=0,g=l;for(;f<=g;){const e=Math.floor(f+(g-f)/2),t=h[e]-s;if(t<0)f=e+1;else{if(!(t>0)){g=e;break}g=e-1}}const p=g;if(h[p]===s)return p/l;const d=h[p];return(p+(s-d)/(h[p+1]-d))/l}},{"./lengths":16}],13:[function(e,t,s){const getPointType=function(e){let t=null;return e.forEach((e=>{let s="";if(Number.isFinite(e))s="float_single";else{if(!Array.isArray(e))throw new Error("Bezier points must all be numbers or arrays of number.");e.forEach((e=>{if(!Number.isFinite(e))throw new Error("Bezier point values must all be numbers.")})),s="float_"+e.length}if(null==t)t=s;else if(t!==s)throw new Error("Bezier points must be either all numbers or all arrays of numbers of the same size.")})),t},getPermutations=function(e){const t=[];for(let s=0;s<=e;s++)t.push(factorial(e)/(factorial(s)*factorial(e-s)));return t},factorial=function(e){let t=1;for(let s=2;s<=e;s++)t*=s;return t};t.exports=e=>{if(!Array.isArray(e))throw new Error("Bezier points must be a valid array/");if(e.length<2)throw new Error("Bezier points must contain at least 2 values.");const t=getPointType(e);return{points:e,pointType:t,dimensions:"float_single"===t?0:e[0].length,permutations:getPermutations(e.length-1),tangentPermutations:getPermutations(e.length-2)}}},{}],14:[function(e,t,s){t.exports={create:e("./create"),valueAt:e("./valueAt"),tangentAt:e("./tangentAt"),lengths:e("./lengths"),length:e("./length"),arcLengthToT:e("./arcLengthToT")}},{"./arcLengthToT":12,"./create":13,"./length":15,"./lengths":16,"./tangentAt":17,"./valueAt":18}],15:[function(e,t,s){const c=e("./lengths");t.exports=(e,t)=>c(e,t)[e]},{"./lengths":16}],16:[function(e,t,s){const c=e("./valueAt"),distanceBetween=(e,t)=>{if(Number.isFinite(e)&&Number.isFinite(t))return Math.abs(e-t);if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)throw new Error("The operands must have the same number of dimensions.");let s=0;for(let c=0;c<e.length;c++)s+=(t[c]-e[c])*(t[c]-e[c]);return Math.sqrt(s)}throw new Error("The operands must be of the same type, either number or array.")};t.exports=(e,t)=>{let s=0;const l=[0];let h=c(0,t);for(let f=1;f<=e;f++){const g=c(f/e,t);s+=distanceBetween(g,h),l.push(s),h=g}return l}},{"./valueAt":18}],17:[function(e,t,s){const bezierTangent=function(e,t,s){const c=t.length-1;let l=0;for(let h=0;h<c;h++){const f=c*(t[h+1]-t[h]);l+=e.tangentPermutations[h]*Math.pow(1-s,c-1-h)*Math.pow(s,h)*f}return l};t.exports=(e,t)=>{if(e<0||e>1)throw new Error("Bezier tangentAt() input must be between 0 and 1");if("float_single"===t.pointType)return bezierTangent(t,t.points,e);{const s=[];for(let c=0;c<t.dimensions;c++){const l=[];for(let e=0;e<t.points.length;e++)l.push(t.points[e][c]);s.push(bezierTangent(t,l,e))}return s}}},{}],18:[function(e,t,s){const bezierFunction=function(e,t,s){const c=t.length-1;let l=0;for(let h=0;h<=c;h++)l+=e.permutations[h]*Math.pow(1-s,c-h)*Math.pow(s,h)*t[h];return l};t.exports=(e,t)=>{if(e<0||e>1)throw new Error("Bezier valueAt() input must be between 0 and 1");if("float_single"===t.pointType)return bezierFunction(t,t.points,e);{const s=[];for(let c=0;c<t.dimensions;c++){const l=[];for(let e=0;e<t.points.length;e++)l.push(t.points[e][c]);s.push(bezierFunction(t,l,e))}return s}}},{}],19:[function(e,t,s){t.exports={bezier:e("./bezier")}},{"./bezier":14}],20:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../maths/vec2");t.exports=e=>(c.isIdentity(e.transforms)||(e.sides=e.sides.map((t=>[l.transform(l.create(),t[0],e.transforms),l.transform(l.create(),t[1],e.transforms)])),e.transforms=c.create()),e)},{"../../maths/mat4":142,"../../maths/vec2":190}],21:[function(e,t,s){t.exports=e=>Object.assign({},e)},{}],22:[function(e,t,s){const c=e("../../maths/mat4");t.exports=e=>(void 0===e&&(e=[]),{sides:e,transforms:c.create()})},{"../../maths/mat4":142}],23:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../maths/vec2"),h=e("./create");t.exports=e=>{if(0!==e[0])throw new Error("invalid compact binary data");const t=h();t.transforms=c.clone(e.slice(1,17));for(let s=21;s<e.length;s+=4){const c=l.fromValues(e[s+0],e[s+1]),h=l.fromValues(e[s+2],e[s+3]);t.sides.push([c,h])}return e[17]>=0&&(t.color=[e[17],e[18],e[19],e[20]]),t}},{"../../maths/mat4":142,"../../maths/vec2":190,"./create":22}],24:[function(e,t,s){const c=e("../../maths/vec2"),l=e("./create");t.exports=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");let t=e.length;if(t<3)throw new Error("the given points must define a closed geometry with three or more points");c.equals(e[0],e[t-1])&&--t;const s=[];let h=e[t-1];for(let l=0;l<t;l++){const t=e[l];s.push([c.clone(h),c.clone(t)]),h=t}return l(s)}},{"../../maths/vec2":190,"./create":22}],25:[function(e,t,s){t.exports={clone:e("./clone"),create:e("./create"),fromPoints:e("./fromPoints"),fromCompactBinary:e("./fromCompactBinary"),isA:e("./isA"),reverse:e("./reverse"),toOutlines:e("./toOutlines"),toPoints:e("./toPoints"),toSides:e("./toSides"),toString:e("./toString"),toCompactBinary:e("./toCompactBinary"),transform:e("./transform"),validate:e("./validate")}},{"./clone":21,"./create":22,"./fromCompactBinary":23,"./fromPoints":24,"./isA":26,"./reverse":27,"./toCompactBinary":28,"./toOutlines":29,"./toPoints":30,"./toSides":31,"./toString":32,"./transform":33,"./validate":34}],26:[function(e,t,s){t.exports=e=>!!(e&&"object"==typeof e&&"sides"in e&&"transforms"in e&&Array.isArray(e.sides)&&"length"in e.transforms)},{}],27:[function(e,t,s){const c=e("./create"),l=e("./toSides");t.exports=e=>{const t=l(e).map((e=>[e[1],e[0]]));return t.reverse(),c(t)}},{"./create":22,"./toSides":31}],28:[function(e,t,s){t.exports=e=>{const t=e.sides,s=e.transforms;let c=[-1,-1,-1,-1];e.color&&(c=e.color);const l=new Float32Array(21+4*t.length);l[0]=0,l[1]=s[0],l[2]=s[1],l[3]=s[2],l[4]=s[3],l[5]=s[4],l[6]=s[5],l[7]=s[6],l[8]=s[7],l[9]=s[8],l[10]=s[9],l[11]=s[10],l[12]=s[11],l[13]=s[12],l[14]=s[13],l[15]=s[14],l[16]=s[15],l[17]=c[0],l[18]=c[1],l[19]=c[2],l[20]=c[3];for(let e=0;e<t.length;e++){const s=4*e+21,c=t[e][0],h=t[e][1];l[s+0]=c[0],l[s+1]=c[1],l[s+2]=h[0],l[s+3]=h[1]}return l}},{}],29:[function(e,t,s){const c=e("../../maths/vec2"),l=e("./toSides"),toVertexMap=e=>{const t=new Map;return(e=>{const t=new Map,r=e=>{const s=e.toString();return t.has(s)?t.get(s):(t.set(s,e),e)};return e.map((e=>e.map(r)))})(e).forEach((e=>{t.has(e[0])?t.get(e[0]).push(e):t.set(e[0],[e])})),t},popNextSide=(e,t)=>{if(1===t.length)return t.pop();const s=c.create(),l=c.angleDegrees(c.subtract(s,e[1],e[0]));let h,f;t.forEach(((e,t)=>{let g=c.angleDegrees(c.subtract(s,e[1],e[0]))-l;g<-180&&(g+=360),g>=180&&(g-=360),(void 0===f||g>h)&&(f=t,h=g)}));const g=t[f];return t.splice(f,1),g};t.exports=e=>{const t=toVertexMap(l(e)),s=[];for(;;){let e;for(const[s,c]of t){if(e=c.shift())break;t.delete(s)}if(void 0===e)break;const c=[],l=e[0];for(;;){c.push(e[0]);const s=e[1];if(s===l)break;const h=t.get(s);if(!h)throw new Error(`geometry is not closed at vertex ${s}`);const f=popNextSide(e,h);0===h.length&&t.delete(s),e=f}c.length>0&&c.push(c.shift()),s.push(c)}return t.clear(),s}},{"../../maths/vec2":190,"./toSides":31}],30:[function(e,t,s){const c=e("./toSides");t.exports=e=>{const t=c(e).map((e=>e[0]));return t.length>0&&t.push(t.shift()),t}},{"./toSides":31}],31:[function(e,t,s){const c=e("./applyTransforms");t.exports=e=>c(e).sides},{"./applyTransforms":20}],32:[function(e,t,s){const c=e("../../maths/vec2"),l=e("./toSides");t.exports=e=>{const t=l(e);let s="geom2 ("+t.length+" sides):\n[\n";return t.forEach((e=>{s+="  ["+c.toString(e[0])+", "+c.toString(e[1])+"]\n"})),s+="]\n"}},{"../../maths/vec2":190,"./toSides":31}],33:[function(e,t,s){const c=e("../../maths/mat4"),l=e("./reverse.js");t.exports=(e,t)=>{const s=c.multiply(c.create(),e,t.transforms),h=Object.assign({},t,{transforms:s});return e[0]*e[5]-e[4]*e[1]<0?l(h):h}},{"../../maths/mat4":142,"./reverse.js":27}],34:[function(e,t,s){const c=e("../../maths/vec2"),l=e("./isA"),h=e("./toOutlines");t.exports=e=>{if(!l(e))throw new Error("invalid geom2 structure");if(h(e),e.sides.forEach((e=>{if(c.equals(e[0],e[1]))throw new Error(`geom2 self-edge ${e[0]}`)})),!e.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${e.transforms}`)}},{"../../maths/vec2":190,"./isA":26,"./toOutlines":29}],35:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../poly3");t.exports=e=>(c.isIdentity(e.transforms)||(e.polygons=e.polygons.map((t=>l.transform(e.transforms,t))),e.transforms=c.create()),e)},{"../../maths/mat4":142,"../poly3":78}],36:[function(e,t,s){t.exports=e=>Object.assign({},e)},{}],37:[function(e,t,s){const c=e("../../maths/mat4");t.exports=e=>(void 0===e&&(e=[]),{polygons:e,transforms:c.create()})},{"../../maths/mat4":142}],38:[function(e,t,s){const c=e("../../maths/vec3"),l=e("../../maths/mat4"),h=e("../poly3"),f=e("./create");t.exports=e=>{if(1!==e[0])throw new Error("invalid compact binary data");const t=f();t.transforms=l.clone(e.slice(1,17));const s=e[21];let g=22,p=e.length-3*s;for(;p<e.length;){const s=e[g];g++;const l=[];for(let t=0;t<s;t++)l.push(c.fromValues(e[p],e[p+1],e[p+2])),p+=3;t.polygons.push(h.create(l))}return e[17]>=0&&(t.color=[e[17],e[18],e[19],e[20]]),t}},{"../../maths/mat4":142,"../../maths/vec3":221,"../poly3":78,"./create":37}],39:[function(e,t,s){const c=e("../poly3"),l=e("./create");t.exports=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");const t=e.map(((e,t)=>c.create(e)));return l(t)}},{"../poly3":78,"./create":37}],40:[function(e,t,s){t.exports={clone:e("./clone"),create:e("./create"),fromPoints:e("./fromPoints"),fromCompactBinary:e("./fromCompactBinary"),invert:e("./invert"),isA:e("./isA"),toPoints:e("./toPoints"),toPolygons:e("./toPolygons"),toString:e("./toString"),toCompactBinary:e("./toCompactBinary"),transform:e("./transform"),validate:e("./validate")}},{"./clone":36,"./create":37,"./fromCompactBinary":38,"./fromPoints":39,"./invert":41,"./isA":42,"./toCompactBinary":43,"./toPoints":44,"./toPolygons":45,"./toString":46,"./transform":47,"./validate":48}],41:[function(e,t,s){const c=e("../poly3"),l=e("./create"),h=e("./toPolygons");t.exports=e=>{const t=h(e).map((e=>c.invert(e)));return l(t)}},{"../poly3":78,"./create":37,"./toPolygons":45}],42:[function(e,t,s){t.exports=e=>!!(e&&"object"==typeof e&&"polygons"in e&&"transforms"in e&&Array.isArray(e.polygons)&&"length"in e.transforms)},{}],43:[function(e,t,s){const c=e("../poly3");t.exports=e=>{const t=e.polygons,s=e.transforms,l=t.length,h=t.reduce(((e,t)=>e+t.vertices.length),0);let f=[-1,-1,-1,-1];e.color&&(f=e.color);const g=new Float32Array(22+l+3*h);g[0]=1,g[1]=s[0],g[2]=s[1],g[3]=s[2],g[4]=s[3],g[5]=s[4],g[6]=s[5],g[7]=s[6],g[8]=s[7],g[9]=s[8],g[10]=s[9],g[11]=s[10],g[12]=s[11],g[13]=s[12],g[14]=s[13],g[15]=s[14],g[16]=s[15],g[17]=f[0],g[18]=f[1],g[19]=f[2],g[20]=f[3],g[21]=h;let p=22,d=p+l;return t.forEach((e=>{const t=c.toPoints(e);g[p]=t.length,p++;for(let e=0;e<t.length;e++){const s=t[e];g[d+0]=s[0],g[d+1]=s[1],g[d+2]=s[2],d+=3}})),g}},{"../poly3":78}],44:[function(e,t,s){const c=e("../poly3"),l=e("./toPolygons");t.exports=e=>l(e).map((e=>c.toPoints(e)))},{"../poly3":78,"./toPolygons":45}],45:[function(e,t,s){const c=e("./applyTransforms");t.exports=e=>c(e).polygons},{"./applyTransforms":35}],46:[function(e,t,s){const c=e("../poly3"),l=e("./toPolygons");t.exports=e=>{const t=l(e);let s="geom3 ("+t.length+" polygons):\n";return t.forEach((e=>{s+="  "+c.toString(e)+"\n"})),s}},{"../poly3":78,"./toPolygons":45}],47:[function(e,t,s){const c=e("../../maths/mat4");t.exports=(e,t)=>{const s=c.multiply(c.create(),e,t.transforms);return Object.assign({},t,{transforms:s})}},{"../../maths/mat4":142}],48:[function(e,t,s){const c=e("../poly3"),l=e("./isA"),validateManifold=e=>{const t=new Map;e.polygons.forEach((({vertices:e})=>{e.forEach(((s,c)=>{const l=`${s}/${e[(c+1)%e.length]}`,h=t.has(l)?t.get(l):0;t.set(l,h+1)}))}));const s=[];if(t.forEach(((e,c)=>{const l=c.split("/").reverse().join("/");e!==t.get(l)&&s.push(c.replace("/"," -> "))})),s.length>0)throw new Error(`non-manifold edges ${s.length}\n${s.join("\n")}`)};t.exports=e=>{if(!l(e))throw new Error("invalid geom3 structure");if(e.polygons.forEach(c.validate),validateManifold(e),!e.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${e.transforms}`)}},{"../poly3":78,"./isA":42}],49:[function(e,t,s){t.exports={geom2:e("./geom2"),geom3:e("./geom3"),path2:e("./path2"),poly2:e("./poly2"),poly3:e("./poly3")}},{"./geom2":25,"./geom3":40,"./path2":61,"./poly2":72,"./poly3":78}],50:[function(e,t,s){const{TAU:c}=e("../../maths/constants"),l=e("../../maths/vec2"),h=e("./fromPoints"),f=e("./toPoints");t.exports=(e,t)=>{let{endpoint:s,radius:g,xaxisrotation:p,clockwise:d,large:x,segments:w}=Object.assign({},{radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16},e);if(!Array.isArray(s))throw new Error("endpoint must be an array of X and Y values");if(s.length<2)throw new Error("endpoint must contain X and Y values");if(s=l.clone(s),!Array.isArray(g))throw new Error("radius must be an array of X and Y values");if(g.length<2)throw new Error("radius must contain X and Y values");if(w<4)throw new Error("segments must be four or more");if(t.isClosed)throw new Error("the given path cannot be closed");const b=f(t);if(b.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let E=g[0],A=g[1];const M=b[b.length-1];E=Math.round(1e5*E)/1e5,A=Math.round(1e5*A)/1e5,s=l.fromValues(Math.round(1e5*s[0])/1e5,Math.round(1e5*s[1])/1e5);const S=!d;let k=[];if(0===E||0===A)k.push(s);else{E=Math.abs(E),A=Math.abs(A);const t=p,h=Math.cos(t),f=Math.sin(t),g=l.subtract(l.create(),M,s);l.scale(g,g,.5);const d=Math.round(1e5*(h*g[0]+f*g[1]))/1e5,b=Math.round(1e5*(-f*g[0]+h*g[1]))/1e5,N=l.fromValues(d,b),C=N[0]*N[0]/(E*E)+N[1]*N[1]/(A*A);if(C>1){const e=Math.sqrt(C);E*=e,A*=e,E=Math.round(1e5*E)/1e5,A=Math.round(1e5*A)/1e5}let V=Math.sqrt((E*E*A*A-E*E*N[1]*N[1]-A*A*N[0]*N[0])/(E*E*N[1]*N[1]+A*A*N[0]*N[0]));S===x&&(V=-V);const q=l.fromValues(E*N[1]/A,-A*N[0]/E);l.scale(q,q,V);let R=l.fromValues(h*q[0]-f*q[1],f*q[0]+h*q[1]);R=l.add(R,R,l.scale(l.create(),l.add(l.create(),M,s),.5));const O=l.fromValues((N[0]-q[0])/E,(N[1]-q[1])/A),B=l.fromValues((-N[0]-q[0])/E,(-N[1]-q[1])/A),F=l.angleRadians(O);let z=l.angleRadians(B)-F;z%=c,!S&&z>0?z-=c:S&&z<0&&(z+=c);let D=Math.ceil(Math.abs(z)/c*w)+1;D<1&&(D=1);for(let e=1;e<D;e++){const t=F+e/D*z,s=Math.cos(t),c=Math.sin(t),g=l.fromValues(h*E*s-f*A*c,f*E*s+h*A*c);l.add(g,g,R),k.push(g)}D&&k.push(e.endpoint)}return k=b.concat(k),h({},k)}},{"../../maths/constants":93,"../../maths/vec2":190,"./fromPoints":60,"./toPoints":65}],51:[function(e,t,s){const{TAU:c}=e("../../maths/constants"),l=e("../../maths/vec2"),h=e("../../maths/vec2"),f=e("./appendPoints"),g=e("./toPoints");t.exports=(e,t)=>{let{controlPoints:s,segments:p}=Object.assign({},{segments:16},e);if(!Array.isArray(s))throw new Error("controlPoints must be an array of one or more points");if(s.length<1)throw new Error("controlPoints must be an array of one or more points");if(p<4)throw new Error("segments must be four or more");if(t.isClosed)throw new Error("the given geometry cannot be closed");const d=g(t);if(d.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");if(null===(s=s.slice())[0]){if(s.length<2)throw new Error("a null control point must be passed with one more control points");let e=d[d.length-2];if("lastBezierControlPoint"in t&&(e=t.lastBezierControlPoint),!Array.isArray(e))throw new Error("the given path must contain TWO or more points if given a null control point");const c=l.scale(l.create(),d[d.length-1],2);l.subtract(c,c,e),s[0]=c}s.unshift(d[d.length-1]);const x=s.length-1,w=[];let b=1;for(let e=0;e<=x;++e)e>0&&(b*=e),w.push(b);const E=[];for(let e=0;e<=x;++e){const t=w[x]/(w[e]*w[x-e]);E.push(t)}const A=l.create(),M=l.create(),S=h.create(),u=e=>{let t=1,c=Math.pow(1-e,x);const h=1!==e?1/(1-e):1,f=l.create();for(let g=0;g<=x;++g){g===x&&(c=1);const p=E[g]*t*c,d=l.scale(A,s[g],p);l.add(f,f,d),t*=e,c*=h}return f},k=[],N=[],C=x+1;for(let e=0;e<C;++e){const t=e/(C-1),s=u(t);k.push(s),N.push(t)}let V=1;const q=c/p,R=Math.sin(q);for(;V<k.length-1;){const e=l.subtract(A,k[V],k[V-1]);l.normalize(e,e);const t=l.subtract(M,k[V+1],k[V]);l.normalize(t,t);const s=l.cross(S,e,t);if(Math.abs(s[2])>R){const e=N[V-1],t=N[V+1],s=e+1*(t-e)/3,c=e+2*(t-e)/3,l=u(s),h=u(c);k.splice(V,1,l,h),N.splice(V,1,s,c),--V<1&&(V=1)}else++V}k.shift();const O=f(k,t);return O.lastBezierControlPoint=s[s.length-2],O}},{"../../maths/constants":93,"../../maths/vec2":190,"./appendPoints":52,"./toPoints":65}],52:[function(e,t,s){const c=e("./concat"),l=e("./create");t.exports=(e,t)=>c(t,l(e))},{"./concat":56,"./create":57}],53:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../maths/vec2");t.exports=e=>(c.isIdentity(e.transforms)||(e.points=e.points.map((t=>l.transform(l.create(),t,e.transforms))),e.transforms=c.create()),e)},{"../../maths/mat4":142,"../../maths/vec2":190}],54:[function(e,t,s){t.exports=e=>Object.assign({},e)},{}],55:[function(e,t,s){const{EPS:c}=e("../../maths/constants"),l=e("../../maths/vec2"),h=e("./clone");t.exports=e=>{if(e.isClosed)return e;const t=h(e);if(t.isClosed=!0,t.points.length>1){const e=t.points,s=e[0];let h=e[e.length-1];for(;l.distance(s,h)<c*c&&(e.pop(),1!==e.length);)h=e[e.length-1]}return t}},{"../../maths/constants":93,"../../maths/vec2":190,"./clone":54}],56:[function(e,t,s){const c=e("./fromPoints"),l=e("./toPoints"),{equals:h}=e("../../maths/vec2");t.exports=(...e)=>{let t=!1,s=[];return e.forEach(((e,c)=>{const f=l(e).slice();if(s.length>0&&f.length>0&&h(f[0],s[s.length-1])&&f.shift(),f.length>0&&t)throw new Error(`Cannot concatenate to a closed path; check the ${c}th path`);t=e.isClosed,s=s.concat(f)})),c({closed:t},s)}},{"../../maths/vec2":190,"./fromPoints":60,"./toPoints":65}],57:[function(e,t,s){const c=e("../../maths/mat4");t.exports=e=>(void 0===e&&(e=[]),{points:e,isClosed:!1,transforms:c.create()})},{"../../maths/mat4":142}],58:[function(e,t,s){const c=e("../../maths/vec2"),l=e("./toPoints");t.exports=(e,t)=>{if(e.isClosed!==t.isClosed)return!1;if(e.points.length!==t.points.length)return!1;const s=l(e),h=l(t),f=s.length;let g=0;do{let t=!1;for(let e=0;e<f;e++)if(!c.equals(s[e],h[(e+g)%f])){t=!0;break}if(!1===t)return!0;if(!e.isClosed)return!1}while(++g<f);return!1}},{"../../maths/vec2":190,"./toPoints":65}],59:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../maths/vec2"),h=e("./create");t.exports=e=>{if(2!==e[0])throw new Error("invalid compact binary data");const t=h();t.transforms=c.clone(e.slice(1,17)),t.isClosed=!!e[17];for(let s=22;s<e.length;s+=2){const c=l.fromValues(e[s],e[s+1]);t.points.push(c)}return e[18]>=0&&(t.color=[e[18],e[19],e[20],e[21]]),t}},{"../../maths/mat4":142,"../../maths/vec2":190,"./create":57}],60:[function(e,t,s){const{EPS:c}=e("../../maths/constants"),l=e("../../maths/vec2"),h=e("./close"),f=e("./create");t.exports=(e,t)=>{let{closed:s}=Object.assign({},{closed:!1},e),g=f();if(g.points=t.map((e=>l.clone(e))),g.points.length>1){const e=g.points[0],t=g.points[g.points.length-1];l.distance(e,t)<c*c&&(s=!0)}return!0===s&&(g=h(g)),g}},{"../../maths/constants":93,"../../maths/vec2":190,"./close":55,"./create":57}],61:[function(e,t,s){t.exports={appendArc:e("./appendArc"),appendBezier:e("./appendBezier"),appendPoints:e("./appendPoints"),clone:e("./clone"),close:e("./close"),concat:e("./concat"),create:e("./create"),equals:e("./equals"),fromPoints:e("./fromPoints"),fromCompactBinary:e("./fromCompactBinary"),isA:e("./isA"),reverse:e("./reverse"),toPoints:e("./toPoints"),toString:e("./toString"),toCompactBinary:e("./toCompactBinary"),transform:e("./transform"),validate:e("./validate")}},{"./appendArc":50,"./appendBezier":51,"./appendPoints":52,"./clone":54,"./close":55,"./concat":56,"./create":57,"./equals":58,"./fromCompactBinary":59,"./fromPoints":60,"./isA":62,"./reverse":63,"./toCompactBinary":64,"./toPoints":65,"./toString":66,"./transform":67,"./validate":68}],62:[function(e,t,s){t.exports=e=>!!(e&&"object"==typeof e&&"points"in e&&"transforms"in e&&"isClosed"in e&&Array.isArray(e.points)&&"length"in e.transforms)},{}],63:[function(e,t,s){const c=e("./clone");t.exports=e=>{const t=c(e);return t.points=e.points.slice().reverse(),t}},{"./clone":54}],64:[function(e,t,s){t.exports=e=>{const t=e.points,s=e.transforms;let c=[-1,-1,-1,-1];e.color&&(c=e.color);const l=new Float32Array(22+2*t.length);l[0]=2,l[1]=s[0],l[2]=s[1],l[3]=s[2],l[4]=s[3],l[5]=s[4],l[6]=s[5],l[7]=s[6],l[8]=s[7],l[9]=s[8],l[10]=s[9],l[11]=s[10],l[12]=s[11],l[13]=s[12],l[14]=s[13],l[15]=s[14],l[16]=s[15],l[17]=e.isClosed?1:0,l[18]=c[0],l[19]=c[1],l[20]=c[2],l[21]=c[3];for(let e=0;e<t.length;e++){const s=2*e+22,c=t[e];l[s]=c[0],l[s+1]=c[1]}return l}},{}],65:[function(e,t,s){const c=e("./applyTransforms");t.exports=e=>c(e).points},{"./applyTransforms":53}],66:[function(e,t,s){const c=e("../../maths/vec2"),l=e("./toPoints");t.exports=e=>{const t=l(e);let s="path ("+t.length+" points, "+e.isClosed+"):\n[\n";return t.forEach((e=>{s+="  "+c.toString(e)+",\n"})),s+="]\n"}},{"../../maths/vec2":190,"./toPoints":65}],67:[function(e,t,s){const c=e("../../maths/mat4");t.exports=(e,t)=>{const s=c.multiply(c.create(),e,t.transforms);return Object.assign({},t,{transforms:s})}},{"../../maths/mat4":142}],68:[function(e,t,s){const c=e("../../maths/vec2"),l=e("./isA");t.exports=e=>{if(!l(e))throw new Error("invalid path2 structure");if(e.points.length>1)for(let t=0;t<e.points.length;t++)if(c.equals(e.points[t],e.points[(t+1)%e.points.length]))throw new Error(`path2 duplicate points ${e.points[t]}`);if(e.points.forEach((e=>{if(!e.every(Number.isFinite))throw new Error(`path2 invalid point ${e}`)})),!e.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${e.transforms}`)}},{"../../maths/vec2":190,"./isA":62}],69:[function(e,t,s){const c=e("./measureArea"),l=e("./flip"),isPointInside=(e,t)=>{const s=t.length,c=e[0],l=e[1];let h=t[s-1],f=t[0],g=h[1]>l,p=0,d=0;for(let e=s+1;--e;){const e=f[1]>l;if(g!==e){const e=h[0]>c,t=f[0]>c;(e&&t||f[0]-(f[1]-l)*(h[0]-f[0])/(h[1]-f[1])>=c)&&(p=!p)}g=e,h=f,f=t[++d]}return p};t.exports=(e,t)=>{if(0===e.length)return 0;const s=t.vertices;return s.length<3?0:(c(t)<0&&(t=l(t)),e.reduce(((e,t)=>e+isPointInside(t,s)),0)===e.length?1:0)}},{"./flip":71,"./measureArea":73}],70:[function(e,t,s){t.exports=e=>((void 0===e||e.length<3)&&(e=[]),{vertices:e})},{}],71:[function(e,t,s){const c=e("./create");t.exports=e=>{const t=e.vertices.slice().reverse();return c(t)}},{"./create":70}],72:[function(e,t,s){t.exports={arePointsInside:e("./arePointsInside"),create:e("./create"),flip:e("./flip"),measureArea:e("./measureArea")}},{"./arePointsInside":69,"./create":70,"./flip":71,"./measureArea":73}],73:[function(e,t,s){const c=e("../../maths/utils/area");t.exports=e=>c(e.vertices)},{"../../maths/utils/area":167}],74:[function(e,t,s){const c=e("./create"),l=e("../../maths/vec3");t.exports=(...e)=>{let t,s;return 1===e.length?(t=c(),s=e[0]):(t=e[0],s=e[1]),t.vertices=s.vertices.map((e=>l.clone(e))),t}},{"../../maths/vec3":221,"./create":75}],75:[function(e,t,s){t.exports=e=>((void 0===e||e.length<3)&&(e=[]),{vertices:e})},{}],76:[function(e,t,s){const c=e("../../maths/vec3"),l=e("./create");t.exports=e=>{const t=e.map((e=>c.clone(e)));return l(t)}},{"../../maths/vec3":221,"./create":75}],77:[function(e,t,s){const c=e("./create");t.exports=(e,t)=>{const s=c(e);return s.plane=t,s}},{"./create":75}],78:[function(e,t,s){t.exports={clone:e("./clone"),create:e("./create"),fromPoints:e("./fromPoints"),fromPointsAndPlane:e("./fromPointsAndPlane"),invert:e("./invert"),isA:e("./isA"),isConvex:e("./isConvex"),measureArea:e("./measureArea"),measureBoundingBox:e("./measureBoundingBox"),measureBoundingSphere:e("./measureBoundingSphere"),measureSignedVolume:e("./measureSignedVolume"),plane:e("./plane"),toPoints:e("./toPoints"),toString:e("./toString"),transform:e("./transform"),validate:e("./validate")}},{"./clone":74,"./create":75,"./fromPoints":76,"./fromPointsAndPlane":77,"./invert":79,"./isA":80,"./isConvex":81,"./measureArea":82,"./measureBoundingBox":83,"./measureBoundingSphere":84,"./measureSignedVolume":85,"./plane":86,"./toPoints":87,"./toString":88,"./transform":89,"./validate":90}],79:[function(e,t,s){const c=e("../../maths/plane"),l=e("./create");t.exports=e=>{const t=e.vertices.slice().reverse(),s=l(t);return e.plane&&(s.plane=c.flip(c.create(),e.plane)),s}},{"../../maths/plane":162,"./create":75}],80:[function(e,t,s){t.exports=e=>!!(e&&"object"==typeof e&&"vertices"in e&&Array.isArray(e.vertices))},{}],81:[function(e,t,s){const c=e("../../maths/plane"),l=e("../../maths/vec3"),areVerticesConvex=e=>{const t=e.length;if(t>2){const s=c.fromPoints(c.create(),...e);let l=e[t-2],h=e[t-1];for(let c=0;c<t;c++){const t=e[c];if(!isConvexPoint(l,h,t,s))return!1;l=h,h=t}}return!0},isConvexPoint=(e,t,s,c)=>{const h=l.cross(l.create(),l.subtract(l.create(),t,e),l.subtract(l.create(),s,t));return l.dot(h,c)>=0};t.exports=e=>areVerticesConvex(e.vertices)},{"../../maths/plane":162,"../../maths/vec3":221}],82:[function(e,t,s){const c=e("./plane");t.exports=e=>{const t=e.vertices.length;if(t<3)return 0;const s=e.vertices,l=c(e),h=Math.abs(l[0]),f=Math.abs(l[1]),g=Math.abs(l[2]);if(h+f+g===0)return 0;let p=3;h>f&&h>g?p=1:f>g&&(p=2);let d=0,x=0,w=1,b=2;switch(p){case 1:for(w=1;w<t;w++)x=w-1,b=(w+1)%t,d+=s[w][1]*(s[b][2]-s[x][2]);d+=s[0][1]*(s[1][2]-s[t-1][2]),d/=2*l[0];break;case 2:for(w=1;w<t;w++)x=w-1,b=(w+1)%t,d+=s[w][2]*(s[b][0]-s[x][0]);d+=s[0][2]*(s[1][0]-s[t-1][0]),d/=2*l[1];break;default:for(w=1;w<t;w++)x=w-1,b=(w+1)%t,d+=s[w][0]*(s[b][1]-s[x][1]);d+=s[0][0]*(s[1][1]-s[t-1][1]),d/=2*l[2]}return d}},{"./plane":86}],83:[function(e,t,s){const c=e("../../maths/vec3");t.exports=e=>{const t=e.vertices,s=t.length,l=0===s?c.create():c.clone(t[0]),h=c.clone(l);for(let e=1;e<s;e++)c.min(l,l,t[e]),c.max(h,h,t[e]);return[l,h]}},{"../../maths/vec3":221}],84:[function(e,t,s){const c=e("../../maths/vec4"),l=new WeakMap;t.exports=e=>{const t=l.get(e);if(t)return t;const s=e.vertices,h=c.create();if(0===s.length)return h[0]=0,h[1]=0,h[2]=0,h[3]=0,h;let f=s[0],g=f,p=f,d=f,x=f,w=f;s.forEach((e=>{f[0]>e[0]&&(f=e),g[1]>e[1]&&(g=e),p[2]>e[2]&&(p=e),d[0]<e[0]&&(d=e),x[1]<e[1]&&(x=e),w[2]<e[2]&&(w=e)})),h[0]=.5*(f[0]+d[0]),h[1]=.5*(g[1]+x[1]),h[2]=.5*(p[2]+w[2]);const b=h[0]-d[0],E=h[1]-x[1],A=h[2]-w[2];return h[3]=Math.sqrt(b*b+E*E+A*A),l.set(e,h),h}},{"../../maths/vec4":247}],85:[function(e,t,s){const c=e("../../maths/vec3");t.exports=e=>{let t=0;const s=e.vertices,l=c.create();for(let e=0;e<s.length-2;e++)c.cross(l,s[e+1],s[e+2]),t+=c.dot(s[0],l);return t/6}},{"../../maths/vec3":221}],86:[function(e,t,s){const c=e("../../maths/plane/");t.exports=e=>(e.plane||(e.plane=c.fromPoints(c.create(),...e.vertices)),e.plane)},{"../../maths/plane/":162}],87:[function(e,t,s){t.exports=e=>e.vertices},{}],88:[function(e,t,s){const c=e("../../maths/vec3/");t.exports=e=>{let t="poly3: vertices: [";return e.vertices.forEach((e=>{t+=`${c.toString(e)}, `})),t+="]"}},{"../../maths/vec3/":221}],89:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../maths/vec3"),h=e("./create");t.exports=(e,t)=>{const s=t.vertices.map((t=>l.transform(l.create(),t,e)));return c.isMirroring(e)&&s.reverse(),h(s)}},{"../../maths/mat4":142,"../../maths/vec3":221,"./create":75}],90:[function(e,t,s){const c=e("../../maths/plane/signedDistanceToPoint"),{NEPS:l}=e("../../maths/constants"),h=e("../../maths/vec3"),f=e("./isA"),g=e("./isConvex"),p=e("./measureArea"),d=e("./plane");t.exports=e=>{if(!f(e))throw new Error("invalid poly3 structure");if(e.vertices.length<3)throw new Error(`poly3 not enough vertices ${e.vertices.length}`);if(p(e)<=0)throw new Error("poly3 area must be greater than zero");for(let t=0;t<e.vertices.length;t++)if(h.equals(e.vertices[t],e.vertices[(t+1)%e.vertices.length]))throw new Error(`poly3 duplicate vertex ${e.vertices[t]}`);if(!g(e))throw new Error("poly3 must be convex");if(e.vertices.forEach((e=>{if(!e.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${e}`)})),e.vertices.length>3){const t=d(e);e.vertices.forEach((e=>{const s=Math.abs(c(t,e));if(s>l)throw new Error(`poly3 must be coplanar: vertex ${e} distance ${s}`)}))}}},{"../../maths/constants":93,"../../maths/plane/signedDistanceToPoint":164,"../../maths/vec3":221,"./isA":80,"./isConvex":81,"./measureArea":82,"./plane":86}],91:[function(e,t,s){t.exports={colors:e("./colors"),curves:e("./curves"),geometries:e("./geometries"),maths:e("./maths"),measurements:e("./measurements"),primitives:e("./primitives"),text:e("./text"),utils:e("./utils"),booleans:e("./operations/booleans"),expansions:e("./operations/expansions"),extrusions:e("./operations/extrusions"),hulls:e("./operations/hulls"),modifiers:e("./operations/modifiers"),transforms:e("./operations/transforms")}},{"./colors":8,"./curves":19,"./geometries":49,"./maths":94,"./measurements":251,"./operations/booleans":265,"./operations/expansions":294,"./operations/extrusions":317,"./operations/hulls":339,"./operations/modifiers":350,"./operations/transforms":360,"./primitives":376,"./text":390,"./utils":398}],92:[function(e,t,s){const c=e("./mat4"),l=e("./vec2"),h=e("./vec3"),OrthoNormalBasis=function(e,t){arguments.length<2&&(t=h.orthogonal(h.create(),e)),this.v=h.normalize(h.create(),h.cross(h.create(),e,t)),this.u=h.cross(h.create(),this.v,e),this.plane=e,this.planeorigin=h.scale(h.create(),e,e[3])};OrthoNormalBasis.GetCartesian=function(e,t){const s=e+"/"+t;let c,l;if("X/Y"===s)c=[0,0,1],l=[1,0,0];else if("Y/-X"===s)c=[0,0,1],l=[0,1,0];else if("-X/-Y"===s)c=[0,0,1],l=[-1,0,0];else if("-Y/X"===s)c=[0,0,1],l=[0,-1,0];else if("-X/Y"===s)c=[0,0,-1],l=[-1,0,0];else if("-Y/-X"===s)c=[0,0,-1],l=[0,-1,0];else if("X/-Y"===s)c=[0,0,-1],l=[1,0,0];else if("Y/X"===s)c=[0,0,-1],l=[0,1,0];else if("X/Z"===s)c=[0,-1,0],l=[1,0,0];else if("Z/-X"===s)c=[0,-1,0],l=[0,0,1];else if("-X/-Z"===s)c=[0,-1,0],l=[-1,0,0];else if("-Z/X"===s)c=[0,-1,0],l=[0,0,-1];else if("-X/Z"===s)c=[0,1,0],l=[-1,0,0];else if("-Z/-X"===s)c=[0,1,0],l=[0,0,-1];else if("X/-Z"===s)c=[0,1,0],l=[1,0,0];else if("Z/X"===s)c=[0,1,0],l=[0,0,1];else if("Y/Z"===s)c=[1,0,0],l=[0,1,0];else if("Z/-Y"===s)c=[1,0,0],l=[0,0,1];else if("-Y/-Z"===s)c=[1,0,0],l=[0,-1,0];else if("-Z/Y"===s)c=[1,0,0],l=[0,0,-1];else if("-Y/Z"===s)c=[-1,0,0],l=[0,-1,0];else if("-Z/-Y"===s)c=[-1,0,0],l=[0,0,-1];else if("Y/-Z"===s)c=[-1,0,0],l=[0,1,0];else{if("Z/Y"!==s)throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");c=[-1,0,0],l=[0,0,1]}return new OrthoNormalBasis(new Plane(new Vector3D(c),0),new Vector3D(l))},OrthoNormalBasis.Z0Plane=function(){const e=new Plane(new Vector3D([0,0,1]),0);return new OrthoNormalBasis(e,new Vector3D([1,0,0]))},OrthoNormalBasis.prototype={getProjectionMatrix:function(){return c.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const e=h.scale(h.create(),this.plane,this.plane[3]);return c.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,e[0],e[1],e[2],1)},to2D:function(e){return l.fromValues(h.dot(e,this.u),h.dot(e,this.v))},to3D:function(e){const t=h.scale(h.create(),this.u,e[0]),s=h.scale(h.create(),this.v,e[1]),c=h.add(t,t,this.planeorigin);return h.add(s,s,c)},line3Dto2D:function(e){const t=e.point,s=e.direction.plus(t),c=this.to2D(t),l=this.to2D(s);return Line2D.fromPoints(c,l)},line2Dto3D:function(e){const t=e.origin(),s=e.direction().plus(t),c=this.to3D(t),l=this.to3D(s);return Line3D.fromPoints(c,l)},transform:function(e){const t=this.plane.transform(e),s=this.u.transform(e),c=new Vector3D(0,0,0).transform(e),l=s.minus(c);return new OrthoNormalBasis(t,l)}},t.exports=OrthoNormalBasis},{"./mat4":142,"./vec2":190,"./vec3":221}],93:[function(e,t,s){const c=2*Math.PI;t.exports={EPS:1e-5,NEPS:1e-13,TAU:c,spatialResolution:1e5}},{}],94:[function(e,t,s){t.exports={constants:e("./constants"),line2:e("./line2"),line3:e("./line3"),mat4:e("./mat4"),plane:e("./plane"),utils:e("./utils"),vec2:e("./vec2"),vec3:e("./vec3"),vec4:e("./vec4")}},{"./constants":93,"./line2":104,"./line3":121,"./mat4":142,"./plane":162,"./utils":168,"./vec2":190,"./vec3":221,"./vec4":247}],95:[function(e,t,s){const c=e("./create");t.exports=e=>{const t=c();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}},{"./create":98}],96:[function(e,t,s){const c=e("../vec2"),l=e("./direction"),h=e("./origin");t.exports=(e,t)=>{const s=h(e),f=l(e),g=c.subtract(c.create(),t,s),p=c.dot(g,f);return c.scale(g,f,p),c.add(g,g,s),g}},{"../vec2":190,"./direction":99,"./origin":106}],97:[function(e,t,s){t.exports=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e)},{}],98:[function(e,t,s){t.exports=()=>[0,1,0]},{}],99:[function(e,t,s){const c=e("../vec2");t.exports=e=>{const t=c.normal(c.create(),e);return c.negate(t,t),t}},{"../vec2":190}],100:[function(e,t,s){const c=e("../vec2");t.exports=(e,t)=>{let s=c.dot(t,e);return Math.abs(s-e[2])}},{"../vec2":190}],101:[function(e,t,s){t.exports=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},{}],102:[function(e,t,s){const c=e("../vec2");t.exports=(e,t,s)=>{const l=c.subtract(c.create(),s,t);c.normal(l,l),c.normalize(l,l);const h=c.dot(t,l);return e[0]=l[0],e[1]=l[1],e[2]=h,e}},{"../vec2":190}],103:[function(e,t,s){const c=e("./create");t.exports=(e,t,s)=>{const l=c();return l[0]=e,l[1]=t,l[2]=s,l}},{"./create":98}],104:[function(e,t,s){t.exports={clone:e("./clone"),closestPoint:e("./closestPoint"),copy:e("./copy"),create:e("./create"),direction:e("./direction"),distanceToPoint:e("./distanceToPoint"),equals:e("./equals"),fromPoints:e("./fromPoints"),fromValues:e("./fromValues"),intersectPointOfLines:e("./intersectPointOfLines"),origin:e("./origin"),reverse:e("./reverse"),toString:e("./toString"),transform:e("./transform"),xAtY:e("./xAtY")}},{"./clone":95,"./closestPoint":96,"./copy":97,"./create":98,"./direction":99,"./distanceToPoint":100,"./equals":101,"./fromPoints":102,"./fromValues":103,"./intersectPointOfLines":105,"./origin":106,"./reverse":107,"./toString":108,"./transform":109,"./xAtY":110}],105:[function(e,t,s){const c=e("../vec2"),{solve2Linear:l}=e("../utils");t.exports=(e,t)=>{const s=l(e[0],e[1],t[0],t[1],e[2],t[2]);return c.clone(s)}},{"../utils":168,"../vec2":190}],106:[function(e,t,s){const c=e("../vec2");t.exports=e=>c.scale(c.create(),e,e[2])},{"../vec2":190}],107:[function(e,t,s){const c=e("../vec2"),l=e("./copy"),h=e("./fromValues");t.exports=(e,t)=>{const s=c.negate(c.create(),t),f=-t[2];return l(e,h(s[0],s[1],f))}},{"../vec2":190,"./copy":97,"./fromValues":103}],108:[function(e,t,s){t.exports=e=>`line2: (${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)})`},{}],109:[function(e,t,s){const c=e("../vec2"),l=e("./fromPoints"),h=e("./origin"),f=e("./direction");t.exports=(e,t,s)=>{const g=h(t),p=f(t);return c.transform(g,g,s),c.transform(p,p,s),l(e,g,p)}},{"../vec2":190,"./direction":99,"./fromPoints":102,"./origin":106}],110:[function(e,t,s){const c=e("./origin");t.exports=(e,t)=>{let s=(e[2]-e[1]*t)/e[0];return Number.isNaN(s)&&(s=c(e)[0]),s}},{"./origin":106}],111:[function(e,t,s){const c=e("../vec3"),l=e("./create");t.exports=e=>{const t=l();return c.copy(t[0],e[0]),c.copy(t[1],e[1]),t}},{"../vec3":221,"./create":114}],112:[function(e,t,s){const c=e("../vec3");t.exports=(e,t)=>{const s=e[0],l=e[1],h=c.dot(c.subtract(c.create(),t,s),l)/c.dot(l,l),f=c.scale(c.create(),l,h);return c.add(f,f,s),f}},{"../vec3":221}],113:[function(e,t,s){const c=e("../vec3");t.exports=(e,t)=>(c.copy(e[0],t[0]),c.copy(e[1],t[1]),e)},{"../vec3":221}],114:[function(e,t,s){const c=e("../vec3");t.exports=()=>[c.fromValues(0,0,0),c.fromValues(0,0,1)]},{"../vec3":221}],115:[function(e,t,s){t.exports=e=>e[1]},{}],116:[function(e,t,s){const c=e("../vec3"),l=e("./closestPoint");t.exports=(e,t)=>{const s=l(e,t),h=c.subtract(c.create(),t,s);return c.length(h)}},{"../vec3":221,"./closestPoint":112}],117:[function(e,t,s){const c=e("../vec3");t.exports=(e,t)=>!!c.equals(e[1],t[1])&&!!c.equals(e[0],t[0])},{"../vec3":221}],118:[function(e,t,s){const c=e("../vec3"),{solve2Linear:l}=e("../utils"),{EPS:h}=e("../constants"),f=e("./fromPointAndDirection");t.exports=(e,t,s)=>{let g=c.cross(c.create(),t,s),p=c.length(g);if(p<h)throw new Error("parallel planes do not intersect");p=1/p,g=c.scale(g,g,p);const d=Math.abs(g[0]),x=Math.abs(g[1]),w=Math.abs(g[2]);let b,E;return d>=x&&d>=w?(E=l(t[1],t[2],s[1],s[2],t[3],s[3]),b=c.fromValues(0,E[0],E[1])):x>=d&&x>=w?(E=l(t[0],t[2],s[0],s[2],t[3],s[3]),b=c.fromValues(E[0],0,E[1])):(E=l(t[0],t[1],s[0],s[1],t[3],s[3]),b=c.fromValues(E[0],E[1],0)),f(e,b,g)}},{"../constants":93,"../utils":168,"../vec3":221,"./fromPointAndDirection":119}],119:[function(e,t,s){const c=e("../vec3");t.exports=(e,t,s)=>{const l=c.normalize(c.create(),s);return c.copy(e[0],t),c.copy(e[1],l),e}},{"../vec3":221}],120:[function(e,t,s){const c=e("../vec3"),l=e("./fromPointAndDirection");t.exports=(e,t,s)=>{const h=c.subtract(c.create(),s,t);return l(e,t,h)}},{"../vec3":221,"./fromPointAndDirection":119}],121:[function(e,t,s){t.exports={clone:e("./clone"),closestPoint:e("./closestPoint"),copy:e("./copy"),create:e("./create"),direction:e("./direction"),distanceToPoint:e("./distanceToPoint"),equals:e("./equals"),fromPlanes:e("./fromPlanes"),fromPointAndDirection:e("./fromPointAndDirection"),fromPoints:e("./fromPoints"),intersectPointOfLineAndPlane:e("./intersectPointOfLineAndPlane"),origin:e("./origin"),reverse:e("./reverse"),toString:e("./toString"),transform:e("./transform")}},{"./clone":111,"./closestPoint":112,"./copy":113,"./create":114,"./direction":115,"./distanceToPoint":116,"./equals":117,"./fromPlanes":118,"./fromPointAndDirection":119,"./fromPoints":120,"./intersectPointOfLineAndPlane":122,"./origin":123,"./reverse":124,"./toString":125,"./transform":126}],122:[function(e,t,s){const c=e("../vec3");t.exports=(e,t)=>{const s=t,l=t[3],h=e[0],f=e[1],g=(l-c.dot(s,h))/c.dot(s,f);return c.add(c.create(),h,c.scale(c.create(),f,g))}},{"../vec3":221}],123:[function(e,t,s){t.exports=e=>e[0]},{}],124:[function(e,t,s){const c=e("../vec3"),l=e("./fromPointAndDirection");t.exports=(e,t)=>{const s=c.clone(t[0]),h=c.negate(c.create(),t[1]);return l(e,s,h)}},{"../vec3":221,"./fromPointAndDirection":119}],125:[function(e,t,s){t.exports=e=>{const t=e[0],s=e[1];return`line3: point: (${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)}) direction: (${s[0].toFixed(7)}, ${s[1].toFixed(7)}, ${s[2].toFixed(7)})`}},{}],126:[function(e,t,s){const c=e("../vec3"),l=e("./fromPointAndDirection");t.exports=(e,t,s)=>{const h=t[0],f=t[1],g=c.add(c.create(),h,f),p=c.transform(c.create(),h,s),d=c.transform(g,g,s),x=c.subtract(d,d,p);return l(e,p,x)}},{"../vec3":221,"./fromPointAndDirection":119}],127:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]+s[0],e[1]=t[1]+s[1],e[2]=t[2]+s[2],e[3]=t[3]+s[3],e[4]=t[4]+s[4],e[5]=t[5]+s[5],e[6]=t[6]+s[6],e[7]=t[7]+s[7],e[8]=t[8]+s[8],e[9]=t[9]+s[9],e[10]=t[10]+s[10],e[11]=t[11]+s[11],e[12]=t[12]+s[12],e[13]=t[13]+s[13],e[14]=t[14]+s[14],e[15]=t[15]+s[15],e)},{}],128:[function(e,t,s){const c=e("./create");t.exports=e=>{const t=c();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}},{"./create":130}],129:[function(e,t,s){t.exports=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e)},{}],130:[function(e,t,s){t.exports=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},{}],131:[function(e,t,s){t.exports=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},{}],132:[function(e,t,s){const{EPS:c}=e("../constants"),{sin:l,cos:h}=e("../utils/trigonometry"),f=e("./identity");t.exports=(e,t,s)=>{let[g,p,d]=s;const x=g*g+p*p+d*d;if(Math.abs(x)<c)return f(e);const w=1/Math.sqrt(x);g*=w,p*=w,d*=w;const b=l(t),E=h(t),A=1-E;return e[0]=g*g*A+E,e[1]=p*g*A+d*b,e[2]=d*g*A-p*b,e[3]=0,e[4]=g*p*A-d*b,e[5]=p*p*A+E,e[6]=d*p*A+g*b,e[7]=0,e[8]=g*d*A+p*b,e[9]=p*d*A-g*b,e[10]=d*d*A+E,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}},{"../constants":93,"../utils/trigonometry":172,"./identity":141}],133:[function(e,t,s){t.exports=(e,t)=>(e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)},{}],134:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t,s,h)=>{const f=c(t),g=l(t),p=c(s),d=l(s),x=c(h),w=l(h);return e[0]=d*g,e[1]=d*f,e[2]=-p,e[3]=0,e[4]=x*p*g-w*f,e[5]=w*g+x*p*f,e[6]=x*d,e[7]=0,e[8]=x*f+w*p*g,e[9]=w*p*f-x*g,e[10]=w*d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}},{"../utils/trigonometry":172}],135:[function(e,t,s){t.exports=(e,t)=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e)},{}],136:[function(e,t,s){const c=e("./create");t.exports=(e,t,s,l,h,f,g,p,d,x,w,b,E,A,M,S)=>{const k=c();return k[0]=e,k[1]=t,k[2]=s,k[3]=l,k[4]=h,k[5]=f,k[6]=g,k[7]=p,k[8]=d,k[9]=x,k[10]=w,k[11]=b,k[12]=E,k[13]=A,k[14]=M,k[15]=S,k}},{"./create":130}],137:[function(e,t,s){const c=e("../vec3"),l=e("./fromRotation");t.exports=(e,t,s)=>{const h=c.normalize(c.create(),t),f=c.normalize(c.create(),s),g=c.cross(c.create(),f,h),p=c.dot(f,h);if(-1===p)return l(e,Math.PI,c.orthogonal(g,h));const d=1/(1+p);return e[0]=g[0]*g[0]*d+p,e[1]=g[1]*g[0]*d-g[2],e[2]=g[2]*g[0]*d+g[1],e[3]=0,e[4]=g[0]*g[1]*d+g[2],e[5]=g[1]*g[1]*d+p,e[6]=g[2]*g[1]*d-g[0],e[7]=0,e[8]=g[0]*g[2]*d-g[1],e[9]=g[1]*g[2]*d+g[0],e[10]=g[2]*g[2]*d+p,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}},{"../vec3":221,"./fromRotation":132}],138:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t)=>{const s=c(t),h=l(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=h,e[6]=s,e[7]=0,e[8]=0,e[9]=-s,e[10]=h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}},{"../utils/trigonometry":172}],139:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t)=>{const s=c(t),h=l(t);return e[0]=h,e[1]=0,e[2]=-s,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=s,e[9]=0,e[10]=h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}},{"../utils/trigonometry":172}],140:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t)=>{const s=c(t),h=l(t);return e[0]=h,e[1]=s,e[2]=0,e[3]=0,e[4]=-s,e[5]=h,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}},{"../utils/trigonometry":172}],141:[function(e,t,s){t.exports=e=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)},{}],142:[function(e,t,s){t.exports={add:e("./add"),clone:e("./clone"),copy:e("./copy"),create:e("./create"),invert:e("./invert"),equals:e("./equals"),fromRotation:e("./fromRotation"),fromScaling:e("./fromScaling"),fromTaitBryanRotation:e("./fromTaitBryanRotation"),fromTranslation:e("./fromTranslation"),fromValues:e("./fromValues"),fromVectorRotation:e("./fromVectorRotation"),fromXRotation:e("./fromXRotation"),fromYRotation:e("./fromYRotation"),fromZRotation:e("./fromZRotation"),identity:e("./identity"),isIdentity:e("./isIdentity"),isOnlyTransformScale:e("./isOnlyTransformScale"),isMirroring:e("./isMirroring"),mirrorByPlane:e("./mirrorByPlane"),multiply:e("./multiply"),rotate:e("./rotate"),rotateX:e("./rotateX"),rotateY:e("./rotateY"),rotateZ:e("./rotateZ"),scale:e("./scale"),subtract:e("./subtract"),toString:e("./toString"),translate:e("./translate")}},{"./add":127,"./clone":128,"./copy":129,"./create":130,"./equals":131,"./fromRotation":132,"./fromScaling":133,"./fromTaitBryanRotation":134,"./fromTranslation":135,"./fromValues":136,"./fromVectorRotation":137,"./fromXRotation":138,"./fromYRotation":139,"./fromZRotation":140,"./identity":141,"./invert":143,"./isIdentity":144,"./isMirroring":145,"./isOnlyTransformScale":146,"./mirrorByPlane":147,"./multiply":148,"./rotate":149,"./rotateX":150,"./rotateY":151,"./rotateZ":152,"./scale":153,"./subtract":154,"./toString":155,"./translate":156}],143:[function(e,t,s){t.exports=(e,t)=>{const s=t[0],c=t[1],l=t[2],h=t[3],f=t[4],g=t[5],p=t[6],d=t[7],x=t[8],w=t[9],b=t[10],E=t[11],A=t[12],M=t[13],S=t[14],k=t[15],N=s*g-c*f,C=s*p-l*f,V=s*d-h*f,q=c*p-l*g,R=c*d-h*g,O=l*d-h*p,B=x*M-w*A,F=x*S-b*A,z=x*k-E*A,D=w*S-b*M,j=w*k-E*M,Z=b*k-E*S;let G=N*Z-C*j+V*D+q*z-R*F+O*B;return G?(G=1/G,e[0]=(g*Z-p*j+d*D)*G,e[1]=(l*j-c*Z-h*D)*G,e[2]=(M*O-S*R+k*q)*G,e[3]=(b*R-w*O-E*q)*G,e[4]=(p*z-f*Z-d*F)*G,e[5]=(s*Z-l*z+h*F)*G,e[6]=(S*V-A*O-k*C)*G,e[7]=(x*O-b*V+E*C)*G,e[8]=(f*j-g*z+d*B)*G,e[9]=(c*z-s*j-h*B)*G,e[10]=(A*R-M*V+k*N)*G,e[11]=(w*V-x*R-E*N)*G,e[12]=(g*F-f*D-p*B)*G,e[13]=(s*D-c*F+l*B)*G,e[14]=(M*C-A*q-S*N)*G,e[15]=(x*q-w*C+b*N)*G,e):null}},{}],144:[function(e,t,s){t.exports=e=>1===e[0]&&0===e[1]&&0===e[2]&&0===e[3]&&0===e[4]&&1===e[5]&&0===e[6]&&0===e[7]&&0===e[8]&&0===e[9]&&1===e[10]&&0===e[11]&&0===e[12]&&0===e[13]&&0===e[14]&&1===e[15]},{}],145:[function(e,t,s){t.exports=e=>{const t=e[4]*e[9]-e[8]*e[5],s=e[8]*e[1]-e[0]*e[9],c=e[0]*e[5]-e[4]*e[1];return t*e[2]+s*e[6]+c*e[10]<0}},{}],146:[function(e,t,s){const isZero=e=>Math.abs(e)<Number.EPSILON;t.exports=e=>isZero(e[1])&&isZero(e[2])&&isZero(e[3])&&isZero(e[4])&&isZero(e[6])&&isZero(e[7])&&isZero(e[8])&&isZero(e[9])&&isZero(e[11])&&1===e[15]},{}],147:[function(e,t,s){t.exports=(e,t)=>{const[s,c,l,h]=t;return e[0]=1-2*s*s,e[1]=-2*c*s,e[2]=-2*l*s,e[3]=0,e[4]=-2*s*c,e[5]=1-2*c*c,e[6]=-2*l*c,e[7]=0,e[8]=-2*s*l,e[9]=-2*c*l,e[10]=1-2*l*l,e[11]=0,e[12]=2*s*h,e[13]=2*c*h,e[14]=2*l*h,e[15]=1,e}},{}],148:[function(e,t,s){t.exports=(e,t,s)=>{const c=t[0],l=t[1],h=t[2],f=t[3],g=t[4],p=t[5],d=t[6],x=t[7],w=t[8],b=t[9],E=t[10],A=t[11],M=t[12],S=t[13],k=t[14],N=t[15];let C=s[0],V=s[1],q=s[2],R=s[3];return e[0]=C*c+V*g+q*w+R*M,e[1]=C*l+V*p+q*b+R*S,e[2]=C*h+V*d+q*E+R*k,e[3]=C*f+V*x+q*A+R*N,C=s[4],V=s[5],q=s[6],R=s[7],e[4]=C*c+V*g+q*w+R*M,e[5]=C*l+V*p+q*b+R*S,e[6]=C*h+V*d+q*E+R*k,e[7]=C*f+V*x+q*A+R*N,C=s[8],V=s[9],q=s[10],R=s[11],e[8]=C*c+V*g+q*w+R*M,e[9]=C*l+V*p+q*b+R*S,e[10]=C*h+V*d+q*E+R*k,e[11]=C*f+V*x+q*A+R*N,C=s[12],V=s[13],q=s[14],R=s[15],e[12]=C*c+V*g+q*w+R*M,e[13]=C*l+V*p+q*b+R*S,e[14]=C*h+V*d+q*E+R*k,e[15]=C*f+V*x+q*A+R*N,e}},{}],149:[function(e,t,s){const{EPS:c}=e("../constants"),{sin:l,cos:h}=e("../utils/trigonometry"),f=e("./copy");t.exports=(e,t,s,g)=>{let[p,d,x]=g;const w=p*p+d*d+x*x;if(Math.abs(w)<c)return f(e,t);const b=1/Math.sqrt(w);p*=b,d*=b,x*=b;const E=l(s),A=h(s),M=1-A,S=t[0],k=t[1],N=t[2],C=t[3],V=t[4],q=t[5],R=t[6],O=t[7],B=t[8],F=t[9],z=t[10],D=t[11],j=p*p*M+A,Z=d*p*M+x*E,G=x*p*M-d*E,X=p*d*M-x*E,$=d*d*M+A,L=x*d*M+p*E,Y=p*x*M+d*E,I=d*x*M-p*E,U=x*x*M+A;return e[0]=S*j+V*Z+B*G,e[1]=k*j+q*Z+F*G,e[2]=N*j+R*Z+z*G,e[3]=C*j+O*Z+D*G,e[4]=S*X+V*$+B*L,e[5]=k*X+q*$+F*L,e[6]=N*X+R*$+z*L,e[7]=C*X+O*$+D*L,e[8]=S*Y+V*I+B*U,e[9]=k*Y+q*I+F*U,e[10]=N*Y+R*I+z*U,e[11]=C*Y+O*I+D*U,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e}},{"../constants":93,"../utils/trigonometry":172,"./copy":129}],150:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t,s)=>{const h=c(s),f=l(s),g=t[4],p=t[5],d=t[6],x=t[7],w=t[8],b=t[9],E=t[10],A=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=g*f+w*h,e[5]=p*f+b*h,e[6]=d*f+E*h,e[7]=x*f+A*h,e[8]=w*f-g*h,e[9]=b*f-p*h,e[10]=E*f-d*h,e[11]=A*f-x*h,e}},{"../utils/trigonometry":172}],151:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t,s)=>{const h=c(s),f=l(s),g=t[0],p=t[1],d=t[2],x=t[3],w=t[8],b=t[9],E=t[10],A=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=g*f-w*h,e[1]=p*f-b*h,e[2]=d*f-E*h,e[3]=x*f-A*h,e[8]=g*h+w*f,e[9]=p*h+b*f,e[10]=d*h+E*f,e[11]=x*h+A*f,e}},{"../utils/trigonometry":172}],152:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t,s)=>{const h=c(s),f=l(s),g=t[0],p=t[1],d=t[2],x=t[3],w=t[4],b=t[5],E=t[6],A=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=g*f+w*h,e[1]=p*f+b*h,e[2]=d*f+E*h,e[3]=x*f+A*h,e[4]=w*f-g*h,e[5]=b*f-p*h,e[6]=E*f-d*h,e[7]=A*f-x*h,e}},{"../utils/trigonometry":172}],153:[function(e,t,s){t.exports=(e,t,s)=>{const c=s[0],l=s[1],h=s[2];return e[0]=t[0]*c,e[1]=t[1]*c,e[2]=t[2]*c,e[3]=t[3]*c,e[4]=t[4]*l,e[5]=t[5]*l,e[6]=t[6]*l,e[7]=t[7]*l,e[8]=t[8]*h,e[9]=t[9]*h,e[10]=t[10]*h,e[11]=t[11]*h,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}},{}],154:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]-s[0],e[1]=t[1]-s[1],e[2]=t[2]-s[2],e[3]=t[3]-s[3],e[4]=t[4]-s[4],e[5]=t[5]-s[5],e[6]=t[6]-s[6],e[7]=t[7]-s[7],e[8]=t[8]-s[8],e[9]=t[9]-s[9],e[10]=t[10]-s[10],e[11]=t[11]-s[11],e[12]=t[12]-s[12],e[13]=t[13]-s[13],e[14]=t[14]-s[14],e[15]=t[15]-s[15],e)},{}],155:[function(e,t,s){t.exports=e=>e.map((e=>e.toFixed(7))).toString()},{}],156:[function(e,t,s){t.exports=(e,t,s)=>{const c=s[0],l=s[1],h=s[2];let f,g,p,d,x,w,b,E,A,M,S,k;return t===e?(e[12]=t[0]*c+t[4]*l+t[8]*h+t[12],e[13]=t[1]*c+t[5]*l+t[9]*h+t[13],e[14]=t[2]*c+t[6]*l+t[10]*h+t[14],e[15]=t[3]*c+t[7]*l+t[11]*h+t[15]):(f=t[0],g=t[1],p=t[2],d=t[3],x=t[4],w=t[5],b=t[6],E=t[7],A=t[8],M=t[9],S=t[10],k=t[11],e[0]=f,e[1]=g,e[2]=p,e[3]=d,e[4]=x,e[5]=w,e[6]=b,e[7]=E,e[8]=A,e[9]=M,e[10]=S,e[11]=k,e[12]=f*c+x*l+A*h+t[12],e[13]=g*c+w*l+M*h+t[13],e[14]=p*c+b*l+S*h+t[14],e[15]=d*c+E*l+k*h+t[15]),e}},{}],157:[function(e,t,s){t.exports=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e)},{}],158:[function(e,t,s){const c=e("../vec3"),l=e("./fromNormalAndPoint");t.exports=(e,...t)=>{e[0]=0,e[1]=0,e[2]=0,e[3]=0;const s=t.length;t.forEach((t=>{c.add(e,e,t)})),c.scale(e,e,1/s);let h=0,f=0,g=0,p=0,d=0,x=0;const w=c.create();t.forEach((t=>{c.subtract(w,t,e),h+=w[0]*w[0],f+=w[0]*w[1],g+=w[0]*w[2],p+=w[1]*w[1],d+=w[1]*w[2],x+=w[2]*w[2]})),h/=s,f/=s,g/=s,p/=s,d/=s,x/=s,w[0]=0,w[1]=0,w[2]=0;const b=c.create();let E=p*x-d*d;b[0]=E,b[1]=g*d-f*x,b[2]=f*d-g*p;let A=E*E;return c.add(w,w,c.scale(b,b,A)),E=h*x-g*g,b[0]=g*d-f*x,b[1]=E,b[2]=f*g-d*h,A=E*E,c.dot(w,b)<0&&(A=-A),c.add(w,w,c.scale(b,b,A)),E=h*p-f*f,b[0]=f*d-g*p,b[1]=f*g-d*h,b[2]=E,A=E*E,c.dot(w,b)<0&&(A=-A),c.add(w,w,c.scale(b,b,A)),l(e,w,e)}},{"../vec3":221,"./fromNormalAndPoint":159}],159:[function(e,t,s){const c=e("../vec3");t.exports=(e,t,s)=>{const l=c.normalize(c.create(),t),h=c.dot(s,l);return e[0]=l[0],e[1]=l[1],e[2]=l[2],e[3]=h,e}},{"../vec3":221}],160:[function(e,t,s){const c=e("../vec3");t.exports=(e,...t)=>{const s=t.length,l=c.create(),h=c.create(),v=e=>{const f=t[e],g=t[(e+1)%s],p=t[(e+2)%s];return c.subtract(l,g,f),c.subtract(h,p,f),c.cross(l,l,h),c.normalize(l,l),l};return e[0]=0,e[1]=0,e[2]=0,3===s?c.copy(e,v(0)):(t.forEach(((t,s)=>{c.add(e,e,v(s))})),c.normalize(e,e)),e[3]=c.dot(e,t[0]),e}},{"../vec3":221}],161:[function(e,t,s){const{EPS:c}=e("../constants"),l=e("../vec3");t.exports=(e,t,s,h)=>{let f=l.subtract(l.create(),s,t),g=l.subtract(l.create(),h,t);l.length(f)<c&&(f=l.orthogonal(f,g)),l.length(g)<c&&(g=l.orthogonal(g,f));let p=l.cross(l.create(),f,g);l.length(p)<c&&(g=l.orthogonal(g,f),p=l.cross(p,f,g)),p=l.normalize(p,p);const d=l.dot(p,t);return e[0]=p[0],e[1]=p[1],e[2]=p[2],e[3]=d,e}},{"../constants":93,"../vec3":221}],162:[function(e,t,s){t.exports={clone:e("../vec4/clone"),copy:e("../vec4/copy"),create:e("../vec4/create"),equals:e("../vec4/equals"),flip:e("./flip"),fromNormalAndPoint:e("./fromNormalAndPoint"),fromValues:e("../vec4/fromValues"),fromNoisyPoints:e("./fromNoisyPoints"),fromPoints:e("./fromPoints"),fromPointsRandom:e("./fromPointsRandom"),projectionOfPoint:e("./projectionOfPoint"),signedDistanceToPoint:e("./signedDistanceToPoint"),toString:e("../vec4/toString"),transform:e("./transform")}},{"../vec4/clone":240,"../vec4/copy":241,"../vec4/create":242,"../vec4/equals":244,"../vec4/fromValues":246,"../vec4/toString":248,"./flip":157,"./fromNoisyPoints":158,"./fromNormalAndPoint":159,"./fromPoints":160,"./fromPointsRandom":161,"./projectionOfPoint":163,"./signedDistanceToPoint":164,"./transform":165}],163:[function(e,t,s){const c=e("../vec3");t.exports=(e,t)=>{const s=t[0]*e[0]+t[1]*e[1]+t[2]*e[2]-e[3],l=t[0]-s*e[0],h=t[1]-s*e[1],f=t[2]-s*e[2];return c.fromValues(l,h,f)}},{"../vec3":221}],164:[function(e,t,s){const c=e("../vec3");t.exports=(e,t)=>c.dot(e,t)-e[3]},{"../vec3":221}],165:[function(e,t,s){const c=e("../mat4"),l=e("../vec3"),h=e("./fromPoints"),f=e("./flip");t.exports=(e,t,s)=>{const g=c.isMirroring(s),p=l.orthogonal(l.create(),t),d=l.cross(p,t,p),x=l.cross(l.create(),t,d);let w=l.fromScalar(l.create(),t[3]);l.multiply(w,w,t);let b=l.add(l.create(),w,d),E=l.add(l.create(),w,x);return w=l.transform(w,w,s),b=l.transform(b,b,s),E=l.transform(E,E,s),h(e,w,b,E),g&&f(e,e),e}},{"../mat4":142,"../vec3":221,"./flip":157,"./fromPoints":160}],166:[function(e,t,s){const{NEPS:c}=e("../constants");t.exports=(e,t)=>Math.abs(e[0]-t[0])<=c&&Math.abs(e[1]-t[1])<=c&&Math.abs(e[2]-t[2])<=c},{"../constants":93}],167:[function(e,t,s){t.exports=e=>{let t=0;for(let s=0;s<e.length;s++){const c=(s+1)%e.length;t+=e[s][0]*e[c][1],t-=e[c][0]*e[s][1]}return t/2}},{}],168:[function(e,t,s){t.exports={aboutEqualNormals:e("./aboutEqualNormals"),area:e("./area"),cos:e("./trigonometry").cos,interpolateBetween2DPointsForY:e("./interpolateBetween2DPointsForY"),intersect:e("./intersect"),sin:e("./trigonometry").sin,solve2Linear:e("./solve2Linear")}},{"./aboutEqualNormals":166,"./area":167,"./interpolateBetween2DPointsForY":169,"./intersect":170,"./solve2Linear":171,"./trigonometry":172}],169:[function(e,t,s){t.exports=(e,t,s)=>{let c,l=s-e[1],h=t[1]-e[1];return h<0&&(l=-l,h=-h),c=l<=0?0:l>=h?1:h<1e-10?.5:l/h,e[0]+c*(t[0]-e[0])}},{}],170:[function(e,t,s){t.exports=(e,t,s,c)=>{if(e[0]===t[0]&&e[1]===t[1]||s[0]===c[0]&&s[1]===c[1])return;const l=(c[1]-s[1])*(t[0]-e[0])-(c[0]-s[0])*(t[1]-e[1]);if(Math.abs(l)<Number.MIN_VALUE)return;const h=((c[0]-s[0])*(e[1]-s[1])-(c[1]-s[1])*(e[0]-s[0]))/l,f=((t[0]-e[0])*(e[1]-s[1])-(t[1]-e[1])*(e[0]-s[0]))/l;return h<0||h>1||f<0||f>1?void 0:[e[0]+h*(t[0]-e[0]),e[1]+h*(t[1]-e[1])]}},{}],171:[function(e,t,s){t.exports=(e,t,s,c,l,h)=>{const f=1/(e*c-t*s);let g=l*c-t*h,p=-l*s+e*h;return[g*=f,p*=f]}},{}],172:[function(e,t,s){const{NEPS:c}=e("../constants"),rezero=e=>Math.abs(e)<c?0:e;t.exports={sin:e=>rezero(Math.sin(e)),cos:e=>rezero(Math.cos(e))}},{"../constants":93}],173:[function(e,t,s){t.exports=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e)},{}],174:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]+s[0],e[1]=t[1]+s[1],e)},{}],175:[function(e,t,s){t.exports=e("./angleRadians")},{"./angleRadians":177}],176:[function(e,t,s){const c=e("./angleRadians");t.exports=e=>57.29577951308232*c(e)},{"./angleRadians":177}],177:[function(e,t,s){t.exports=e=>Math.atan2(e[1],e[0])},{}],178:[function(e,t,s){const c=e("./create");t.exports=e=>{const t=c();return t[0]=e[0],t[1]=e[1],t}},{"./create":180}],179:[function(e,t,s){t.exports=(e,t)=>(e[0]=t[0],e[1]=t[1],e)},{}],180:[function(e,t,s){t.exports=()=>[0,0]},{}],181:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=0,e[1]=0,e[2]=t[0]*s[1]-t[1]*s[0],e)},{}],182:[function(e,t,s){t.exports=(e,t)=>{const s=t[0]-e[0],c=t[1]-e[1];return Math.sqrt(s*s+c*c)}},{}],183:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]/s[0],e[1]=t[1]/s[1],e)},{}],184:[function(e,t,s){t.exports=(e,t)=>e[0]*t[0]+e[1]*t[1]},{}],185:[function(e,t,s){t.exports=(e,t)=>e[0]===t[0]&&e[1]===t[1]},{}],186:[function(e,t,s){const c=e("./fromAngleRadians");t.exports=(e,t)=>c(e,.017453292519943295*t)},{"./fromAngleRadians":187}],187:[function(e,t,s){const{sin:c,cos:l}=e("../utils/trigonometry");t.exports=(e,t)=>(e[0]=l(t),e[1]=c(t),e)},{"../utils/trigonometry":172}],188:[function(e,t,s){t.exports=(e,t)=>(e[0]=t,e[1]=t,e)},{}],189:[function(e,t,s){const c=e("./create");t.exports=(e,t)=>{const s=c();return s[0]=e,s[1]=t,s}},{"./create":180}],190:[function(e,t,s){t.exports={abs:e("./abs"),add:e("./add"),angle:e("./angle"),angleDegrees:e("./angleDegrees"),angleRadians:e("./angleRadians"),clone:e("./clone"),copy:e("./copy"),create:e("./create"),cross:e("./cross"),distance:e("./distance"),divide:e("./divide"),dot:e("./dot"),equals:e("./equals"),fromAngleDegrees:e("./fromAngleDegrees"),fromAngleRadians:e("./fromAngleRadians"),fromScalar:e("./fromScalar"),fromValues:e("./fromValues"),length:e("./length"),lerp:e("./lerp"),max:e("./max"),min:e("./min"),multiply:e("./multiply"),negate:e("./negate"),normal:e("./normal"),normalize:e("./normalize"),rotate:e("./rotate"),scale:e("./scale"),snap:e("./snap"),squaredDistance:e("./squaredDistance"),squaredLength:e("./squaredLength"),subtract:e("./subtract"),toString:e("./toString"),transform:e("./transform")}},{"./abs":173,"./add":174,"./angle":175,"./angleDegrees":176,"./angleRadians":177,"./clone":178,"./copy":179,"./create":180,"./cross":181,"./distance":182,"./divide":183,"./dot":184,"./equals":185,"./fromAngleDegrees":186,"./fromAngleRadians":187,"./fromScalar":188,"./fromValues":189,"./length":191,"./lerp":192,"./max":193,"./min":194,"./multiply":195,"./negate":196,"./normal":197,"./normalize":198,"./rotate":199,"./scale":200,"./snap":201,"./squaredDistance":202,"./squaredLength":203,"./subtract":204,"./toString":205,"./transform":206}],191:[function(e,t,s){t.exports=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1])},{}],192:[function(e,t,s){t.exports=(e,t,s,c)=>{const l=t[0],h=t[1];return e[0]=l+c*(s[0]-l),e[1]=h+c*(s[1]-h),e}},{}],193:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=Math.max(t[0],s[0]),e[1]=Math.max(t[1],s[1]),e)},{}],194:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=Math.min(t[0],s[0]),e[1]=Math.min(t[1],s[1]),e)},{}],195:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]*s[0],e[1]=t[1]*s[1],e)},{}],196:[function(e,t,s){t.exports=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e)},{}],197:[function(e,t,s){const{TAU:c}=e("../constants"),l=e("./create"),h=e("./rotate");t.exports=(e,t)=>h(e,t,l(),c/4)},{"../constants":93,"./create":180,"./rotate":199}],198:[function(e,t,s){t.exports=(e,t)=>{const s=t[0],c=t[1];let l=s*s+c*c;return l>0&&(l=1/Math.sqrt(l)),e[0]=s*l,e[1]=c*l,e}},{}],199:[function(e,t,s){t.exports=(e,t,s,c)=>{const l=t[0]-s[0],h=t[1]-s[1],f=Math.cos(c),g=Math.sin(c);return e[0]=l*f-h*g+s[0],e[1]=l*g+h*f+s[1],e}},{}],200:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]*s,e[1]=t[1]*s,e)},{}],201:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=Math.round(t[0]/s)*s+0,e[1]=Math.round(t[1]/s)*s+0,e)},{}],202:[function(e,t,s){t.exports=(e,t)=>{const s=t[0]-e[0],c=t[1]-e[1];return s*s+c*c}},{}],203:[function(e,t,s){t.exports=e=>{const t=e[0],s=e[1];return t*t+s*s}},{}],204:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]-s[0],e[1]=t[1]-s[1],e)},{}],205:[function(e,t,s){t.exports=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}]`},{}],206:[function(e,t,s){t.exports=(e,t,s)=>{const c=t[0],l=t[1];return e[0]=s[0]*c+s[4]*l+s[12],e[1]=s[1]*c+s[5]*l+s[13],e}},{}],207:[function(e,t,s){t.exports=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e[2]=Math.abs(t[2]),e)},{}],208:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]+s[0],e[1]=t[1]+s[1],e[2]=t[2]+s[2],e)},{}],209:[function(e,t,s){const c=e("./dot");t.exports=(e,t)=>{const s=e[0],l=e[1],h=e[2],f=t[0],g=t[1],p=t[2],d=Math.sqrt(s*s+l*l+h*h)*Math.sqrt(f*f+g*g+p*p),x=d&&c(e,t)/d;return Math.acos(Math.min(Math.max(x,-1),1))}},{"./dot":216}],210:[function(e,t,s){const c=e("./create");t.exports=e=>{const t=c();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}},{"./create":212}],211:[function(e,t,s){t.exports=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e)},{}],212:[function(e,t,s){t.exports=()=>[0,0,0]},{}],213:[function(e,t,s){t.exports=(e,t,s)=>{const c=t[0],l=t[1],h=t[2],f=s[0],g=s[1],p=s[2];return e[0]=l*p-h*g,e[1]=h*f-c*p,e[2]=c*g-l*f,e}},{}],214:[function(e,t,s){t.exports=(e,t)=>{const s=t[0]-e[0],c=t[1]-e[1],l=t[2]-e[2];return Math.sqrt(s*s+c*c+l*l)}},{}],215:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]/s[0],e[1]=t[1]/s[1],e[2]=t[2]/s[2],e)},{}],216:[function(e,t,s){t.exports=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},{}],217:[function(e,t,s){t.exports=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},{}],218:[function(e,t,s){t.exports=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e)},{}],219:[function(e,t,s){const c=e("./create");t.exports=(e,t,s)=>{const l=c();return l[0]=e,l[1]=t,l[2]=s,l}},{"./create":212}],220:[function(e,t,s){t.exports=(e,t,s=0)=>(e[0]=t[0],e[1]=t[1],e[2]=s,e)},{}],221:[function(e,t,s){t.exports={abs:e("./abs"),add:e("./add"),angle:e("./angle"),clone:e("./clone"),copy:e("./copy"),create:e("./create"),cross:e("./cross"),distance:e("./distance"),divide:e("./divide"),dot:e("./dot"),equals:e("./equals"),fromScalar:e("./fromScalar"),fromValues:e("./fromValues"),fromVec2:e("./fromVec2"),length:e("./length"),lerp:e("./lerp"),max:e("./max"),min:e("./min"),multiply:e("./multiply"),negate:e("./negate"),normalize:e("./normalize"),orthogonal:e("./orthogonal"),rotateX:e("./rotateX"),rotateY:e("./rotateY"),rotateZ:e("./rotateZ"),scale:e("./scale"),snap:e("./snap"),squaredDistance:e("./squaredDistance"),squaredLength:e("./squaredLength"),subtract:e("./subtract"),toString:e("./toString"),transform:e("./transform")}},{"./abs":207,"./add":208,"./angle":209,"./clone":210,"./copy":211,"./create":212,"./cross":213,"./distance":214,"./divide":215,"./dot":216,"./equals":217,"./fromScalar":218,"./fromValues":219,"./fromVec2":220,"./length":222,"./lerp":223,"./max":224,"./min":225,"./multiply":226,"./negate":227,"./normalize":228,"./orthogonal":229,"./rotateX":230,"./rotateY":231,"./rotateZ":232,"./scale":233,"./snap":234,"./squaredDistance":235,"./squaredLength":236,"./subtract":237,"./toString":238,"./transform":239}],222:[function(e,t,s){t.exports=e=>{const t=e[0],s=e[1],c=e[2];return Math.sqrt(t*t+s*s+c*c)}},{}],223:[function(e,t,s){t.exports=(e,t,s,c)=>(e[0]=t[0]+c*(s[0]-t[0]),e[1]=t[1]+c*(s[1]-t[1]),e[2]=t[2]+c*(s[2]-t[2]),e)},{}],224:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=Math.max(t[0],s[0]),e[1]=Math.max(t[1],s[1]),e[2]=Math.max(t[2],s[2]),e)},{}],225:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=Math.min(t[0],s[0]),e[1]=Math.min(t[1],s[1]),e[2]=Math.min(t[2],s[2]),e)},{}],226:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]*s[0],e[1]=t[1]*s[1],e[2]=t[2]*s[2],e)},{}],227:[function(e,t,s){t.exports=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e)},{}],228:[function(e,t,s){t.exports=(e,t)=>{const s=t[0],c=t[1],l=t[2];let h=s*s+c*c+l*l;return h>0&&(h=1/Math.sqrt(h)),e[0]=s*h,e[1]=c*h,e[2]=l*h,e}},{}],229:[function(e,t,s){const c=e("./abs"),l=e("./create"),h=e("./cross");t.exports=(e,t)=>{const s=c(l(),t),f=0+(s[0]<s[1]&&s[0]<s[2]),g=0+(s[1]<=s[0]&&s[1]<s[2]),p=0+(s[2]<=s[0]&&s[2]<=s[1]);return h(e,t,[f,g,p])}},{"./abs":207,"./create":212,"./cross":213}],230:[function(e,t,s){t.exports=(e,t,s,c)=>{const l=[],h=[];return l[0]=t[0]-s[0],l[1]=t[1]-s[1],l[2]=t[2]-s[2],h[0]=l[0],h[1]=l[1]*Math.cos(c)-l[2]*Math.sin(c),h[2]=l[1]*Math.sin(c)+l[2]*Math.cos(c),e[0]=h[0]+s[0],e[1]=h[1]+s[1],e[2]=h[2]+s[2],e}},{}],231:[function(e,t,s){t.exports=(e,t,s,c)=>{const l=[],h=[];return l[0]=t[0]-s[0],l[1]=t[1]-s[1],l[2]=t[2]-s[2],h[0]=l[2]*Math.sin(c)+l[0]*Math.cos(c),h[1]=l[1],h[2]=l[2]*Math.cos(c)-l[0]*Math.sin(c),e[0]=h[0]+s[0],e[1]=h[1]+s[1],e[2]=h[2]+s[2],e}},{}],232:[function(e,t,s){t.exports=(e,t,s,c)=>{const l=[],h=[];return l[0]=t[0]-s[0],l[1]=t[1]-s[1],h[0]=l[0]*Math.cos(c)-l[1]*Math.sin(c),h[1]=l[0]*Math.sin(c)+l[1]*Math.cos(c),e[0]=h[0]+s[0],e[1]=h[1]+s[1],e[2]=t[2],e}},{}],233:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e)},{}],234:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=Math.round(t[0]/s)*s+0,e[1]=Math.round(t[1]/s)*s+0,e[2]=Math.round(t[2]/s)*s+0,e)},{}],235:[function(e,t,s){t.exports=(e,t)=>{const s=t[0]-e[0],c=t[1]-e[1],l=t[2]-e[2];return s*s+c*c+l*l}},{}],236:[function(e,t,s){t.exports=e=>{const t=e[0],s=e[1],c=e[2];return t*t+s*s+c*c}},{}],237:[function(e,t,s){t.exports=(e,t,s)=>(e[0]=t[0]-s[0],e[1]=t[1]-s[1],e[2]=t[2]-s[2],e)},{}],238:[function(e,t,s){t.exports=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)}]`},{}],239:[function(e,t,s){t.exports=(e,t,s)=>{const c=t[0],l=t[1],h=t[2];let f=s[3]*c+s[7]*l+s[11]*h+s[15];return f=f||1,e[0]=(s[0]*c+s[4]*l+s[8]*h+s[12])/f,e[1]=(s[1]*c+s[5]*l+s[9]*h+s[13])/f,e[2]=(s[2]*c+s[6]*l+s[10]*h+s[14])/f,e}},{}],240:[function(e,t,s){const c=e("./create");t.exports=e=>{const t=c();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}},{"./create":242}],241:[function(e,t,s){t.exports=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e)},{}],242:[function(e,t,s){t.exports=()=>[0,0,0,0]},{}],243:[function(e,t,s){t.exports=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},{}],244:[function(e,t,s){t.exports=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},{}],245:[function(e,t,s){t.exports=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e[3]=t,e)},{}],246:[function(e,t,s){const c=e("./create");t.exports=(e,t,s,l)=>{const h=c();return h[0]=e,h[1]=t,h[2]=s,h[3]=l,h}},{"./create":242}],247:[function(e,t,s){t.exports={clone:e("./clone"),copy:e("./copy"),create:e("./create"),dot:e("./dot"),equals:e("./equals"),fromScalar:e("./fromScalar"),fromValues:e("./fromValues"),toString:e("./toString"),transform:e("./transform")}},{"./clone":240,"./copy":241,"./create":242,"./dot":243,"./equals":244,"./fromScalar":245,"./fromValues":246,"./toString":248,"./transform":249}],248:[function(e,t,s){t.exports=e=>`(${e[0].toFixed(9)}, ${e[1].toFixed(9)}, ${e[2].toFixed(9)}, ${e[3].toFixed(9)})`},{}],249:[function(e,t,s){t.exports=(e,t,s)=>{const[c,l,h,f]=t;return e[0]=s[0]*c+s[4]*l+s[8]*h+s[12]*f,e[1]=s[1]*c+s[5]*l+s[9]*h+s[13]*f,e[2]=s[2]*c+s[6]*l+s[10]*h+s[14]*f,e[3]=s[3]*c+s[7]*l+s[11]*h+s[15]*f,e}},{}],250:[function(e,t,s){const{EPS:c}=e("../maths/constants");t.exports=(e,t)=>{let s=0;for(let c=0;c<t;c++)s+=e[1][c]-e[0][c];return c*s/t}},{"../maths/constants":93}],251:[function(e,t,s){t.exports={measureAggregateArea:e("./measureAggregateArea"),measureAggregateBoundingBox:e("./measureAggregateBoundingBox"),measureAggregateEpsilon:e("./measureAggregateEpsilon"),measureAggregateVolume:e("./measureAggregateVolume"),measureArea:e("./measureArea"),measureBoundingBox:e("./measureBoundingBox"),measureBoundingSphere:e("./measureBoundingSphere"),measureCenter:e("./measureCenter"),measureCenterOfMass:e("./measureCenterOfMass"),measureDimensions:e("./measureDimensions"),measureEpsilon:e("./measureEpsilon"),measureVolume:e("./measureVolume")}},{"./measureAggregateArea":252,"./measureAggregateBoundingBox":253,"./measureAggregateEpsilon":254,"./measureAggregateVolume":255,"./measureArea":256,"./measureBoundingBox":257,"./measureBoundingSphere":258,"./measureCenter":259,"./measureCenterOfMass":260,"./measureDimensions":261,"./measureEpsilon":262,"./measureVolume":263}],252:[function(e,t,s){const c=e("../utils/flatten"),l=e("./measureArea");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("measureAggregateArea: no geometries supplied");const t=l(e);return 1===e.length?t:t.reduce(((e,t)=>e+t),0)}},{"../utils/flatten":396,"./measureArea":256}],253:[function(e,t,s){const c=e("../utils/flatten"),l=e("../maths/vec3/min"),h=e("../maths/vec3/max"),f=e("./measureBoundingBox");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("measureAggregateBoundingBox: no geometries supplied");const t=f(e);if(1===e.length)return t;const s=[[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]];return t.reduce(((e,t)=>[l(e[0],e[0],t[0]),h(e[1],e[1],t[1])]),s)}},{"../maths/vec3/max":224,"../maths/vec3/min":225,"../utils/flatten":396,"./measureBoundingBox":257}],254:[function(e,t,s){const c=e("../utils/flatten"),l=e("./measureAggregateBoundingBox"),h=e("./calculateEpsilonFromBounds"),{geom2:f,geom3:g,path2:p}=e("../geometries");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("measureAggregateEpsilon: no geometries supplied");const t=l(e);let s=0;return s=e.reduce(((e,t)=>p.isA(t)||f.isA(t)?Math.max(e,2):g.isA(t)?Math.max(e,3):0),s),h(t,s)}},{"../geometries":49,"../utils/flatten":396,"./calculateEpsilonFromBounds":250,"./measureAggregateBoundingBox":253}],255:[function(e,t,s){const c=e("../utils/flatten"),l=e("./measureVolume");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("measureAggregateVolume: no geometries supplied");const t=l(e);return 1===e.length?t:t.reduce(((e,t)=>e+t),0)}},{"../utils/flatten":396,"./measureVolume":263}],256:[function(e,t,s){const c=e("../utils/flatten"),l=e("../geometries/geom2"),h=e("../geometries/geom3"),f=e("../geometries/path2"),g=e("../geometries/poly3"),p=new WeakMap;t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");const t=e.map((e=>f.isA(e)?0:l.isA(e)?(e=>{let t=p.get(e);return t||(t=l.toSides(e).reduce(((e,t)=>e+(t[0][0]*t[1][1]-t[0][1]*t[1][0])),0),t*=.5,p.set(e,t),t)})(e):h.isA(e)?(e=>{let t=p.get(e);return t||(t=h.toPolygons(e).reduce(((e,t)=>e+g.measureArea(t)),0),p.set(e,t),t)})(e):0));return 1===t.length?t[0]:t}},{"../geometries/geom2":25,"../geometries/geom3":40,"../geometries/path2":61,"../geometries/poly3":78,"../utils/flatten":396}],257:[function(e,t,s){const c=e("../utils/flatten"),l=e("../maths/vec2"),h=e("../maths/vec3"),f=e("../geometries/geom2"),g=e("../geometries/geom3"),p=e("../geometries/path2"),d=e("../geometries/poly3"),x=new WeakMap;t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");const t=e.map((e=>p.isA(e)?(e=>{let t=x.get(e);if(t)return t;const s=p.toPoints(e);let c;c=0===s.length?l.create():l.clone(s[0]);let h=l.clone(c);return s.forEach((e=>{l.min(c,c,e),l.max(h,h,e)})),c=[c[0],c[1],0],h=[h[0],h[1],0],t=[c,h],x.set(e,t),t})(e):f.isA(e)?(e=>{let t=x.get(e);if(t)return t;const s=f.toPoints(e);let c;c=0===s.length?l.create():l.clone(s[0]);let h=l.clone(c);return s.forEach((e=>{l.min(c,c,e),l.max(h,h,e)})),c=[c[0],c[1],0],h=[h[0],h[1],0],t=[c,h],x.set(e,t),t})(e):g.isA(e)?(e=>{let t=x.get(e);if(t)return t;const s=g.toPolygons(e);let c=h.create();if(s.length>0){const e=d.toPoints(s[0]);h.copy(c,e[0])}let l=h.clone(c);return s.forEach((e=>{d.toPoints(e).forEach((e=>{h.min(c,c,e),h.max(l,l,e)}))})),c=[c[0],c[1],c[2]],l=[l[0],l[1],l[2]],t=[c,l],x.set(e,t),t})(e):[[0,0,0],[0,0,0]]));return 1===t.length?t[0]:t}},{"../geometries/geom2":25,"../geometries/geom3":40,"../geometries/path2":61,"../geometries/poly3":78,"../maths/vec2":190,"../maths/vec3":221,"../utils/flatten":396}],258:[function(e,t,s){const c=e("../utils/flatten"),l=e("../maths/vec2"),h=e("../maths/vec3"),f=e("../geometries/geom2"),g=e("../geometries/geom3"),p=e("../geometries/path2"),d=e("../geometries/poly3"),x=new WeakMap;t.exports=(...e)=>{const t=(e=c(e)).map((e=>p.isA(e)?(e=>{let t=x.get(e);if(void 0!==t)return t;const s=h.create();let c=0;const f=p.toPoints(e);if(f.length>0){let e=0;const t=h.create();f.forEach((c=>{h.add(s,s,h.fromVec2(t,c,0)),e++})),h.scale(s,s,1/e),f.forEach((e=>{c=Math.max(c,l.squaredDistance(s,e))})),c=Math.sqrt(c)}return t=[s,c],x.set(e,t),t})(e):f.isA(e)?(e=>{let t=x.get(e);if(void 0!==t)return t;const s=h.create();let c=0;const g=f.toSides(e);if(g.length>0){let e=0;const t=h.create();g.forEach((c=>{h.add(s,s,h.fromVec2(t,c[0],0)),e++})),h.scale(s,s,1/e),g.forEach((e=>{c=Math.max(c,l.squaredDistance(s,e[0]))})),c=Math.sqrt(c)}return t=[s,c],x.set(e,t),t})(e):g.isA(e)?(e=>{let t=x.get(e);if(void 0!==t)return t;const s=h.create();let c=0;const l=g.toPolygons(e);if(l.length>0){let e=0;l.forEach((t=>{d.toPoints(t).forEach((t=>{h.add(s,s,t),e++}))})),h.scale(s,s,1/e),l.forEach((e=>{d.toPoints(e).forEach((e=>{c=Math.max(c,h.squaredDistance(s,e))}))})),c=Math.sqrt(c)}return t=[s,c],x.set(e,t),t})(e):[[0,0,0],0]));return 1===t.length?t[0]:t}},{"../geometries/geom2":25,"../geometries/geom3":40,"../geometries/path2":61,"../geometries/poly3":78,"../maths/vec2":190,"../maths/vec3":221,"../utils/flatten":396}],259:[function(e,t,s){const c=e("../utils/flatten"),l=e("./measureBoundingBox");t.exports=(...e)=>{const t=(e=c(e)).map((e=>{const t=l(e);return[t[0][0]+(t[1][0]-t[0][0])/2,t[0][1]+(t[1][1]-t[0][1])/2,t[0][2]+(t[1][2]-t[0][2])/2]}));return 1===t.length?t[0]:t}},{"../utils/flatten":396,"./measureBoundingBox":257}],260:[function(e,t,s){const c=e("../utils/flatten"),l=e("../maths/vec3"),h=e("../geometries/geom2"),f=e("../geometries/geom3"),g=new WeakMap;t.exports=(...e)=>{const t=(e=c(e)).map((e=>h.isA(e)?(e=>{let t=g.get(e);if(void 0!==t)return t;const s=h.toSides(e);let c=0,f=0,p=0;if(s.length>0){for(let e=0;e<s.length;e++){const t=s[e][0],l=s[e][1],h=t[0]*l[1]-t[1]*l[0];c+=h,f+=(t[0]+l[0])*h,p+=(t[1]+l[1])*h}const e=1/(6*(c/=2));f*=e,p*=e}return t=l.fromValues(f,p,0),g.set(e,t),t})(e):f.isA(e)?(e=>{let t=g.get(e);if(void 0!==t)return t;t=l.create();const s=f.toPolygons(e);if(0===s.length)return t;let c=0;const h=l.create();return s.forEach((e=>{const s=e.vertices;for(let e=0;e<s.length-2;e++){l.cross(h,s[e+1],s[e+2]);const f=l.dot(s[0],h)/6;c+=f,l.add(h,s[0],s[e+1]),l.add(h,h,s[e+2]);const g=l.scale(h,h,.25*f);l.add(t,t,g)}})),l.scale(t,t,1/c),g.set(e,t),t})(e):[0,0,0]));return 1===t.length?t[0]:t}},{"../geometries/geom2":25,"../geometries/geom3":40,"../maths/vec3":221,"../utils/flatten":396}],261:[function(e,t,s){const c=e("../utils/flatten"),l=e("./measureBoundingBox");t.exports=(...e)=>{const t=(e=c(e)).map((e=>{const t=l(e);return[t[1][0]-t[0][0],t[1][1]-t[0][1],t[1][2]-t[0][2]]}));return 1===t.length?t[0]:t}},{"../utils/flatten":396,"./measureBoundingBox":257}],262:[function(e,t,s){const c=e("../utils/flatten"),{geom2:l,geom3:h,path2:f}=e("../geometries"),g=e("./calculateEpsilonFromBounds"),p=e("./measureBoundingBox");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");const t=e.map((e=>f.isA(e)||l.isA(e)?(e=>g(p(e),2))(e):h.isA(e)?(e=>g(p(e),3))(e):0));return 1===t.length?t[0]:t}},{"../geometries":49,"../utils/flatten":396,"./calculateEpsilonFromBounds":250,"./measureBoundingBox":257}],263:[function(e,t,s){const c=e("../utils/flatten"),l=e("../geometries/geom2"),h=e("../geometries/geom3"),f=e("../geometries/path2"),g=e("../geometries/poly3"),p=new WeakMap;t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");const t=e.map((e=>f.isA(e)||l.isA(e)?0:h.isA(e)?(e=>{let t=p.get(e);return t||(t=h.toPolygons(e).reduce(((e,t)=>e+g.measureSignedVolume(t)),0),p.set(e,t),t)})(e):0));return 1===t.length?t[0]:t}},{"../geometries/geom2":25,"../geometries/geom3":40,"../geometries/path2":61,"../geometries/poly3":78,"../utils/flatten":396}],264:[function(e,t,s){const c=e("../../maths/vec2"),l=e("../../geometries/geom2");t.exports=(e,t)=>{const s=t.map((t=>((e,t)=>{if(t.vertices.length<4)return null;const s=[],l=t.vertices.filter(((e,t)=>e[2]>0&&(s.push(t),!0)));if(2!==l.length)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const h=l.map((t=>{const s=Math.round(t[0]/e)*e+0,l=Math.round(t[1]/e)*e+0;return c.fromValues(s,l)}));if(c.equals(h[0],h[1]))return null;const f=s[1]-s[0];if(1!==f&&3!==f)throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return 1===f&&h.reverse(),h})(e,t))).filter((e=>null!==e));return l.create(s)}},{"../../geometries/geom2":25,"../../maths/vec2":190}],265:[function(e,t,s){t.exports={intersect:e("./intersect"),scission:e("./scission"),subtract:e("./subtract"),union:e("./union")}},{"./intersect":266,"./scission":271,"./subtract":273,"./union":284}],266:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../utils/areAllShapesTheSameType"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("./intersectGeom2"),p=e("./intersectGeom3");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");if(!l(e))throw new Error("only intersect of the types are supported");const t=e[0];return h.isA(t)?g(e):f.isA(t)?p(e):t}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../utils/areAllShapesTheSameType":394,"../../utils/flatten":396,"./intersectGeom2":267,"./intersectGeom3":268}],267:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom3"),h=e("../../measurements/measureEpsilon"),f=e("./fromFakePolygons"),g=e("./to3DWalls"),p=e("./intersectGeom3");t.exports=(...e)=>{const t=(e=c(e)).map((e=>g({z0:-1,z1:1},e))),s=p(t),d=h(s);return f(d,l.toPolygons(s))}},{"../../geometries/geom3":40,"../../measurements/measureEpsilon":262,"../../utils/flatten":396,"./fromFakePolygons":264,"./intersectGeom3":268,"./to3DWalls":277}],268:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../modifiers/retessellate"),h=e("./intersectGeom3Sub");t.exports=(...e)=>{let t=(e=c(e)).shift();return e.forEach((e=>{t=h(t,e)})),t=l(t)}},{"../../utils/flatten":396,"../modifiers/retessellate":354,"./intersectGeom3Sub":269}],269:[function(e,t,s){const c=e("../../geometries/geom3"),l=e("./mayOverlap"),{Tree:h}=e("./trees");t.exports=(e,t)=>{if(!l(e,t))return c.create();const s=new h(c.toPolygons(e)),f=new h(c.toPolygons(t));s.invert(),f.clipTo(s),f.invert(),s.clipTo(f),f.clipTo(s),s.addPolygons(f.allPolygons()),s.invert();const g=s.allPolygons();return c.create(g)}},{"../../geometries/geom3":40,"./mayOverlap":270,"./trees":281}],270:[function(e,t,s){const{EPS:c}=e("../../maths/constants"),l=e("../../measurements/measureBoundingBox");t.exports=(e,t)=>{if(0===e.polygons.length||0===t.polygons.length)return!1;const s=l(e),h=s[0],f=s[1],g=l(t),p=g[0],d=g[1];return!(p[0]-f[0]>c||h[0]-d[0]>c||p[1]-f[1]>c||h[1]-d[1]>c||p[2]-f[2]>c||h[2]-d[2]>c)}},{"../../maths/constants":93,"../../measurements/measureBoundingBox":257}],271:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom3"),h=e("./scissionGeom3");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");const t=e.map((e=>l.isA(e)?h(e):e));return 1===t.length?t[0]:t}},{"../../geometries/geom3":40,"../../utils/flatten":396,"./scissionGeom3":272}],272:[function(e,t,s){const c=e("../../maths/vec3"),l=e("../../measurements/measureEpsilon"),h=e("../../geometries/geom3"),sortNb=e=>e.sort(((e,t)=>e-t)).filter(((e,t,s)=>!t||e!==s[t-1]));t.exports=e=>{const t=l(e),s=h.toPolygons(e),f=s.length,g=new Map,p=c.create();s.forEach(((e,s)=>{e.vertices.forEach((e=>{((e,t,s)=>{const c=`${t}`,l=e.get(c);void 0===l?e.set(c,[s]):l.push(s)})(g,c.snap(p,e,t),s)}))}));const d=s.map((e=>{let s=[];return e.vertices.forEach((e=>{s=s.concat(((e,t)=>{const s=`${t}`;return e.get(s)})(g,c.snap(p,e,t)))})),{e:1,d:sortNb(s)}}));g.clear();let x=0;const w=d.length;for(let e=0;e<w;e++){const t=d[e];if(t.e>0){const s=new Array(f);s[e]=!0;do{x=0,s.forEach(((e,t)=>{const c=d[t];if(c.e>0){c.e=-1;for(let e=0;e<c.d.length;e++)s[c.d[e]]=!0;x++}}))}while(x>0);t.indexes=s}}const b=[];for(let e=0;e<w;e++)if(d[e].indexes){const t=[];d[e].indexes.forEach(((e,c)=>t.push(s[c]))),b.push(h.create(t))}return b}},{"../../geometries/geom3":40,"../../maths/vec3":221,"../../measurements/measureEpsilon":262}],273:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../utils/areAllShapesTheSameType"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("./subtractGeom2"),p=e("./subtractGeom3");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");if(!l(e))throw new Error("only subtract of the types are supported");const t=e[0];return h.isA(t)?g(e):f.isA(t)?p(e):t}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../utils/areAllShapesTheSameType":394,"../../utils/flatten":396,"./subtractGeom2":274,"./subtractGeom3":275}],274:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom3"),h=e("../../measurements/measureEpsilon"),f=e("./fromFakePolygons"),g=e("./to3DWalls"),p=e("./subtractGeom3");t.exports=(...e)=>{const t=(e=c(e)).map((e=>g({z0:-1,z1:1},e))),s=p(t),d=h(s);return f(d,l.toPolygons(s))}},{"../../geometries/geom3":40,"../../measurements/measureEpsilon":262,"../../utils/flatten":396,"./fromFakePolygons":264,"./subtractGeom3":275,"./to3DWalls":277}],275:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../modifiers/retessellate"),h=e("./subtractGeom3Sub");t.exports=(...e)=>{let t=(e=c(e)).shift();return e.forEach((e=>{t=h(t,e)})),t=l(t)}},{"../../utils/flatten":396,"../modifiers/retessellate":354,"./subtractGeom3Sub":276}],276:[function(e,t,s){const c=e("../../geometries/geom3"),l=e("./mayOverlap"),{Tree:h}=e("./trees");t.exports=(e,t)=>{if(!l(e,t))return c.clone(e);const s=new h(c.toPolygons(e)),f=new h(c.toPolygons(t));s.invert(),s.clipTo(f),f.clipTo(s,!0),s.addPolygons(f.allPolygons()),s.invert();const g=s.allPolygons();return c.create(g)}},{"../../geometries/geom3":40,"./mayOverlap":270,"./trees":281}],277:[function(e,t,s){const c=e("../../maths/vec3"),l=e("../../geometries/geom2"),h=e("../../geometries/geom3"),f=e("../../geometries/poly3");t.exports=(e,t)=>{const s=l.toSides(t).map((t=>((e,t,s)=>{const l=[c.fromVec2(c.create(),s[0],e),c.fromVec2(c.create(),s[1],e),c.fromVec2(c.create(),s[1],t),c.fromVec2(c.create(),s[0],t)];return f.create(l)})(e.z0,e.z1,t)));return h.create(s)}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/poly3":78,"../../maths/vec3":221}],278:[function(e,t,s){const c=e("../../../maths/plane"),l=e("../../../geometries/poly3");class Node{constructor(e){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=e}invert(){const e=[this];let t;for(let s=0;s<e.length;s++){(t=e[s]).plane&&(t.plane=c.flip(c.create(),t.plane)),t.front&&e.push(t.front),t.back&&e.push(t.back);const l=t.front;t.front=t.back,t.back=l}}clipPolygons(e,t){let s,c={node:this,polygontreenodes:e};const l=[];do{if(s=c.node,e=c.polygontreenodes,s.plane){const c=s.plane,h=[],f=[],g=t?h:f,p=e.length;for(let t=0;t<p;t++){const s=e[t];s.isRemoved()||s.splitByPlane(c,g,h,f,h)}s.front&&f.length>0&&l.push({node:s.front,polygontreenodes:f});const d=h.length;if(s.back&&d>0)l.push({node:s.back,polygontreenodes:h});else for(let e=0;e<d;e++)h[e].remove()}c=l.pop()}while(void 0!==c)}clipTo(e,t){let s=this;const c=[];do{s.polygontreenodes.length>0&&e.rootnode.clipPolygons(s.polygontreenodes,t),s.front&&c.push(s.front),s.back&&c.push(s.back),s=c.pop()}while(void 0!==s)}addPolygonTreeNodes(e){let t={node:this,polygontreenodes:e};const s=[];do{const e=t.node,c=t.polygontreenodes;if(0===c.length){t=s.pop();continue}if(!e.plane){let t=0;const s=c[t=Math.floor(c.length/2)].getPolygon();e.plane=l.plane(s)}const h=[],f=[],g=c.length;for(let t=0;t<g;++t)c[t].splitByPlane(e.plane,e.polygontreenodes,f,h,f);h.length>0&&(e.front||(e.front=new Node(e)),g===h.length&&0===f.length?e.front.polygontreenodes=h:s.push({node:e.front,polygontreenodes:h})),f.length>0&&(e.back||(e.back=new Node(e)),g===f.length&&0===h.length?e.back.polygontreenodes=f:s.push({node:e.back,polygontreenodes:f})),t=s.pop()}while(void 0!==t)}}t.exports=Node},{"../../../geometries/poly3":78,"../../../maths/plane":162}],279:[function(e,t,s){const{EPS:c}=e("../../../maths/constants"),l=e("../../../maths/vec3"),h=e("../../../geometries/poly3"),f=e("./splitPolygonByPlane");class PolygonTreeNode{constructor(e,t){this.parent=e,this.children=[],this.polygon=t,this.removed=!1}addPolygons(e){if(!this.isRootNode())throw new Error("Assertion failed");const t=this;e.forEach((e=>{t.addChild(e)}))}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const e=this.parent.children,t=e.indexOf(this);if(t<0)throw new Error("Assertion failed");e.splice(t,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(e){let t=[this];const s=[t];let c,l,h,f;for(c=0;c<s.length;++c)for(l=0,h=(t=s[c]).length;l<h;l++)(f=t[l]).polygon?e.push(f.polygon):f.children.length>0&&s.push(f.children)}splitByPlane(e,t,s,c,l){if(this.children.length){const h=[this.children];let f,g,p,d,x;for(f=0;f<h.length;f++)for(x=h[f],g=0,p=x.length;g<p;g++)(d=x[g]).children.length>0?h.push(d.children):d._splitByPlane(e,t,s,c,l)}else this._splitByPlane(e,t,s,c,l)}_splitByPlane(e,t,s,g,p){const d=this.polygon;if(d){const x=h.measureBoundingSphere(d),w=x[3]+c,b=x,E=l.dot(e,b)-e[3];if(E>w)g.push(this);else if(E<-w)p.push(this);else{const c=f(e,d);switch(c.type){case 0:t.push(this);break;case 1:s.push(this);break;case 2:g.push(this);break;case 3:p.push(this);break;case 4:if(c.front){const e=this.addChild(c.front);g.push(e)}if(c.back){const e=this.addChild(c.back);p.push(e)}}}}}addChild(e){const t=new PolygonTreeNode(this,e);return this.children.push(t),t}invertSub(){let e=[this];const t=[e];let s,c,l,f;for(s=0;s<t.length;s++)for(c=0,l=(e=t[s]).length;c<l;c++)(f=e[c]).polygon&&(f.polygon=h.invert(f.polygon)),f.children.length>0&&t.push(f.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let e=[this];const t=[e];for(let s=0;s<t.length;++s){const c=(e=t[s]).length;for(let s=0;s<c;s++){const c=e[s];c.polygon&&(c.polygon=null),c.parent&&(c.parent=null),c.children.length>0&&t.push(c.children),c.children=[]}}}toString(){let e="",t=[this];const s=[t];let c,l,h,f;for(c=0;c<s.length;++c){t=s[c];const g=" ".repeat(c);for(l=0,h=t.length;l<h;l++)e+=`${g}PolygonTreeNode (${(f=t[l]).isRootNode()}): ${f.children.length}`,f.polygon?e+=`\n ${g}polygon: ${f.polygon.vertices}\n`:e+="\n",f.children.length>0&&s.push(f.children)}return e}}t.exports=PolygonTreeNode},{"../../../geometries/poly3":78,"../../../maths/constants":93,"../../../maths/vec3":221,"./splitPolygonByPlane":283}],280:[function(e,t,s){const c=e("./Node"),l=e("./PolygonTreeNode");t.exports=class Tree{constructor(e){this.polygonTree=new l,this.rootnode=new c(null),e&&this.addPolygons(e)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(e,t=!1){this.rootnode.clipTo(e,t)}allPolygons(){const e=[];return this.polygonTree.getPolygons(e),e}addPolygons(e){const t=new Array(e.length);for(let s=0;s<e.length;s++)t[s]=this.polygonTree.addChild(e[s]);this.rootnode.addPolygonTreeNodes(t)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}}},{"./Node":278,"./PolygonTreeNode":279}],281:[function(e,t,s){t.exports={Tree:e("./Tree")}},{"./Tree":280}],282:[function(e,t,s){const c=e("../../../maths/vec3");t.exports=(e,t,s)=>{const l=c.subtract(c.create(),s,t);let h=(e[3]-c.dot(e,t))/c.dot(e,l);return Number.isNaN(h)&&(h=0),h>1&&(h=1),h<0&&(h=0),c.scale(l,l,h),c.add(l,t,l),l}},{"../../../maths/vec3":221}],283:[function(e,t,s){const{EPS:c}=e("../../../maths/constants"),l=e("../../../maths/plane"),h=e("../../../maths/vec3"),f=e("../../../geometries/poly3"),g=e("./splitLineSegmentByPlane");t.exports=(e,t)=>{const s={type:null,front:null,back:null},p=t.vertices,d=p.length,x=f.plane(t);if(l.equals(x,e))s.type=0;else{let t=!1,l=!1;const w=[],b=-c;for(let s=0;s<d;s++){const f=h.dot(e,p[s])-e[3],g=f<b;w.push(g),f>c&&(t=!0),f<b&&(l=!0)}if(t||l)if(l)if(t){s.type=4;const t=[],l=[];let b=w[0];for(let s=0;s<d;s++){const c=p[s];let h=s+1;h>=d&&(h=0);const f=w[h];if(b===f)b?l.push(c):t.push(c);else{const s=p[h],f=g(e,c,s);b?(l.push(c),l.push(f),t.push(f)):(t.push(c),t.push(f),l.push(f))}b=f}const E=c*c;if(l.length>=3){let e=l[l.length-1];for(let t=0;t<l.length;t++){const s=l[t];h.squaredDistance(s,e)<E&&(l.splice(t,1),t--),e=s}}if(t.length>=3){let e=t[t.length-1];for(let s=0;s<t.length;s++){const c=t[s];h.squaredDistance(c,e)<E&&(t.splice(s,1),s--),e=c}}t.length>=3&&(s.front=f.fromPointsAndPlane(t,x)),l.length>=3&&(s.back=f.fromPointsAndPlane(l,x))}else s.type=3;else s.type=2;else{const t=h.dot(e,x);s.type=t>=0?0:1}}return s}},{"../../../geometries/poly3":78,"../../../maths/constants":93,"../../../maths/plane":162,"../../../maths/vec3":221,"./splitLineSegmentByPlane":282}],284:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../utils/areAllShapesTheSameType"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("./unionGeom2"),p=e("./unionGeom3");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");if(!l(e))throw new Error("only unions of the same type are supported");const t=e[0];return h.isA(t)?g(e):f.isA(t)?p(e):t}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../utils/areAllShapesTheSameType":394,"../../utils/flatten":396,"./unionGeom2":285,"./unionGeom3":286}],285:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom3"),h=e("../../measurements/measureEpsilon"),f=e("./fromFakePolygons"),g=e("./to3DWalls"),p=e("./unionGeom3");t.exports=(...e)=>{const t=(e=c(e)).map((e=>g({z0:-1,z1:1},e))),s=p(t),d=h(s);return f(d,l.toPolygons(s))}},{"../../geometries/geom3":40,"../../measurements/measureEpsilon":262,"../../utils/flatten":396,"./fromFakePolygons":264,"./to3DWalls":277,"./unionGeom3":286}],286:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../modifiers/retessellate"),h=e("./unionGeom3Sub");t.exports=(...e)=>{let t;for(e=c(e),t=1;t<e.length;t+=2)e.push(h(e[t-1],e[t]));let s=e[t-1];return l(s)}},{"../../utils/flatten":396,"../modifiers/retessellate":354,"./unionGeom3Sub":287}],287:[function(e,t,s){const c=e("../../geometries/geom3"),l=e("./mayOverlap"),{Tree:h}=e("./trees"),unionForNonIntersecting=(e,t)=>{let s=c.toPolygons(e);return s=s.concat(c.toPolygons(t)),c.create(s)};t.exports=(e,t)=>{if(!l(e,t))return unionForNonIntersecting(e,t);const s=new h(c.toPolygons(e)),f=new h(c.toPolygons(t));s.clipTo(f,!1),f.clipTo(s),f.invert(),f.clipTo(s),f.invert();const g=s.allPolygons().concat(f.allPolygons());return c.create(g)}},{"../../geometries/geom3":40,"./mayOverlap":270,"./trees":281}],288:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom2"),h=e("../../geometries/geom3"),f=e("../../geometries/path2"),g=e("./expandGeom2"),p=e("./expandGeom3"),d=e("./expandPath2");t.exports=(e,...t)=>{if(0===(t=c(t)).length)throw new Error("wrong number of arguments");const s=t.map((t=>f.isA(t)?d(e,t):l.isA(t)?g(e,t):h.isA(t)?p(e,t):t));return 1===s.length?s[0]:s}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../utils/flatten":396,"./expandGeom2":289,"./expandGeom3":290,"./expandPath2":291}],289:[function(e,t,s){const c=e("../../geometries/geom2"),l=e("./offsetFromPoints");t.exports=(e,t)=>{const{delta:s,corners:h,segments:f}=Object.assign({},{delta:1,corners:"edge",segments:16},e);if("edge"!==h&&"chamfer"!==h&&"round"!==h)throw new Error('corners must be "edge", "chamfer", or "round"');const g=c.toOutlines(t).map((t=>l(e={delta:s,corners:h,closed:!0,segments:f},t))).reduce(((e,t)=>e.concat(c.toSides(c.fromPoints(t)))),[]);return c.create(g)}},{"../../geometries/geom2":25,"./offsetFromPoints":296}],290:[function(e,t,s){const c=e("../../geometries/geom3"),l=e("../booleans/union"),h=e("./expandShell");t.exports=(e,t)=>{const{delta:s,corners:f,segments:g}=Object.assign({},{delta:1,corners:"round",segments:12},e);if("round"!==f)throw new Error('corners must be "round" for 3D geometries');if(0===c.toPolygons(t).length)throw new Error("the given geometry cannot be empty");const p=h(e={delta:s,corners:f,segments:g},t);return l(t,p)}},{"../../geometries/geom3":40,"../booleans/union":284,"./expandShell":292}],291:[function(e,t,s){const c=e("../../maths/utils/area"),l=e("../../maths/vec2"),h=e("../../geometries/geom2"),f=e("../../geometries/path2"),g=e("./offsetFromPoints");t.exports=(e,t)=>{e=Object.assign({},{delta:1,corners:"edge",segments:16},e);const{delta:s,corners:p,segments:d}=e;if(s<=0)throw new Error("the given delta must be positive for paths");if("edge"!==p&&"chamfer"!==p&&"round"!==p)throw new Error('corners must be "edge", "chamfer", or "round"');const x=t.isClosed,w=f.toPoints(t);if(0===w.length)throw new Error("the given geometry cannot be empty");const b={points:w,external:g({delta:s,corners:p,segments:d,closed:x},w),internal:g({delta:-s,corners:p,segments:d,closed:x},w)};return t.isClosed?(e=>{let{external:t,internal:s}=e;c(t)<0?t=t.reverse():s=s.reverse();const l=f.fromPoints({closed:!0},t),g=f.fromPoints({closed:!0},s),p=h.toSides(h.fromPoints(f.toPoints(l))),d=h.toSides(h.fromPoints(f.toPoints(g)));return p.push(...d),h.create(p)})(b):((e,t,s,c)=>{const{points:f,external:g,internal:p}=e,d=Math.floor(t/2),x=[],w=[];if("round"===s&&d>0){const e=Math.PI/d,t=f[f.length-1],s=l.angle(l.subtract(l.create(),g[g.length-1],t)),h=f[0],b=l.angle(l.subtract(l.create(),p[0],h));for(let f=1;f<d;f++){let g=s+e*f,p=l.fromAngleRadians(l.create(),g);l.scale(p,p,c),l.add(p,p,t),x.push(p),g=b+e*f,p=l.fromAngleRadians(l.create(),g),l.scale(p,p,c),l.add(p,p,h),w.push(p)}}const b=[];return b.push(...g,...x,...p.reverse(),...w),h.fromPoints(b)})(b,d,p,s)}},{"../../geometries/geom2":25,"../../geometries/path2":61,"../../maths/utils/area":167,"../../maths/vec2":190,"./offsetFromPoints":296}],292:[function(e,t,s){const{EPS:c,TAU:l}=e("../../maths/constants"),h=e("../../maths/mat4"),f=e("../../maths/vec3"),g=e("../../utils/fnNumberSort"),p=e("../../geometries/geom3"),d=e("../../geometries/poly3"),x=e("../../primitives/sphere"),w=e("../modifiers/retessellate"),b=e("../booleans/unionGeom3Sub"),E=e("./extrudePolygon"),mapPlaneToVertex=(e,t,s)=>{const c=t.toString();if(e.has(c))e.get(c)[1].push(s);else{const l=[t,[s]];e.set(c,l)}},mapPlaneToEdge=(e,t,s)=>{const c=t[0].toString(),l=t[1].toString(),h=c<l?`${c},${l}`:`${l},${c}`;if(e.has(h))e.get(h)[1].push(s);else{const c=[t,[s]];e.set(h,c)}},addUniqueAngle=(e,t)=>{e.findIndex((e=>e===t))<0&&e.push(t)};t.exports=(e,t)=>{const{delta:s,segments:A}=Object.assign({},{delta:1,segments:12},e);let M=p.create();const S=new Map,k=new Map,N=f.create(),C=f.create();return p.toPolygons(t).forEach(((e,t)=>{const c=f.scale(f.create(),d.plane(e),2*s),l=d.transform(h.fromTranslation(h.create(),f.scale(f.create(),c,-.5)),e),g=E(c,l);M=b(M,g);const p=e.vertices;for(let t=0;t<p.length;t++){mapPlaneToVertex(S,p[t],d.plane(e));const s=(t+1)%p.length,c=[p[t],p[s]];mapPlaneToEdge(k,c,d.plane(e))}})),k.forEach((e=>{const t=e[0],h=e[1],x=t[0],w=t[1],E=f.subtract(f.create(),w,x);f.normalize(E,E);const S=h[0],k=f.cross(f.create(),S,E);let V=[];for(let e=0;e<A;e++)addUniqueAngle(V,e*l/A);for(let e=0,t=h.length;e<t;e++){const t=h[e],s=f.dot(k,t),c=f.dot(S,t);let g=Math.atan2(s,c);g<0&&(g+=l),addUniqueAngle(V,g),(g=Math.atan2(-s,-c))<0&&(g+=l),addUniqueAngle(V,g)}const q=(V=V.sort(g)).length;let R,O;const B=[],F=[],z=[];for(let e=-1;e<q;e++){const t=V[e<0?e+q:e],l=Math.sin(t),h=Math.cos(t);f.scale(N,S,h*s),f.scale(C,k,l*s),f.add(N,N,C);const g=f.add(f.create(),x,N),p=f.add(f.create(),w,N);let b=!1;if(e>=0&&f.distance(g,R)<c&&(b=!0),!b){if(e>=0){B.push(g),F.push(p);const e=[O,p,g,R],t=d.create(e);z.push(t)}R=g,O=p}}F.reverse(),z.push(d.create(B)),z.push(d.create(F));const D=p.create(z);M=b(M,D)})),S.forEach((e=>{const t=e[0],c=e[1],l=c[0];let h=null,g=0;for(let e=1;e<c.length;e++){const t=c[e],s=f.cross(N,l,t),p=f.length(s);p>.05&&p>g&&(g=p,h=t)}h||(h=f.orthogonal(N,l));const p=f.cross(N,l,h);f.normalize(p,p);const d=f.cross(C,p,l),w=x({center:[t[0],t[1],t[2]],radius:s,segments:A,axes:[l,p,d]});M=b(M,w)})),w(M)}},{"../../geometries/geom3":40,"../../geometries/poly3":78,"../../maths/constants":93,"../../maths/mat4":142,"../../maths/vec3":221,"../../primitives/sphere":384,"../../utils/fnNumberSort":397,"../booleans/unionGeom3Sub":287,"../modifiers/retessellate":354,"./extrudePolygon":293}],293:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../maths/vec3"),h=e("../../geometries/geom3"),f=e("../../geometries/poly3");t.exports=(e,t)=>{l.dot(f.plane(t),e)>0&&(t=f.invert(t));const s=[t],g=f.transform(c.fromTranslation(c.create(),e),t),p=t.vertices.length;for(let e=0;e<p;e++){const c=e<p-1?e+1:0,l=f.create([t.vertices[e],g.vertices[e],g.vertices[c],t.vertices[c]]);s.push(l)}return s.push(f.invert(g)),h.create(s)}},{"../../geometries/geom3":40,"../../geometries/poly3":78,"../../maths/mat4":142,"../../maths/vec3":221}],294:[function(e,t,s){t.exports={expand:e("./expand"),offset:e("./offset")}},{"./expand":288,"./offset":295}],295:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom2"),h=e("../../geometries/path2"),f=e("./offsetGeom2"),g=e("./offsetPath2");t.exports=(e,...t)=>{if(0===(t=c(t)).length)throw new Error("wrong number of arguments");const s=t.map((t=>h.isA(t)?g(e,t):l.isA(t)?f(e,t):t));return 1===s.length?s[0]:s}},{"../../geometries/geom2":25,"../../geometries/path2":61,"../../utils/flatten":396,"./offsetGeom2":297,"./offsetPath2":298}],296:[function(e,t,s){const{EPS:c,TAU:l}=e("../../maths/constants"),h=e("../../maths/utils/intersect"),f=e("../../maths/line2"),g=e("../../maths/vec2"),p=e("../../maths/utils/area");t.exports=(e,t)=>{let{delta:s,corners:d,closed:x,segments:w}=Object.assign({},{delta:1,corners:"edge",closed:!1,segments:16},e);if(Math.abs(s)<c)return t;let b=e.closed?p(t):1;0===b&&(b=1);const E=b>0&&s>=0||b<0&&s<0;s=Math.abs(s);let A=null,M=[];const S=[],k=g.create(),N=t.length;for(let e=0;e<N;e++){const c=(e+1)%N,l=t[e],f=t[c];E?g.subtract(k,l,f):g.subtract(k,f,l),g.normal(k,k),g.normalize(k,k),g.scale(k,k,s);const p=g.add(g.create(),l,k),d=g.add(g.create(),f,k),w=[p,d];if(null!=A&&(x||!x&&0!==c)){const e=h(A[0],A[1],w[0],w[1]);e?(M.pop(),w[0]=e):S.push({c:l,s0:A,s1:w})}A=[p,d],(0!==c||x)&&(M.push(w[0]),M.push(w[1]))}if(x&&null!=A){const e=M[0],s=M[1],c=h(A[0],A[1],e,s);if(c)M[0]=c,M.pop();else{const c=t[0],l=[e,s];S.push({c:c,s0:A,s1:l})}}if("edge"===d){const e=new Map;M.forEach(((t,s)=>e.set(t,s)));const t=f.create(),s=f.create();S.forEach((c=>{f.fromPoints(t,c.s0[0],c.s0[1]),f.fromPoints(s,c.s1[0],c.s1[1]);const l=f.intersectPointOfLines(t,s);if(Number.isFinite(l[0])&&Number.isFinite(l[1])){const t=c.s0[1],s=e.get(t);M[s]=l,M[(s+1)%M.length]=void 0}else{const t=c.s1[0],s=e.get(t);M[s]=void 0}})),M=M.filter((e=>void 0!==e))}if("round"===d){let e=Math.floor(w/4);const t=g.create();S.forEach((c=>{let h=g.angle(g.subtract(t,c.s1[0],c.c));if(h-=g.angle(g.subtract(t,c.s0[1],c.c)),E&&h<0&&(h+=Math.PI)<0&&(h+=Math.PI),!E&&h>0&&(h-=Math.PI)>0&&(h-=Math.PI),0!==h){const f=h/(e=Math.floor(w*(Math.abs(h)/l))),p=g.angle(g.subtract(t,c.s0[1],c.c)),d=[];for(let t=1;t<e;t++){const e=p+f*t,l=g.fromAngleRadians(g.create(),e);g.scale(l,l,s),g.add(l,l,c.c),d.push(l)}if(d.length>0){const e=c.s0[1];let t=M.findIndex((t=>g.equals(e,t)));t=(t+1)%M.length,M.splice(t,0,...d)}}else{const e=c.s1[0],t=M.findIndex((t=>g.equals(e,t)));M.splice(t,1)}}))}return M}},{"../../maths/constants":93,"../../maths/line2":104,"../../maths/utils/area":167,"../../maths/utils/intersect":170,"../../maths/vec2":190}],297:[function(e,t,s){const c=e("../../geometries/geom2"),l=e("../../geometries/poly2"),h=e("./offsetFromPoints");t.exports=(e,t)=>{const{delta:s,corners:f,segments:g}=Object.assign({},{delta:1,corners:"edge",segments:0},e);if("edge"!==f&&"chamfer"!==f&&"round"!==f)throw new Error('corners must be "edge", "chamfer", or "round"');const p=c.toOutlines(t),d=p.map((t=>{const c=p.reduce(((e,s)=>e+l.arePointsInside(t,l.create(s))),0);return h(e={delta:c%2==0?s:-s,corners:f,closed:!0,segments:g},t)})).reduce(((e,t)=>e.concat(c.toSides(c.fromPoints(t)))),[]);return c.create(d)}},{"../../geometries/geom2":25,"../../geometries/poly2":72,"./offsetFromPoints":296}],298:[function(e,t,s){const c=e("../../geometries/path2"),l=e("./offsetFromPoints");t.exports=(e,t)=>{const s={delta:1,corners:"edge",closed:t.isClosed,segments:16},{delta:h,corners:f,closed:g,segments:p}=Object.assign({},s,e);if("edge"!==f&&"chamfer"!==f&&"round"!==f)throw new Error('corners must be "edge", "chamfer", or "round"');const d=l(e={delta:h,corners:f,closed:g,segments:p},c.toPoints(t));return c.fromPoints({closed:g},d)}},{"../../geometries/path2":61,"./offsetFromPoints":296}],299:[function(e,t,s){const{area:c}=e("../../../maths/utils"),{toOutlines:l}=e("../../../geometries/geom2"),{arePointsInside:h}=e("../../../geometries/poly2"),minIndex=(e,t)=>{let s,c;return e.forEach(((e,l)=>{const h=t(e);(void 0===c||h<c)&&(s=l,c=h)})),s};t.exports=e=>{const t=l(e),s=[],f=[];t.forEach(((e,t)=>{const l=c(e);l<0?f.push(t):l>0&&s.push(t)}));const g=[],p=[];return s.forEach(((e,s)=>{const c=t[e];g[s]=[],f.forEach(((e,l)=>{const f=t[e];h([f[0]],{vertices:c})&&(g[s].push(e),p[l]||(p[l]=[]),p[l].push(s))}))})),f.forEach(((e,t)=>{if(p[t]&&p[t].length>1){const s=minIndex(p[t],(e=>g[e].length));p[t].forEach(((t,c)=>{c!==s&&(g[t]=g[t].filter((t=>t!==e)))}))}})),g.map(((e,c)=>({solid:t[s[c]],holes:e.map((e=>t[e]))})))}},{"../../../geometries/geom2":25,"../../../geometries/poly2":72,"../../../maths/utils":168}],300:[function(e,t,s){const{filterPoints:c,linkedPolygon:l,locallyInside:h,splitPolygon:f}=e("./linkedPolygon"),{area:g,pointInTriangle:p}=e("./triangle"),eliminateHole=(e,t)=>{const s=findHoleBridge(e,t);if(!s)return t;const l=f(s,e),h=c(s,s.next);return c(l,l.next),t===s?h:t},findHoleBridge=(e,t)=>{let s=t;const c=e.x,l=e.y;let f,g=-1/0;do{if(l<=s.y&&l>=s.next.y&&s.next.y!==s.y){const e=s.x+(l-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(e<=c&&e>g){if(g=e,e===c){if(l===s.y)return s;if(l===s.next.y)return s.next}f=s.x<s.next.x?s:s.next}}s=s.next}while(s!==t);if(!f)return null;if(c===g)return f;const d=f,x=f.x,w=f.y;let b=1/0;s=f;do{if(c>=s.x&&s.x>=x&&c!==s.x&&p(l<w?c:g,l,x,w,l<w?g:c,l,s.x,s.y)){const t=Math.abs(l-s.y)/(c-s.x);h(s,e)&&(t<b||t===b&&(s.x>f.x||s.x===f.x&&sectorContainsSector(f,s)))&&(f=s,b=t)}s=s.next}while(s!==d);return f},sectorContainsSector=(e,t)=>g(e.prev,e,t.prev)<0&&g(t.next,e,e.next)<0,getLeftmost=e=>{let t=e,s=e;do{(t.x<s.x||t.x===s.x&&t.y<s.y)&&(s=t),t=t.next}while(t!==e);return s};t.exports=(e,t,s,h)=>{const f=[];for(let s=0,c=t.length;s<c;s++){const g=t[s]*h,p=s<c-1?t[s+1]*h:e.length,d=l(e,g,p,h,!1);d===d.next&&(d.steiner=!0),f.push(getLeftmost(d))}f.sort(((e,t)=>e.x-t.x));for(let e=0;e<f.length;e++)s=eliminateHole(f[e],s),s=c(s,s.next);return s}},{"./linkedPolygon":304,"./triangle":306}],301:[function(e,t,s){const c=e("./eliminateHoles"),{removeNode:l,sortLinked:h}=e("./linkedList"),{cureLocalIntersections:f,filterPoints:g,isValidDiagonal:p,linkedPolygon:d,splitPolygon:x}=e("./linkedPolygon"),{area:w,pointInTriangle:b}=e("./triangle"),earcutLinked=(e,t,s,c,h,p,d)=>{if(!e)return;!d&&p&&indexCurve(e,c,h,p);let x,w,b=e;for(;e.prev!==e.next;)if(x=e.prev,w=e.next,p?isEarHashed(e,c,h,p):isEar(e))t.push(x.i/s),t.push(e.i/s),t.push(w.i/s),l(e),e=w.next,b=w.next;else if((e=w)===b){d?1===d?(e=f(g(e),t,s),earcutLinked(e,t,s,c,h,p,2)):2===d&&splitEarcut(e,t,s,c,h,p):earcutLinked(g(e),t,s,c,h,p,1);break}},isEar=e=>{const t=e.prev,s=e,c=e.next;if(w(t,s,c)>=0)return!1;let l=e.next.next;for(;l!==e.prev;){if(b(t.x,t.y,s.x,s.y,c.x,c.y,l.x,l.y)&&w(l.prev,l,l.next)>=0)return!1;l=l.next}return!0},isEarHashed=(e,t,s,c)=>{const l=e.prev,h=e,f=e.next;if(w(l,h,f)>=0)return!1;const g=l.x<h.x?l.x<f.x?l.x:f.x:h.x<f.x?h.x:f.x,p=l.y<h.y?l.y<f.y?l.y:f.y:h.y<f.y?h.y:f.y,d=l.x>h.x?l.x>f.x?l.x:f.x:h.x>f.x?h.x:f.x,x=l.y>h.y?l.y>f.y?l.y:f.y:h.y>f.y?h.y:f.y,E=zOrder(g,p,t,s,c),A=zOrder(d,x,t,s,c);let M=e.prevZ,S=e.nextZ;for(;M&&M.z>=E&&S&&S.z<=A;){if(M!==e.prev&&M!==e.next&&b(l.x,l.y,h.x,h.y,f.x,f.y,M.x,M.y)&&w(M.prev,M,M.next)>=0)return!1;if(M=M.prevZ,S!==e.prev&&S!==e.next&&b(l.x,l.y,h.x,h.y,f.x,f.y,S.x,S.y)&&w(S.prev,S,S.next)>=0)return!1;S=S.nextZ}for(;M&&M.z>=E;){if(M!==e.prev&&M!==e.next&&b(l.x,l.y,h.x,h.y,f.x,f.y,M.x,M.y)&&w(M.prev,M,M.next)>=0)return!1;M=M.prevZ}for(;S&&S.z<=A;){if(S!==e.prev&&S!==e.next&&b(l.x,l.y,h.x,h.y,f.x,f.y,S.x,S.y)&&w(S.prev,S,S.next)>=0)return!1;S=S.nextZ}return!0},splitEarcut=(e,t,s,c,l,h)=>{let f=e;do{let e=f.next.next;for(;e!==f.prev;){if(f.i!==e.i&&p(f,e)){let p=x(f,e);return f=g(f,f.next),p=g(p,p.next),earcutLinked(f,t,s,c,l,h),void earcutLinked(p,t,s,c,l,h)}e=e.next}f=f.next}while(f!==e)},indexCurve=(e,t,s,c)=>{let l=e;do{null===l.z&&(l.z=zOrder(l.x,l.y,t,s,c)),l.prevZ=l.prev,l.nextZ=l.next,l=l.next}while(l!==e);l.prevZ.nextZ=null,l.prevZ=null,h(l,(e=>e.z))},zOrder=(e,t,s,c,l)=>(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-s)*l)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-c)*l)|t<<8))|t<<4))|t<<2))|t<<1))<<1;t.exports=(e,t,s=2)=>{const l=t&&t.length,h=l?t[0]*s:e.length;let f=d(e,0,h,s,!0);const g=[];if(!f||f.next===f.prev)return g;let p,x,w,b,E;if(l&&(f=c(e,t,f,s)),e.length>80*s){p=w=e[0],x=b=e[1];for(let t=s;t<h;t+=s){const s=e[t],c=e[t+1];s<p&&(p=s),c<x&&(x=c),s>w&&(w=s),c>b&&(b=c)}E=0!==(E=Math.max(w-p,b-x))?1/E:0}return earcutLinked(f,g,s,p,x,E),g}},{"./eliminateHoles":300,"./linkedList":302,"./linkedPolygon":304,"./triangle":306}],302:[function(e,t,s){const c=e("./linkedListSort");class Node{constructor(e,t,s){this.i=e,this.x=t,this.y=s,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}}t.exports={Node:Node,insertNode:(e,t,s,c)=>{const l=new Node(e,t,s);return c?(l.next=c.next,l.prev=c,c.next.prev=l,c.next=l):(l.prev=l,l.next=l),l},removeNode:e=>{e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)},sortLinked:c}},{"./linkedListSort":303}],303:[function(e,t,s){t.exports=(e,t)=>{let s,c,l,h,f,g=1;do{c=e,e=null;let p=null;for(f=0;c;){f++,l=c;let d=0;for(s=0;s<g&&(d++,l=l.nextZ);s++);let x=g;for(;d>0||x>0&&l;)0!==d&&(0===x||!l||t(c)<=t(l))?(h=c,c=c.nextZ,d--):(h=l,l=l.nextZ,x--),p?p.nextZ=h:e=h,h.prevZ=p,p=h;c=l}p.nextZ=null,g*=2}while(f>1);return e}},{}],304:[function(e,t,s){const{Node:c,insertNode:l,removeNode:h}=e("./linkedList"),{area:f}=e("./triangle"),filterPoints=(e,t)=>{if(!e)return e;t||(t=e);let s,c=e;do{if(s=!1,c.steiner||!equals(c,c.next)&&0!==f(c.prev,c,c.next))c=c.next;else{if(h(c),(c=t=c.prev)===c.next)break;s=!0}}while(s||c!==t);return t},locallyInside=(e,t)=>f(e.prev,e,e.next)<0?f(e,t,e.next)>=0&&f(e,e.prev,t)>=0:f(e,t,e.prev)<0||f(e,e.next,t)<0,intersects=(e,t,s,c)=>{const l=Math.sign(f(e,t,s)),h=Math.sign(f(e,t,c)),g=Math.sign(f(s,c,e)),p=Math.sign(f(s,c,t));return l!==h&&g!==p||!(0!==l||!onSegment(e,s,t))||!(0!==h||!onSegment(e,c,t))||!(0!==g||!onSegment(s,e,c))||!(0!==p||!onSegment(s,t,c))},onSegment=(e,t,s)=>t.x<=Math.max(e.x,s.x)&&t.x>=Math.min(e.x,s.x)&&t.y<=Math.max(e.y,s.y)&&t.y>=Math.min(e.y,s.y),signedArea=(e,t,s,c)=>{let l=0;for(let h=t,f=s-c;h<s;h+=c)l+=(e[f]-e[h])*(e[h+1]+e[f+1]),f=h;return l},equals=(e,t)=>e.x===t.x&&e.y===t.y;t.exports={cureLocalIntersections:(e,t,s)=>{let c=e;do{const l=c.prev,f=c.next.next;!equals(l,f)&&intersects(l,c,c.next,f)&&locallyInside(l,f)&&locallyInside(f,l)&&(t.push(l.i/s),t.push(c.i/s),t.push(f.i/s),h(c),h(c.next),c=e=f),c=c.next}while(c!==e);return filterPoints(c)},filterPoints:filterPoints,isValidDiagonal:(e,t)=>e.next.i!==t.i&&e.prev.i!==t.i&&!((e,t)=>{let s=e;do{if(s.i!==e.i&&s.next.i!==e.i&&s.i!==t.i&&s.next.i!==t.i&&intersects(s,s.next,e,t))return!0;s=s.next}while(s!==e);return!1})(e,t)&&(locallyInside(e,t)&&locallyInside(t,e)&&((e,t)=>{let s=e,c=!1;const l=(e.x+t.x)/2,h=(e.y+t.y)/2;do{s.y>h!=s.next.y>h&&s.next.y!==s.y&&l<(s.next.x-s.x)*(h-s.y)/(s.next.y-s.y)+s.x&&(c=!c),s=s.next}while(s!==e);return c})(e,t)&&(f(e.prev,e,t.prev)||f(e,t.prev,t))||equals(e,t)&&f(e.prev,e,e.next)>0&&f(t.prev,t,t.next)>0),linkedPolygon:(e,t,s,c,f)=>{let g;if(f===signedArea(e,t,s,c)>0)for(let h=t;h<s;h+=c)g=l(h,e[h],e[h+1],g);else for(let h=s-c;h>=t;h-=c)g=l(h,e[h],e[h+1],g);return g&&equals(g,g.next)&&(h(g),g=g.next),g},locallyInside:locallyInside,splitPolygon:(e,t)=>{const s=new c(e.i,e.x,e.y),l=new c(t.i,t.x,t.y),h=e.next,f=t.prev;return e.next=t,t.prev=e,s.next=h,h.prev=s,l.next=s,s.prev=l,f.next=l,l.prev=f,l}}},{"./linkedList":302,"./triangle":306}],305:[function(e,t,s){const c=e("../../../geometries/geom2"),l=e("../../../maths/plane"),h=e("../../../maths/vec2"),f=e("../../../maths/vec3"),g=e("../slice/calculatePlane"),p=e("./assignHoles");t.exports=class PolygonHierarchy{constructor(e){this.plane=g(e);const t=f.orthogonal(f.create(),this.plane),s=f.cross(f.create(),this.plane,t);this.v=f.normalize(s,s),this.u=f.cross(f.create(),this.v,this.plane),this.basisMap=new Map;const l=e.edges.map((e=>e.map((e=>this.to2D(e))))),h=c.create(l);this.roots=p(h)}to2D(e){const t=h.fromValues(f.dot(e,this.u),f.dot(e,this.v));return this.basisMap.set(t,e),t}to3D(e){const t=this.basisMap.get(e);if(t)return t;{console.log("Warning: point not in original slice");const t=f.scale(f.create(),this.u,e[0]),s=f.scale(f.create(),this.v,e[1]),c=f.scale(f.create(),l,l[3]),h=f.add(t,t,c);return f.add(s,s,h)}}}},{"../../../geometries/geom2":25,"../../../maths/plane":162,"../../../maths/vec2":190,"../../../maths/vec3":221,"../slice/calculatePlane":319,"./assignHoles":299}],306:[function(e,t,s){t.exports={area:(e,t,s)=>(t.y-e.y)*(s.x-t.x)-(t.x-e.x)*(s.y-t.y),pointInTriangle:(e,t,s,c,l,h,f,g)=>(l-f)*(t-g)-(e-f)*(h-g)>=0&&(e-f)*(c-g)-(s-f)*(t-g)>=0&&(s-f)*(h-g)-(l-f)*(c-g)>=0}},{}],307:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../geometries/geom2"),h=e("../../geometries/geom3"),f=e("../../geometries/poly3"),g=e("./slice"),p=e("./slice/repair"),d=e("./extrudeWalls"),defaultCallback=(e,t,s)=>{let h=null;return l.isA(s)&&(h=g.fromSides(l.toSides(s))),f.isA(s)&&(h=g.fromPoints(f.toPoints(s))),0===e||1===e?g.transform(c.fromTranslation(c.create(),[0,0,e]),h):null};t.exports=(e,t)=>{const s={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:defaultCallback},{numberOfSlices:c,capStart:l,capEnd:x,close:w,repair:b,callback:E}=Object.assign({},s,e);if(c<2)throw new Error("numberOfSlices must be 2 or more");b&&(t=p(t));const A=c-1;let M=null,S=null,k=null,N=[];for(let e=0;e<c;e++){const s=E(e/A,e,t);if(s){if(!g.isA(s))throw new Error("the callback function must return slice objects");if(0===g.toEdges(s).length)throw new Error("the callback function must return slices with one or more edges");k&&(N=N.concat(d(k,s))),0===e&&(M=s),e===c-1&&(S=s),k=s}}if(x){const e=g.toPolygons(S);N=N.concat(e)}if(l){const e=g.toPolygons(M).map(f.invert);N=N.concat(e)}return l||x||w&&!g.equals(S,M)&&(N=N.concat(d(S,M))),h.create(N)}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/poly3":78,"../../maths/mat4":142,"./extrudeWalls":316,"./slice":325,"./slice/repair":327}],308:[function(e,t,s){const{TAU:c}=e("../../maths/constants"),l=e("./slice"),h=e("../../maths/mat4"),f=e("./extrudeFromSlices"),g=e("../../geometries/geom2");t.exports=(e,t)=>{const s={angle:c,startAngle:0,pitch:10,endOffset:0,segmentsPerRotation:32},{angle:p,endOffset:d,segmentsPerRotation:x,startAngle:w}=Object.assign({},s,e);let b;if(b=!e.pitch&&e.height?e.height/(p/c):e.pitch?e.pitch:s.pitch,x<3)throw new Error("The number of segments per rotation needs to be at least 3.");const E=g.toSides(t);if(0===E.length)throw new Error("the given geometry cannot be empty");const A=E.filter((e=>e[0][0]>=0));let M=l.fromSides(E);0===A.length&&(M=l.reverse(M));const S=Math.round(x/c*Math.abs(p)),k=S>=2?S:2,N=h.create();let C;return f({numberOfSlices:k+1,callback:(e,t,s)=>{const f=w+p/k*t,g=d/k*t,x=(f-w)/c*b;return h.multiply(N,h.fromTranslation(h.create(),[g,0,x*Math.sign(p)]),h.fromXRotation(h.create(),-c/4*Math.sign(p))),C=h.create(),h.multiply(C,h.fromZRotation(h.create(),f),N),l.transform(C,s)}},M)}},{"../../geometries/geom2":25,"../../maths/constants":93,"../../maths/mat4":142,"./extrudeFromSlices":307,"./slice":325}],309:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom2"),h=e("../../geometries/path2"),f=e("./extrudeLinearGeom2"),g=e("./extrudeLinearPath2");t.exports=(e,...t)=>{const{height:s,twistAngle:p,twistSteps:d,repair:x}=Object.assign({},{height:1,twistAngle:0,twistSteps:1,repair:!0},e);if(0===(t=c(t)).length)throw new Error("wrong number of arguments");e={offset:[0,0,s],twistAngle:p,twistSteps:d,repair:x};const w=t.map((t=>h.isA(t)?g(e,t):l.isA(t)?f(e,t):t));return 1===w.length?w[0]:w}},{"../../geometries/geom2":25,"../../geometries/path2":61,"../../utils/flatten":396,"./extrudeLinearGeom2":310,"./extrudeLinearPath2":311}],310:[function(e,t,s){const c=e("../../maths/mat4"),l=e("../../maths/vec3"),h=e("../../geometries/geom2"),f=e("./slice"),g=e("./extrudeFromSlices");t.exports=(e,t)=>{let{offset:s,twistAngle:p,twistSteps:d,repair:x}=Object.assign({},{offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0},e);if(d<1)throw new Error("twistSteps must be 1 or more");0===p&&(d=1);const w=l.clone(s),b=h.toSides(t);if(0===b.length)throw new Error("the given geometry cannot be empty");const E=f.fromSides(b);w[2]<0&&f.reverse(E,E);const A=c.create();return g(e={numberOfSlices:d+1,capStart:!0,capEnd:!0,repair:x,callback:(e,t,s)=>{const h=t/d*p,g=l.scale(l.create(),w,t/d);return c.multiply(A,c.fromZRotation(A,h),c.fromTranslation(c.create(),g)),f.transform(A,s)}},E)}},{"../../geometries/geom2":25,"../../maths/mat4":142,"../../maths/vec3":221,"./extrudeFromSlices":307,"./slice":325}],311:[function(e,t,s){const c=e("../../geometries/geom2"),l=e("../../geometries/path2"),h=e("./extrudeLinearGeom2");t.exports=(e,t)=>{if(!t.isClosed)throw new Error("extruded path must be closed");const s=l.toPoints(t),f=c.fromPoints(s);return h(e,f)}},{"../../geometries/geom2":25,"../../geometries/path2":61,"./extrudeLinearGeom2":310}],312:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom2"),h=e("../../geometries/path2"),f=e("./extrudeRectangularPath2"),g=e("./extrudeRectangularGeom2");t.exports=(e,...t)=>{const{size:s,height:p}=Object.assign({},{size:1,height:1},e);if(0===(t=c(t)).length)throw new Error("wrong number of arguments");if(s<=0)throw new Error("size must be positive");if(p<=0)throw new Error("height must be positive");const d=t.map((t=>h.isA(t)?f(e,t):l.isA(t)?g(e,t):t));return 1===d.length?d[0]:d}},{"../../geometries/geom2":25,"../../geometries/path2":61,"../../utils/flatten":396,"./extrudeRectangularGeom2":313,"./extrudeRectangularPath2":314}],313:[function(e,t,s){const{area:c}=e("../../maths/utils"),l=e("../../geometries/geom2"),h=e("../../geometries/path2"),f=e("../expansions/expand"),g=e("./extrudeLinearGeom2");t.exports=(e,t)=>{const{size:s,height:p}=Object.assign({},{size:1,height:1},e);e.delta=s,e.offset=[0,0,p];const d=l.toOutlines(t);if(0===d.length)throw new Error("the given geometry cannot be empty");const x=d.map((t=>(c(t)<0&&t.reverse(),f(e,h.fromPoints({closed:!0},t))))).reduce(((e,t)=>e.concat(l.toSides(t))),[]),w=l.create(x);return g(e,w)}},{"../../geometries/geom2":25,"../../geometries/path2":61,"../../maths/utils":168,"../expansions/expand":288,"./extrudeLinearGeom2":310}],314:[function(e,t,s){const c=e("../../geometries/path2"),l=e("../expansions/expand"),h=e("./extrudeLinearGeom2");t.exports=(e,t)=>{const{size:s,height:f}=Object.assign({},{size:1,height:1},e);if(e.delta=s,e.offset=[0,0,f],0===c.toPoints(t).length)throw new Error("the given geometry cannot be empty");const g=l(e,t);return h(e,g)}},{"../../geometries/path2":61,"../expansions/expand":288,"./extrudeLinearGeom2":310}],315:[function(e,t,s){const{TAU:c}=e("../../maths/constants"),l=e("../../maths/mat4"),{mirrorX:h}=e("../transforms/mirror"),f=e("../../geometries/geom2"),g=e("./slice"),p=e("./extrudeFromSlices");t.exports=(e,t)=>{const s={segments:12,startAngle:0,angle:c,overflow:"cap"};let{segments:d,startAngle:x,angle:w,overflow:b}=Object.assign({},s,e);if(d<3)throw new Error("segments must be greater then 3");x=Math.abs(x)>c?x%c:x,w=Math.abs(w)>c?w%c:w;let E=x+w;if((E=Math.abs(E)>c?E%c:E)<x){const e=x;x=E,E=e}let A=E-x;if(A<=0&&(A=c),Math.abs(A)<c){const e=c/d;d=Math.floor(Math.abs(A)/e),Math.abs(A)>d*e&&d++}let M=f.toSides(t);if(0===M.length)throw new Error("the given geometry cannot be empty");const S=M.filter((e=>e[0][0]<0)),k=M.filter((e=>e[0][0]>=0));S.length>0&&k.length>0&&"cap"===b&&(S.length>k.length?(M=M.map((e=>{let t=e[0],s=e[1];return[t=[Math.min(t[0],0),t[1]],s=[Math.min(s[0],0),s[1]]]})),t=f.create(M),t=h(t)):k.length>=S.length&&(M=M.map((e=>{let t=e[0],s=e[1];return[t=[Math.max(t[0],0),t[1]],s=[Math.max(s[0],0),s[1]]]})),t=f.create(M)));const N=A/d,C=Math.abs(A)<c,V=g.fromSides(f.toSides(t));g.reverse(V,V);const q=l.create();return p(e={numberOfSlices:d+1,capStart:C,capEnd:C,close:!C,callback:(e,t,s)=>{let h=N*t+x;return A===c&&t===d&&(h=x),l.multiply(q,l.fromZRotation(q,h),l.fromXRotation(l.create(),c/4)),g.transform(q,s)}},V)}},{"../../geometries/geom2":25,"../../maths/constants":93,"../../maths/mat4":142,"../transforms/mirror":361,"./extrudeFromSlices":307,"./slice":325}],316:[function(e,t,s){const{EPS:c}=e("../../maths/constants"),l=e("../../maths/vec3"),h=e("../../geometries/poly3"),f=e("./slice"),gcd=(e,t)=>e===t?e:e<t?gcd(t,e):1===t?1:0===t?e:gcd(t,e%t),repartitionEdges=(e,t)=>{const s=e/t.length;if(1===s)return t;const c=l.fromValues(s,s,s),h=[];return t.forEach((e=>{const t=l.subtract(l.create(),e[1],e[0]);l.divide(t,t,c);let f=e[0];for(let e=1;e<=s;++e){const e=l.add(l.create(),f,t);h.push([f,e]),f=e}})),h},g=c*c/2*Math.sin(Math.PI/3);t.exports=(e,t)=>{let s=f.toEdges(e),c=f.toEdges(t);if(s.length!==c.length){const e=((e,t)=>e*t/gcd(e,t))(s.length,c.length);e!==s.length&&(s=repartitionEdges(e,s)),e!==c.length&&(c=repartitionEdges(e,c))}const l=[];return s.forEach(((e,t)=>{const s=c[t],f=h.create([e[0],e[1],s[1]]),p=h.measureArea(f);Number.isFinite(p)&&p>g&&l.push(f);const d=h.create([e[0],s[1],s[0]]),x=h.measureArea(d);Number.isFinite(x)&&x>g&&l.push(d)})),l}},{"../../geometries/poly3":78,"../../maths/constants":93,"../../maths/vec3":221,"./slice":325}],317:[function(e,t,s){t.exports={extrudeFromSlices:e("./extrudeFromSlices"),extrudeLinear:e("./extrudeLinear"),extrudeRectangular:e("./extrudeRectangular"),extrudeRotate:e("./extrudeRotate"),extrudeHelical:e("./extrudeHelical"),project:e("./project"),slice:e("./slice")}},{"./extrudeFromSlices":307,"./extrudeHelical":308,"./extrudeLinear":309,"./extrudeRectangular":312,"./extrudeRotate":315,"./project":318,"./slice":325}],318:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../maths/utils/aboutEqualNormals"),h=e("../../maths/plane"),f=e("../../maths/mat4"),g=e("../../geometries/geom2"),p=e("../../geometries/geom3"),d=e("../../geometries/poly3"),x=e("../../measurements/measureEpsilon"),w=e("../booleans/unionGeom2");t.exports=(e,...t)=>{const{axis:s,origin:b}=Object.assign({},{axis:[0,0,1],origin:[0,0,0]},e);if(0===(t=c(t)).length)throw new Error("wrong number of arguments");e={axis:s,origin:b};const E=t.map((t=>p.isA(t)?((e,t)=>{const s=h.fromNormalAndPoint(h.create(),e.axis,e.origin);if(Number.isNaN(s[0])||Number.isNaN(s[1])||Number.isNaN(s[2])||Number.isNaN(s[3]))throw new Error("project: invalid axis or origin");const c=x(t),b=c*c*Math.sqrt(3)/4;if(0===c)return g.create();const E=p.toPolygons(t);let A=[];for(let e=0;e<E.length;e++){const t=E[e].vertices.map((e=>h.projectionOfPoint(s,e))),c=d.create(t),f=d.plane(c);l(s,f)&&(d.measureArea(c)<b||A.push(c))}if(!l(s,[0,0,1])){const e=f.fromVectorRotation(f.create(),s,[0,0,1]);A=A.map((t=>d.transform(e,t)))}const M=(A=A.sort(((e,t)=>d.measureArea(t)-d.measureArea(e)))).map((e=>g.fromPoints(e.vertices)));return w(M)})(e,t):t));return 1===E.length?E[0]:E}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/poly3":78,"../../maths/mat4":142,"../../maths/plane":162,"../../maths/utils/aboutEqualNormals":166,"../../measurements/measureEpsilon":262,"../../utils/flatten":396,"../booleans/unionGeom2":285}],319:[function(e,t,s){const c=e("../../../maths/plane"),l=e("../../../maths/vec3");t.exports=e=>{const t=e.edges;if(t.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const s=t.reduce(((e,t)=>l.add(l.create(),e,t[0])),l.create());let h;l.scale(s,s,1/t.length);let f=0;t.forEach((e=>{if(!l.equals(e[0],e[1])){const t=l.squaredDistance(s,e[0]);t>f&&(h=e,f=t)}}));const g=t.find((e=>l.equals(e[1],h[0])));return c.fromPoints(c.create(),g[0],h[0],h[1])}},{"../../../maths/plane":162,"../../../maths/vec3":221}],320:[function(e,t,s){const c=e("./create"),l=e("../../../maths/vec3");t.exports=(...e)=>{let t,s;return 1===e.length?(t=c(),s=e[0]):(t=e[0],s=e[1]),t.edges=s.edges.map((e=>[l.clone(e[0]),l.clone(e[1])])),t}},{"../../../maths/vec3":221,"./create":321}],321:[function(e,t,s){t.exports=e=>(e||(e=[]),{edges:e})},{}],322:[function(e,t,s){const c=e("../../../maths/vec3");t.exports=(e,t)=>{const s=e.edges,l=t.edges;return s.length===l.length&&s.reduce(((e,t,s)=>{const h=l[s],f=c.squaredDistance(t[0],h[0]);return e&&f<Number.EPSILON}),!0)}},{"../../../maths/vec3":221}],323:[function(e,t,s){const c=e("../../../maths/vec3"),l=e("./create");t.exports=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");if(e.length<3)throw new Error("the given points must contain THREE or more points");const t=[];let s=e[e.length-1];return e.forEach((e=>{2===e.length&&t.push([c.fromVec2(c.create(),s),c.fromVec2(c.create(),e)]),3===e.length&&t.push([s,e]),s=e})),l(t)}},{"../../../maths/vec3":221,"./create":321}],324:[function(e,t,s){const c=e("../../../maths/vec3"),l=e("./create");t.exports=e=>{if(!Array.isArray(e))throw new Error("the given sides must be an array");const t=[];return e.forEach((e=>{t.push([c.fromVec2(c.create(),e[0]),c.fromVec2(c.create(),e[1])])})),l(t)}},{"../../../maths/vec3":221,"./create":321}],325:[function(e,t,s){t.exports={calculatePlane:e("./calculatePlane"),clone:e("./clone"),create:e("./create"),equals:e("./equals"),fromPoints:e("./fromPoints"),fromSides:e("./fromSides"),isA:e("./isA"),reverse:e("./reverse"),toEdges:e("./toEdges"),toPolygons:e("./toPolygons"),toString:e("./toString"),transform:e("./transform")}},{"./calculatePlane":319,"./clone":320,"./create":321,"./equals":322,"./fromPoints":323,"./fromSides":324,"./isA":326,"./reverse":328,"./toEdges":329,"./toPolygons":330,"./toString":331,"./transform":332}],326:[function(e,t,s){t.exports=e=>!!(e&&"object"==typeof e&&"edges"in e&&Array.isArray(e.edges))},{}],327:[function(e,t,s){const c=e("../../../maths/vec3"),l=e("./create");t.exports=e=>{if(!e.edges)return e;let t=e.edges;const s=new Map,h=new Map;(t=t.filter((e=>!c.equals(e[0],e[1])))).forEach((e=>{const t=e[0].toString(),c=e[1].toString();s.set(t,e[0]),s.set(c,e[1]),h.set(t,(h.get(t)||0)+1),h.set(c,(h.get(c)||0)-1)}));const f=[],g=[];return h.forEach(((e,t)=>{e<0&&f.push(t),e>0&&g.push(t)})),f.forEach((e=>{const l=s.get(e);let h,f=1/0;g.forEach((e=>{const t=s.get(e),g=c.distance(l,t);g<f&&(f=g,h=t)})),console.warn(`slice.repair: repairing vertex gap ${l} to ${h} distance ${f}`),t=t.map((t=>t[0].toString()===e?[h,t[1]]:t[1].toString()===e?[t[0],h]:t))})),l(t)}},{"../../../maths/vec3":221,"./create":321}],328:[function(e,t,s){const c=e("./create");t.exports=(...e)=>{let t,s;return 1===e.length?(t=c(),s=e[0]):(t=e[0],s=e[1]),t.edges=s.edges.map((e=>[e[1],e[0]])),t}},{"./create":321}],329:[function(e,t,s){t.exports=e=>e.edges},{}],330:[function(e,t,s){const c=e("../../../geometries/poly3"),l=e("../earcut"),h=e("../earcut/polygonHierarchy");t.exports=e=>{const t=new h(e),s=[];return t.roots.forEach((({solid:e,holes:h})=>{let f=e.length;const g=[];h.forEach(((e,t)=>{g.push(f),f+=e.length}));const p=[e,...h].flat(),d=p.flat(),a=e=>t.to3D(p[e]),x=l(d,g);for(let e=0;e<x.length;e+=3){const l=x.slice(e,e+3).map(a);s.push(c.fromPointsAndPlane(l,t.plane))}})),s}},{"../../../geometries/poly3":78,"../earcut":301,"../earcut/polygonHierarchy":305}],331:[function(e,t,s){const c=e("../../../maths/vec3");t.exports=e=>`[${(e=>e.reduce(((e,t)=>e+`[${c.toString(t[0])}, ${c.toString(t[1])}], `),""))(e.edges)}]`},{"../../../maths/vec3":221}],332:[function(e,t,s){const c=e("../../../maths/vec3"),l=e("./create");t.exports=(e,t)=>{const s=t.edges.map((t=>[c.transform(c.create(),t[0],e),c.transform(c.create(),t[1],e)]));return l(s)}},{"../../../maths/vec3":221,"./create":321}],333:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../utils/areAllShapesTheSameType"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("../../geometries/path2"),p=e("./hullPath2"),d=e("./hullGeom2"),x=e("./hullGeom3");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");if(!l(e))throw new Error("only hulls of the same type are supported");const t=e[0];return g.isA(t)?p(e):h.isA(t)?d(e):f.isA(t)?x(e):t}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../utils/areAllShapesTheSameType":394,"../../utils/flatten":396,"./hullGeom2":335,"./hullGeom3":336,"./hullPath2":337}],334:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../booleans/union"),h=e("./hull");t.exports=(...e)=>{if((e=c(e)).length<2)throw new Error("wrong number of arguments");const t=[];for(let s=1;s<e.length;s++)t.push(h(e[s-1],e[s]));return l(t)}},{"../../utils/flatten":396,"../booleans/union":284,"./hull":333}],335:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom2"),h=e("./hullPoints2"),f=e("./toUniquePoints");t.exports=(...e)=>{e=c(e);const t=f(e),s=h(t);return s.length<3?l.create():l.fromPoints(s)}},{"../../geometries/geom2":25,"../../utils/flatten":396,"./hullPoints2":338,"./toUniquePoints":348}],336:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom3"),h=e("../../geometries/poly3"),f=e("./quickhull"),g=e("./toUniquePoints");t.exports=(...e)=>{if(1===(e=c(e)).length)return e[0];const t=g(e),s=f(t,{skipTriangulation:!0}).map((e=>{const s=e.map((e=>t[e]));return h.create(s)}));return l.create(s)}},{"../../geometries/geom3":40,"../../geometries/poly3":78,"../../utils/flatten":396,"./quickhull":346,"./toUniquePoints":348}],337:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/path2"),h=e("./hullPoints2"),f=e("./toUniquePoints");t.exports=(...e)=>{e=c(e);const t=f(e),s=h(t);return l.fromPoints({closed:!0},s)}},{"../../geometries/path2":61,"../../utils/flatten":396,"./hullPoints2":338,"./toUniquePoints":348}],338:[function(e,t,s){const c=e("../../maths/vec2"),ccw=(e,t,s)=>(t[0]-e[0])*(s[1]-e[1])-(t[1]-e[1])*(s[0]-e[0]),fakeAtan2=(e,t)=>0===e&&0===t?-1/0:-t/e;t.exports=e=>{let t=c.fromValues(1/0,1/0);e.forEach((e=>{(e[1]<t[1]||e[1]===t[1]&&e[0]<t[0])&&(t=e)}));const s=[];e.forEach((e=>{const l=fakeAtan2(e[1]-t[1],e[0]-t[0]),h=c.squaredDistance(e,t);s.push({point:e,angle:l,distSq:h})})),s.sort(((e,t)=>e.angle!==t.angle?e.angle-t.angle:e.distSq-t.distSq));const l=[];return s.forEach((e=>{let t=l.length;for(;t>1&&ccw(l[t-2],l[t-1],e.point)<=Number.EPSILON;)l.pop(),t=l.length;l.push(e.point)})),l}},{"../../maths/vec2":190}],339:[function(e,t,s){t.exports={hull:e("./hull"),hullChain:e("./hullChain")}},{"./hull":333,"./hullChain":334}],340:[function(e,t,s){const c=e("../../../maths/vec3/add"),l=e("../../../maths/vec3/copy"),h=e("../../../maths/vec3/cross"),f=e("../../../maths/vec3/dot"),g=e("../../../maths/vec3/length"),p=e("../../../maths/vec3/normalize"),d=e("../../../maths/vec3/scale"),x=e("../../../maths/vec3/subtract"),w=e("./HalfEdge");class Face{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=0,this.edge=null,this.nVertices=0}getEdge(e){if("number"!=typeof e)throw Error("requires a number");let t=this.edge;for(;e>0;)t=t.next,e-=1;for(;e<0;)t=t.prev,e+=1;return t}computeNormal(){const e=this.edge,t=e.next;let s=t.next;const f=x([],t.head().point,e.head().point),p=[],w=[];for(this.nVertices=2,this.normal=[0,0,0];s!==e;)l(w,f),x(f,s.head().point,e.head().point),c(this.normal,this.normal,h(p,w,f)),s=s.next,this.nVertices+=1;this.area=g(this.normal),this.normal=d(this.normal,this.normal,1/this.area)}computeNormalMinArea(e){if(this.computeNormal(),this.area<e){let e,t=0,s=this.edge;do{const c=s.lengthSquared();c>t&&(e=s,t=c),s=s.next}while(s!==this.edge);const l=e.tail().point,h=e.head().point,g=x([],h,l),w=Math.sqrt(t);d(g,g,1/w);const b=f(this.normal,g);d(g,g,-b),c(this.normal,this.normal,g),p(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let e=this.edge;do{c(this.centroid,this.centroid,e.head().point),e=e.next}while(e!==this.edge);d(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(e){void 0!==e?this.computeNormalMinArea(e):this.computeNormal(),this.computeCentroid(),this.offset=f(this.normal,this.centroid)}distanceToPlane(e){return f(this.normal,e)-this.offset}connectHalfEdges(e,t){let s;if(e.opposite.face===t.opposite.face){const c=t.opposite.face;let l;e===this.edge&&(this.edge=t),3===c.nVertices?(l=t.opposite.prev.opposite,c.mark=2,s=c):(l=t.opposite.next,c.edge===l.prev&&(c.edge=l),l.prev=l.prev.prev,l.prev.next=l),t.prev=e.prev,t.prev.next=t,t.setOpposite(l),c.computeNormalAndCentroid()}else e.next=t,t.prev=e;return s}mergeAdjacentFaces(e,t){const s=e.opposite,c=s.face;t.push(c),c.mark=2;let l,h,f=e.prev,g=e.next,p=s.prev,d=s.next;for(;f.opposite.face===c;)f=f.prev,d=d.next;for(;g.opposite.face===c;)g=g.next,p=p.prev;for(l=d;l!==p.next;l=l.next)l.face=this;return this.edge=g,(h=this.connectHalfEdges(p,g))&&t.push(h),(h=this.connectHalfEdges(f,d))&&t.push(h),this.computeNormalAndCentroid(),t}collectIndices(){const e=[];let t=this.edge;do{e.push(t.head().index),t=t.next}while(t!==this.edge);return e}static createTriangle(e,t,s,c=0){const l=new Face,h=new w(e,l),f=new w(t,l),g=new w(s,l);return h.next=g.prev=f,f.next=h.prev=g,g.next=f.prev=h,l.edge=h,l.computeNormalAndCentroid(c),l}}t.exports={VISIBLE:0,NON_CONVEX:1,DELETED:2,Face:Face}},{"../../../maths/vec3/add":208,"../../../maths/vec3/copy":211,"../../../maths/vec3/cross":213,"../../../maths/vec3/dot":216,"../../../maths/vec3/length":222,"../../../maths/vec3/normalize":228,"../../../maths/vec3/scale":233,"../../../maths/vec3/subtract":237,"./HalfEdge":341}],341:[function(e,t,s){const c=e("../../../maths/vec3/distance"),l=e("../../../maths/vec3/squaredDistance");t.exports=class HalfEdge{constructor(e,t){this.vertex=e,this.face=t,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?c(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?l(this.tail().point,this.head().point):-1}setOpposite(e){this.opposite=e,e.opposite=this}}},{"../../../maths/vec3/distance":214,"../../../maths/vec3/squaredDistance":235}],342:[function(e,t,s){const c=e("../../../maths/vec3/dot"),l=e("./point-line-distance"),h=e("./get-plane-normal"),f=e("./VertexList"),g=e("./Vertex"),{Face:p,VISIBLE:d,NON_CONVEX:x,DELETED:w}=e("./Face");t.exports=class QuickHull{constructor(e){if(!Array.isArray(e))throw TypeError("input is not a valid array");if(e.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=e.length,this.faces=[],this.newFaces=[],this.claimed=new f,this.unclaimed=new f,this.vertices=[];for(let t=0;t<e.length;t+=1)this.vertices.push(new g(e[t],t));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(e,t){e.face=t,t.outside?this.claimed.insertBefore(t.outside,e):this.claimed.add(e),t.outside=e}removeVertexFromFace(e,t){e===t.outside&&(e.next&&e.next.face===t?t.outside=e.next:t.outside=null),this.claimed.remove(e)}removeAllVerticesFromFace(e){if(e.outside){let t=e.outside;for(;t.next&&t.next.face===e;)t=t.next;return this.claimed.removeChain(e.outside,t),t.next=null,e.outside}}deleteFaceVertices(e,t){const s=this.removeAllVerticesFromFace(e);if(s)if(t){let e;for(let c=s;c;c=e)e=c.next,t.distanceToPlane(c.point)>this.tolerance?this.addVertexToFace(c,t):this.unclaimed.add(c)}else this.unclaimed.addAll(s)}resolveUnclaimedPoints(e){let t=this.unclaimed.first();for(let s=t;s;s=t){t=s.next;let c,l=this.tolerance;for(let t=0;t<e.length;t+=1){const h=e[t];if(h.mark===d){const e=h.distanceToPlane(s.point);if(e>l&&(l=e,c=h),l>1e3*this.tolerance)break}}c&&this.addVertexToFace(s,c)}}computeExtremes(){const e=[],t=[],s=[],c=[];let l,h;for(l=0;l<3;l+=1)s[l]=c[l]=this.vertices[0];for(l=0;l<3;l+=1)e[l]=t[l]=this.vertices[0].point[l];for(l=1;l<this.vertices.length;l+=1){const f=this.vertices[l],g=f.point;for(h=0;h<3;h+=1)g[h]<e[h]&&(e[h]=g[h],s[h]=f);for(h=0;h<3;h+=1)g[h]>t[h]&&(t[h]=g[h],c[h]=f)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e[0]),Math.abs(t[0]))+Math.max(Math.abs(e[1]),Math.abs(t[1]))+Math.max(Math.abs(e[2]),Math.abs(t[2]))),[s,c]}createInitialSimplex(){const e=this.vertices,[t,s]=this.computeExtremes();let f,g,d,x,w=0,b=0;for(d=0;d<3;d+=1){const e=s[d].point[d]-t[d].point[d];e>w&&(w=e,b=d)}const E=t[b],A=s[b];for(w=0,d=0;d<this.vertices.length;d+=1){const e=this.vertices[d];if(e!==E&&e!==A){const t=l(e.point,E.point,A.point);t>w&&(w=t,f=e)}}const M=h([],E.point,A.point,f.point),S=c(E.point,M);for(w=-1,d=0;d<this.vertices.length;d+=1){const e=this.vertices[d];if(e!==E&&e!==A&&e!==f){const t=Math.abs(c(M,e.point)-S);t>w&&(w=t,g=e)}}const k=[];if(c(g.point,M)-S<0)for(k.push(p.createTriangle(E,A,f),p.createTriangle(g,A,E),p.createTriangle(g,f,A),p.createTriangle(g,E,f)),d=0;d<3;d+=1){const e=(d+1)%3;k[d+1].getEdge(2).setOpposite(k[0].getEdge(e)),k[d+1].getEdge(1).setOpposite(k[e+1].getEdge(0))}else for(k.push(p.createTriangle(E,f,A),p.createTriangle(g,E,A),p.createTriangle(g,A,f),p.createTriangle(g,f,E)),d=0;d<3;d+=1){const e=(d+1)%3;k[d+1].getEdge(2).setOpposite(k[0].getEdge((3-d)%3)),k[d+1].getEdge(0).setOpposite(k[e+1].getEdge(1))}for(d=0;d<4;d+=1)this.faces.push(k[d]);for(d=0;d<e.length;d+=1){const t=e[d];if(t!==E&&t!==A&&t!==f&&t!==g){let e;for(w=this.tolerance,x=0;x<4;x+=1){const s=k[x].distanceToPlane(t.point);s>w&&(w=s,e=k[x])}e&&this.addVertexToFace(t,e)}}}reindexFaceAndVertices(){const e=[];for(let t=0;t<this.faces.length;t+=1){const s=this.faces[t];s.mark===d&&e.push(s)}this.faces=e}collectFaces(e){const t=[];for(let s=0;s<this.faces.length;s+=1){if(this.faces[s].mark!==d)throw Error("attempt to include a destroyed face in the hull");const c=this.faces[s].collectIndices();if(e)t.push(c);else for(let e=0;e<c.length-2;e+=1)t.push([c[0],c[e+1],c[e+2]])}return t}nextVertexToAdd(){if(!this.claimed.isEmpty()){let e,t,s=0;const c=this.claimed.first().face;for(t=c.outside;t&&t.face===c;t=t.next){const l=c.distanceToPlane(t.point);l>s&&(s=l,e=t)}return e}}computeHorizon(e,t,s,c){let l;this.deleteFaceVertices(s),s.mark=w,l=t?t.next:t=s.getEdge(0);do{const t=l.opposite,s=t.face;s.mark===d&&(s.distanceToPlane(e)>this.tolerance?this.computeHorizon(e,t,s,c):c.push(l)),l=l.next}while(l!==t)}addAdjoiningFace(e,t){const s=p.createTriangle(e,t.tail(),t.head());return this.faces.push(s),s.getEdge(-1).setOpposite(t.opposite),s.getEdge(0)}addNewFaces(e,t){let s,c;this.newFaces=[];for(let l=0;l<t.length;l+=1){const h=t[l],f=this.addAdjoiningFace(e,h);s?f.next.setOpposite(c):s=f,this.newFaces.push(f.face),c=f}s.next.setOpposite(c)}oppositeFaceDistance(e){return e.face.distanceToPlane(e.opposite.face.centroid)}doAdjacentMerge(e,t){let s=e.edge,c=!0,l=0;do{if(l>=e.nVertices)throw Error("merge recursion limit exceeded");const h=s.opposite.face;let f=!1;if(2===t?(this.oppositeFaceDistance(s)>-this.tolerance||this.oppositeFaceDistance(s.opposite)>-this.tolerance)&&(f=!0):e.area>h.area?this.oppositeFaceDistance(s)>-this.tolerance?f=!0:this.oppositeFaceDistance(s.opposite)>-this.tolerance&&(c=!1):this.oppositeFaceDistance(s.opposite)>-this.tolerance?f=!0:this.oppositeFaceDistance(s)>-this.tolerance&&(c=!1),f){const t=e.mergeAdjacentFaces(s,[]);for(let s=0;s<t.length;s+=1)this.deleteFaceVertices(t[s],e);return!0}s=s.next,l+=1}while(s!==e.edge);return c||(e.mark=x),!1}addVertexToHull(e){const t=[];this.unclaimed.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t);for(let e=0;e<this.newFaces.length;e+=1){const t=this.newFaces[e];if(t.mark===d)for(;this.doAdjacentMerge(t,1););}for(let e=0;e<this.newFaces.length;e+=1){const t=this.newFaces[e];if(t.mark===x)for(t.mark=d;this.doAdjacentMerge(t,2););}this.resolveUnclaimedPoints(this.newFaces)}build(){let e;for(this.createInitialSimplex();e=this.nextVertexToAdd();)this.addVertexToHull(e);this.reindexFaceAndVertices()}}},{"../../../maths/vec3/dot":216,"./Face":340,"./Vertex":343,"./VertexList":344,"./get-plane-normal":345,"./point-line-distance":347}],343:[function(e,t,s){t.exports=class Vertex{constructor(e,t){this.point=e,this.index=t,this.next=null,this.prev=null,this.face=null}}},{}],344:[function(e,t,s){t.exports=class VertexList{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(e,t){t.prev=e.prev,t.next=e,t.prev?t.prev.next=t:this.head=t,e.prev=t}insertAfter(e,t){t.prev=e,t.next=e.next,t.next?t.next.prev=t:this.tail=t,e.next=t}add(e){this.head?this.tail.next=e:this.head=e,e.prev=this.tail,e.next=null,this.tail=e}addAll(e){for(this.head?this.tail.next=e:this.head=e,e.prev=this.tail;e.next;)e=e.next;this.tail=e}remove(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}removeChain(e,t){e.prev?e.prev.next=t.next:this.head=t.next,t.next?t.next.prev=e.prev:this.tail=e.prev}first(){return this.head}isEmpty(){return!this.head}}},{}],345:[function(e,t,s){const c=e("../../../maths/vec3/cross"),l=e("../../../maths/vec3/normalize"),h=e("../../../maths/vec3/subtract");t.exports=(e,t,s,f)=>{const g=[0,0,0];return h(e,t,s),h(g,s,f),c(e,e,g),l(e,e)}},{"../../../maths/vec3/cross":213,"../../../maths/vec3/normalize":228,"../../../maths/vec3/subtract":237}],346:[function(e,t,s){const c=e("./QuickHull");t.exports=(e,t={})=>{const s=new c(e);return s.build(),s.collectFaces(t.skipTriangulation)}},{"./QuickHull":342}],347:[function(e,t,s){const c=e("../../../maths/vec3/cross"),l=e("../../../maths/vec3/subtract"),h=e("../../../maths/vec3/squaredLength");t.exports=(e,t,s)=>Math.sqrt(((e,t,s)=>{const f=[],g=[];l(f,s,t),l(g,e,t);const p=h(c([],g,f)),d=h(f);if(0===d)throw Error("a and b are the same point");return p/d})(e,t,s))},{"../../../maths/vec3/cross":213,"../../../maths/vec3/squaredLength":236,"../../../maths/vec3/subtract":237}],348:[function(e,t,s){const c=e("../../geometries/geom2"),l=e("../../geometries/geom3"),h=e("../../geometries/path2");t.exports=e=>{const t=new Set,s=[],r=e=>{const c=e.toString();t.has(c)||(s.push(e),t.add(c))};return e.forEach((e=>{c.isA(e)?c.toPoints(e).forEach(r):l.isA(e)?l.toPoints(e).forEach((e=>e.forEach(r))):h.isA(e)&&h.toPoints(e).forEach(r)})),s}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61}],349:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../measurements/measureEpsilon"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("../../geometries/path2"),p=e("./snapPolygons"),d=e("./mergePolygons"),x=e("./insertTjunctions"),w=e("./triangulatePolygons");t.exports=(e,...t)=>{if(0===(t=c(t)).length)throw new Error("wrong number of arguments");const s=t.map((t=>{if(g.isA(t))return((e,t)=>t)(0,t);if(h.isA(t))return((e,t)=>t)(0,t);if(f.isA(t))return((e,t)=>{const{snap:s,simplify:c,triangulate:h}=Object.assign({},{snap:!1,simplify:!1,triangulate:!1},e),g=l(t);let b=f.toPolygons(t);s&&(b=p(g,b)),c&&(b=d(g,b)),h&&(b=x(b),b=w(g,b));const E=Object.assign({},t);return E.polygons=b,E})(e,t);throw new Error("invalid geometry")}));return 1===s.length?s[0]:s}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../measurements/measureEpsilon":262,"../../utils/flatten":396,"./insertTjunctions":351,"./mergePolygons":352,"./snapPolygons":356,"./triangulatePolygons":357}],350:[function(e,t,s){t.exports={generalize:e("./generalize"),snap:e("./snap"),retessellate:e("./retessellate")}},{"./generalize":349,"./retessellate":354,"./snap":355}],351:[function(e,t,s){const c=e("../../maths/constants"),l=e("../../maths/vec3"),h=e("../../geometries/poly3"),getTag=e=>`${e}`,addSide=(e,t,s,c,l,h)=>{const f=getTag(c),g=getTag(l),p=`${f}/${g}`,d=`${g}/${f}`;if(e.has(d))return deleteSide(e,t,s,l,c,null),null;const x={vertex0:c,vertex1:l,polygonindex:h};return e.has(p)?e.get(p).push(x):e.set(p,[x]),t.has(f)?t.get(f).push(p):t.set(f,[p]),s.has(g)?s.get(g).push(p):s.set(g,[p]),p},deleteSide=(e,t,s,c,l,h)=>{const f=getTag(c),g=getTag(l),p=`${f}/${g}`;let d=-1;const x=e.get(p);for(let e=0;e<x.length;e++){const t=x[e];let s=getTag(t.vertex0);if(s===f&&(s=getTag(t.vertex1))===g&&(null===h||t.polygonindex===h)){d=e;break}}x.splice(d,1),0===x.length&&e.delete(p),d=t.get(f).indexOf(p),t.get(f).splice(d,1),0===t.get(f).length&&t.delete(f),d=s.get(g).indexOf(p),s.get(g).splice(d,1),0===s.get(g).length&&s.delete(g)};t.exports=e=>{const t=new Map;for(let s=0;s<e.length;s++){const c=e[s],l=c.vertices.length;if(l>=3){let e=c.vertices[0],h=getTag(e);for(let f=0;f<l;f++){let g=f+1;g===l&&(g=0);const p=c.vertices[g],d=getTag(p),x=`${h}/${d}`,w=`${d}/${h}`;if(t.has(w)){const e=t.get(w);e.splice(-1,1),0===e.length&&t.delete(w)}else{const c={vertex0:e,vertex1:p,polygonindex:s};t.has(x)?t.get(x).push(c):t.set(x,[c])}e=p,h=d}}else console.warn("warning: invalid polygon found during insertTjunctions")}if(t.size>0){const s=new Map,f=new Map,g=new Map;for(const[e,c]of t)g.set(e,!0),c.forEach((t=>{const c=getTag(t.vertex0),l=getTag(t.vertex1);s.has(c)?s.get(c).push(e):s.set(c,[e]),f.has(l)?f.get(l).push(e):f.set(l,[e])}));const p=e.slice(0);for(;0!==t.size;){for(const e of t.keys())g.set(e,!0);let e=!1;for(;;){const d=Array.from(g.keys());if(0===d.length)break;const x=d[0];let w=!0;if(t.has(x)){const d=t.get(x)[0];for(let x=0;x<2;x++){const b=0===x?d.vertex0:d.vertex1,E=0===x?d.vertex1:d.vertex0,A=getTag(b),M=getTag(E);let S=[];0===x?f.has(A)&&(S=f.get(A)):s.has(A)&&(S=s.get(A));for(let d=0;d<S.length;d++){const A=S[d],k=t.get(A)[0],N=0===x?k.vertex0:k.vertex1,C=0===x?k.vertex1:k.vertex0,V=getTag(N);if(getTag(C),V===M){deleteSide(t,s,f,b,E,null),deleteSide(t,s,f,E,b,null),w=!1,x=2,e=!0;break}{const d=b,A=E,M=N,S=l.subtract(l.create(),M,d),C=l.dot(l.subtract(l.create(),A,d),S)/l.dot(S,S);if(C>0&&C<1){const b=l.scale(l.create(),S,C);if(l.add(b,b,d),l.squaredDistance(b,A)<c.EPS*c.EPS){const c=k.polygonindex,l=p[c],d=getTag(k.vertex1);let b=-1;for(let e=0;e<l.vertices.length;e++)if(getTag(l.vertices[e])===d){b=e;break}const A=l.vertices.slice(0);A.splice(b,0,E);const M=h.create(A);p[c]=M,deleteSide(t,s,f,k.vertex0,k.vertex1,c);const S=addSide(t,s,f,k.vertex0,E,c),N=addSide(t,s,f,E,k.vertex1,c);null!==S&&g.set(S,!0),null!==N&&g.set(N,!0),w=!1,x=2,e=!0;break}}}}}}w&&g.delete(x)}if(!e)break}e=p}return t.clear(),e}},{"../../geometries/poly3":78,"../../maths/constants":93,"../../maths/vec3":221}],352:[function(e,t,s){const c=e("../../maths/utils/aboutEqualNormals"),l=e("../../maths/vec3"),h=e("../../geometries/poly3"),createEdges=e=>{const t=h.toPoints(e),s=[];for(let e=0;e<t.length;e++){const c=(e+1)%t.length,l={v1:t[e],v2:t[c]};s.push(l)}for(let e=0;e<s.length;e++){const c=(e+1)%t.length;s[e].next=s[c],s[c].prev=s[e]}return s},insertEdge=(e,t)=>{const s=`${t.v1}:${t.v2}`;e.set(s,t)},deleteEdge=(e,t)=>{const s=`${t.v1}:${t.v2}`;e.delete(s)},findOppositeEdge=(e,t)=>{const s=`${t.v2}:${t.v1}`;return e.get(s)},calculateAnglesBetween=(e,t,s)=>{let c=e.prev.v1,l=e.prev.v2,h=t.next.v2;const f=calculateAngle(c,l,h,s);return c=t.prev.v1,l=t.prev.v2,h=e.next.v2,[f,calculateAngle(c,l,h,s)]},f=l.create(),g=l.create(),calculateAngle=(e,t,s,c)=>{const h=l.subtract(f,t,e),p=l.subtract(g,s,t);return l.cross(h,h,p),l.dot(h,c)},mergeCoplanarPolygons=e=>{if(e.length<2)return e;const t=e[0].plane,s=e.slice(),c=new Map;for(;s.length>0;){const e=s.shift(),l=createEdges(e);for(let e=0;e<l.length;e++){const s=l[e],h=findOppositeEdge(c,s);if(h){const e=calculateAnglesBetween(s,h,t);if(e[0]>=0&&e[1]>=0){const t=h.next,l=s.next;s.prev.next=h.next,s.next.prev=h.prev,h.prev.next=s.next,h.next.prev=s.prev,s.v1=null,s.v2=null,s.next=null,s.prev=null,deleteEdge(c,h),h.v1=null,h.v2=null,h.next=null,h.prev=null;const v=(e,t,s)=>{const c={v1:s.v1,v2:t.v2,next:t.next,prev:s.prev};s.prev.next=c,t.next.prev=c,deleteEdge(e,t),t.v1=null,t.v2=null,t.next=null,t.prev=null,deleteEdge(e,s),s.v1=null,s.v2=null,s.next=null,s.prev=null};0===e[0]&&v(c,t,t.prev),0===e[1]&&v(c,l,l.prev)}}else s.next&&insertEdge(c,s)}}const l=[];return c.forEach((e=>{const t=(e=>{let t;const s=[];for(;e.next;){const t=e.next;s.push(e.v1),e.v1=null,e.v2=null,e.next=null,e.prev=null,e=t}return s.length>0&&(t=h.create(s)),t})(e);t&&l.push(t)})),c.clear(),l};t.exports=(e,t)=>{const s=[];t.forEach((e=>{const t=s.find((t=>((e,t)=>Math.abs(e[3]-t[3])<15e-8&&c(e,t))(t[0],h.plane(e))));t?t[1].push(e):s.push([h.plane(e),[e]])}));let l=[];return s.forEach((e=>{const t=e[1],s=mergeCoplanarPolygons(t);l=l.concat(s)})),l}},{"../../geometries/poly3":78,"../../maths/utils/aboutEqualNormals":166,"../../maths/vec3":221}],353:[function(e,t,s){const{EPS:c}=e("../../maths/constants"),l=e("../../maths/line2"),h=e("../../maths/vec2"),f=e("../../maths/OrthoNormalBasis"),g=e("../../maths/utils/interpolateBetween2DPointsForY"),{insertSorted:p,fnNumberSort:d}=e("../../utils"),x=e("../../geometries/poly3");t.exports=e=>{if(e.length<2)return e;const t=[],s=e.length,w=x.plane(e[0]),b=new f(w),E=[],A=[],M=new Map,S=new Map,k=new Map,N=10/c;for(let t=0;t<s;t++){const s=e[t];let c=[],l=s.vertices.length,f=-1;if(l>0){let e,g;for(let p=0;p<l;p++){let l=b.to2D(s.vertices[p]);const d=Math.floor(l[1]*N);let x;k.has(d)?x=k.get(d):k.has(d+1)?x=k.get(d+1):k.has(d-1)?x=k.get(d-1):(x=l[1],k.set(d,l[1])),l=h.fromValues(l[0],x),c.push(l);const w=l[1];(0===p||w<e)&&(e=w,f=p),(0===p||w>g)&&(g=w);let E=S.get(w);E||(E={},S.set(w,E)),E[t]=!0}if(e>=g)c=[],l=0,f=-1;else{let s=M.get(e);s||(s=[],M.set(e,s)),s.push(t)}}c.reverse(),f=l-f-1,E.push(c),A.push(f)}const C=[];S.forEach(((e,t)=>C.push(t))),C.sort(d);let V=[],q=[];for(let e=0;e<C.length;e++){const s=[],f=C[e],d=S.get(f);for(let e=0;e<V.length;++e){const t=V[e],s=t.polygonindex;if(d[s]){const c=E[s],l=c.length;let h=t.leftvertexindex,g=t.rightvertexindex;for(;;){let e=h+1;if(e>=l&&(e=0),c[e][1]!==f)break;h=e}let p=g-1;if(p<0&&(p=l-1),c[p][1]===f&&(g=p),h!==t.leftvertexindex&&h===g)V.splice(e,1),--e;else{t.leftvertexindex=h,t.rightvertexindex=g,t.topleft=c[h],t.topright=c[g];let e=h+1;e>=l&&(e=0),t.bottomleft=c[e];let s=g-1;s<0&&(s=l-1),t.bottomright=c[s]}}}let k;if(e>=C.length-1)V=[],k=null;else{const t=.5*(f+(k=Number(C[e+1]))),s=M.get(f);for(const e in s){const c=s[e],l=E[c],h=l.length,d=A[c];let x=d;for(;;){let e=x+1;if(e>=h&&(e=0),l[e][1]!==f)break;if(e===d)break;x=e}let w=d;for(;;){let e=w-1;if(e<0&&(e=h-1),l[e][1]!==f)break;if(e===x)break;w=e}let b=x+1;b>=h&&(b=0);let M=w-1;M<0&&(M=h-1);const S={polygonindex:c,leftvertexindex:x,rightvertexindex:w,topleft:l[x],topright:l[w],bottomleft:l[b],bottomright:l[M]};p(V,S,((e,s)=>{const c=g(e.topleft,e.bottomleft,t),l=g(s.topleft,s.bottomleft,t);return c>l?1:c<l?-1:0}))}}for(const e in V){const t=V[e];let p=g(t.topleft,t.bottomleft,f);const d=h.fromValues(p,f);p=g(t.topright,t.bottomright,f);const x=h.fromValues(p,f);p=g(t.topleft,t.bottomleft,k);const w=h.fromValues(p,k);p=g(t.topright,t.bottomright,k);const b=h.fromValues(p,k),E={topleft:d,topright:x,bottomleft:w,bottomright:b,leftline:l.fromPoints(l.create(),d,w),rightline:l.fromPoints(l.create(),b,x)};if(s.length>0){const e=s[s.length-1],t=h.distance(E.topleft,e.topright),l=h.distance(E.bottomleft,e.bottomright);t<c&&l<c&&(E.topleft=e.topleft,E.leftline=e.leftline,E.bottomleft=e.bottomleft,s.splice(s.length-1,1))}s.push(E)}if(e>0){const e=new Set,f=new Set;for(let t=0;t<s.length;t++){const g=s[t];for(let t=0;t<q.length;t++)if(!f.has(t)){const s=q[t];if(h.distance(s.bottomleft,g.topleft)<c&&h.distance(s.bottomright,g.topright)<c){f.add(t);const h=l.direction(g.leftline),p=l.direction(s.leftline),d=h[0]-p[0],x=l.direction(g.rightline),w=l.direction(s.rightline),b=x[0]-w[0],E=Math.abs(d)<c,A=Math.abs(b)<c;(E||d>=0)&&(A||b>=0)&&(g.outpolygon=s.outpolygon,g.leftlinecontinues=E,g.rightlinecontinues=A,e.add(t));break}}}for(let s=0;s<q.length;s++)if(!e.has(s)){const e=q[s];e.outpolygon.rightpoints.push(e.bottomright),h.distance(e.bottomright,e.bottomleft)>c&&e.outpolygon.leftpoints.push(e.bottomleft),e.outpolygon.leftpoints.reverse();const l=e.outpolygon.rightpoints.concat(e.outpolygon.leftpoints).map((e=>b.to3D(e))),f=x.fromPointsAndPlane(l,w);f.vertices.length&&t.push(f)}}for(let e=0;e<s.length;e++){const t=s[e];t.outpolygon?(t.leftlinecontinues||t.outpolygon.leftpoints.push(t.topleft),t.rightlinecontinues||t.outpolygon.rightpoints.push(t.topright)):(t.outpolygon={leftpoints:[],rightpoints:[]},t.outpolygon.leftpoints.push(t.topleft),h.distance(t.topleft,t.topright)>c&&t.outpolygon.rightpoints.push(t.topright))}q=s}return t}},{"../../geometries/poly3":78,"../../maths/OrthoNormalBasis":92,"../../maths/constants":93,"../../maths/line2":104,"../../maths/utils/interpolateBetween2DPointsForY":169,"../../maths/vec2":190,"../../utils":398}],354:[function(e,t,s){const c=e("../../geometries/geom3"),l=e("../../geometries/poly3"),{NEPS:h}=e("../../maths/constants"),f=e("./reTesselateCoplanarPolygons"),classifyPolygons=e=>{let t=[e];const s=[];for(let e=3;e>=0;e--){const c=[],l=3===e?15e-9:h;t.forEach((t=>{t.sort(byPlaneComponent(e,l));let h=0;for(let f=1;f<t.length;f++)t[f].plane[e]-t[h].plane[e]>l&&(f-h==1?s.push(t[h]):c.push(t.slice(h,f)),h=f);t.length-h==1?s.push(t[h]):c.push(t.slice(h))})),t=c}const c=[];return t.forEach((e=>{e[0]&&(c[e[0].index]=e)})),s.forEach((e=>{c[e.index]=e})),c},byPlaneComponent=(e,t)=>(s,c)=>s.plane[e]-c.plane[e]>t?1:c.plane[e]-s.plane[e]>t?-1:0;t.exports=e=>{if(e.isRetesselated)return e;const t=c.toPolygons(e).map(((e,t)=>({vertices:e.vertices,plane:l.plane(e),index:t}))),s=classifyPolygons(t),h=[];s.forEach((e=>{if(Array.isArray(e)){const t=f(e);h.push(...t)}else h.push(e)}));const g=c.create(h);return g.isRetesselated=!0,g}},{"../../geometries/geom3":40,"../../geometries/poly3":78,"../../maths/constants":93,"./reTesselateCoplanarPolygons":353}],355:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../maths/vec2"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("../../geometries/path2"),p=e("../../measurements/measureEpsilon"),d=e("./snapPolygons");t.exports=(...e)=>{if(0===(e=c(e)).length)throw new Error("wrong number of arguments");const t=e.map((e=>g.isA(e)?(e=>{const t=p(e),s=g.toPoints(e).map((e=>l.snap(l.create(),e,t)));return g.create(s)})(e):h.isA(e)?(e=>{const t=p(e);let s=h.toSides(e).map((e=>[l.snap(l.create(),e[0],t),l.snap(l.create(),e[1],t)]));return s=s.filter((e=>!l.equals(e[0],e[1]))),h.create(s)})(e):f.isA(e)?(e=>{const t=p(e),s=f.toPolygons(e),c=d(t,s);return f.create(c)})(e):e));return 1===t.length?t[0]:t}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../maths/vec2":190,"../../measurements/measureEpsilon":262,"../../utils/flatten":396,"./snapPolygons":356}],356:[function(e,t,s){const c=e("../../maths/vec3"),l=e("../../geometries/poly3");t.exports=(e,t)=>{let s=t.map((t=>{const s=t.vertices.map((t=>c.snap(c.create(),t,e))),h=[];for(let e=0;e<s.length;e++){const t=(e+1)%s.length;c.equals(s[e],s[t])||h.push(s[e])}const f=l.create(h);return t.color&&(f.color=t.color),f}));const h=e*e*Math.sqrt(3)/4;return s.filter((e=>((e,t)=>{const s=Math.abs(l.measureArea(t));return Number.isFinite(s)&&s>e})(h,e)))}},{"../../geometries/poly3":78,"../../maths/vec3":221}],357:[function(e,t,s){const c=e("../../maths/vec3"),l=e("../../geometries/poly3");t.exports=(e,t)=>{const s=[];return t.forEach((t=>{((e,t,s)=>{const h=t.vertices.length;if(h>3){if(h>4){const f=[0,0,0];t.vertices.forEach((e=>c.add(f,f,e))),c.snap(f,c.divide(f,f,[h,h,h]),e);for(let e=0;e<h;e++){const c=l.create([f,t.vertices[e],t.vertices[(e+1)%h]]);t.color&&(c.color=t.color),s.push(c)}return}const f=l.create([t.vertices[0],t.vertices[1],t.vertices[2]]),g=l.create([t.vertices[0],t.vertices[2],t.vertices[3]]);return t.color&&(f.color=t.color,g.color=t.color),void s.push(f,g)}s.push(t)})(e,t,s)})),s}},{"../../geometries/poly3":78,"../../maths/vec3":221}],358:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../utils/padArrayToLength"),h=e("../../measurements/measureAggregateBoundingBox"),{translate:f}=e("./translate"),alignGeometries=(e,t,s)=>{const c=h(e),l=[0,0,0];for(let e=0;e<3;e++)"center"===t[e]?l[e]=s[e]-(c[0][e]+c[1][e])/2:"max"===t[e]?l[e]=s[e]-c[1][e]:"min"===t[e]&&(l[e]=s[e]-c[0][e]);return f(l,e)};t.exports=(e,...t)=>{e=(e=>{if(!Array.isArray(e.modes)||e.modes.length>3)throw new Error("align(): modes must be an array of length <= 3");if(e.modes=l(e.modes,"none",3),3!==e.modes.filter((e=>["center","max","min","none"].includes(e))).length)throw new Error('align(): all modes must be one of "center", "max" or "min"');if(!Array.isArray(e.relativeTo)||e.relativeTo.length>3)throw new Error("align(): relativeTo must be an array of length <= 3");if(e.relativeTo=l(e.relativeTo,0,3),3!==e.relativeTo.filter((e=>Number.isFinite(e)||null==e)).length)throw new Error("align(): all relativeTo values must be a number, or null.");if("boolean"!=typeof e.grouped)throw new Error("align(): grouped must be a boolean value.");return e})(e=Object.assign({},{modes:["center","center","min"],relativeTo:[0,0,0],grouped:!1},e));let{modes:s,relativeTo:f,grouped:g}=e;if(0===(t=c(t)).length)throw new Error("align(): No geometries were provided to act upon");if(f.filter((e=>null==e)).length){const e=h(t);f=((e,t,s)=>{for(let c=0;c<3;c++)null==e[c]&&("center"===t[c]?e[c]=(s[0][c]+s[1][c])/2:"max"===t[c]?e[c]=s[1][c]:"min"===t[c]&&(e[c]=s[0][c]));return e})(f,s,e)}return 1===(t=g?alignGeometries(t,s,f):t.map((e=>alignGeometries(e,s,f)))).length?t[0]:t}},{"../../measurements/measureAggregateBoundingBox":253,"../../utils/flatten":396,"../../utils/padArrayToLength":400,"./translate":365}],359:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom2"),h=e("../../geometries/geom3"),f=e("../../geometries/path2"),g=e("../../measurements/measureBoundingBox"),{translate:p}=e("./translate"),centerGeometry=(e,t)=>{const{axes:s,relativeTo:c}=Object.assign({},{axes:[!0,!0,!0],relativeTo:[0,0,0]},e),l=g(t),h=[0,0,0];return s[0]&&(h[0]=c[0]-(l[0][0]+(l[1][0]-l[0][0])/2)),s[1]&&(h[1]=c[1]-(l[0][1]+(l[1][1]-l[0][1])/2)),s[2]&&(h[2]=c[2]-(l[0][2]+(l[1][2]-l[0][2])/2)),p(h,t)},center=(e,...t)=>{const{axes:s,relativeTo:g}=Object.assign({},{axes:[!0,!0,!0],relativeTo:[0,0,0]},e);if(0===(t=c(t)).length)throw new Error("wrong number of arguments");if(3!==g.length)throw new Error("relativeTo must be an array of length 3");e={axes:s,relativeTo:g};const p=t.map((t=>f.isA(t)||l.isA(t)||h.isA(t)?centerGeometry(e,t):t));return 1===p.length?p[0]:p};t.exports={center:center,centerX:(...e)=>center({axes:[!0,!1,!1]},e),centerY:(...e)=>center({axes:[!1,!0,!1]},e),centerZ:(...e)=>center({axes:[!1,!1,!0]},e)}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../measurements/measureBoundingBox":257,"../../utils/flatten":396,"./translate":365}],360:[function(e,t,s){t.exports={align:e("./align"),center:e("./center").center,centerX:e("./center").centerX,centerY:e("./center").centerY,centerZ:e("./center").centerZ,mirror:e("./mirror").mirror,mirrorX:e("./mirror").mirrorX,mirrorY:e("./mirror").mirrorY,mirrorZ:e("./mirror").mirrorZ,rotate:e("./rotate").rotate,rotateX:e("./rotate").rotateX,rotateY:e("./rotate").rotateY,rotateZ:e("./rotate").rotateZ,scale:e("./scale").scale,scaleX:e("./scale").scaleX,scaleY:e("./scale").scaleY,scaleZ:e("./scale").scaleZ,transform:e("./transform"),translate:e("./translate").translate,translateX:e("./translate").translateX,translateY:e("./translate").translateY,translateZ:e("./translate").translateZ}},{"./align":358,"./center":359,"./mirror":361,"./rotate":362,"./scale":363,"./transform":364,"./translate":365}],361:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../maths/mat4"),h=e("../../maths/plane"),f=e("../../geometries/geom2"),g=e("../../geometries/geom3"),p=e("../../geometries/path2"),mirror=(e,...t)=>{const{origin:s,normal:d}=Object.assign({},{origin:[0,0,0],normal:[0,0,1]},e);if(0===(t=c(t)).length)throw new Error("wrong number of arguments");const x=h.fromNormalAndPoint(h.create(),d,s);if(Number.isNaN(x[0]))throw new Error("the given origin and normal do not define a proper plane");const w=l.mirrorByPlane(l.create(),x),b=t.map((e=>p.isA(e)?p.transform(w,e):f.isA(e)?f.transform(w,e):g.isA(e)?g.transform(w,e):e));return 1===b.length?b[0]:b};t.exports={mirror:mirror,mirrorX:(...e)=>mirror({normal:[1,0,0]},e),mirrorY:(...e)=>mirror({normal:[0,1,0]},e),mirrorZ:(...e)=>mirror({normal:[0,0,1]},e)}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../maths/mat4":142,"../../maths/plane":162,"../../utils/flatten":396}],362:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../maths/mat4"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("../../geometries/path2"),rotate=(e,...t)=>{if(!Array.isArray(e))throw new Error("angles must be an array");if(0===(t=c(t)).length)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(0);const s=e[2],p=e[1],d=e[0],x=l.fromTaitBryanRotation(l.create(),s,p,d),w=t.map((e=>g.isA(e)?g.transform(x,e):h.isA(e)?h.transform(x,e):f.isA(e)?f.transform(x,e):e));return 1===w.length?w[0]:w};t.exports={rotate:rotate,rotateX:(e,...t)=>rotate([e,0,0],t),rotateY:(e,...t)=>rotate([0,e,0],t),rotateZ:(e,...t)=>rotate([0,0,e],t)}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../maths/mat4":142,"../../utils/flatten":396}],363:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../maths/mat4"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("../../geometries/path2"),scale=(e,...t)=>{if(!Array.isArray(e))throw new Error("factors must be an array");if(0===(t=c(t)).length)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(1);if(e[0]<=0||e[1]<=0||e[2]<=0)throw new Error("factors must be positive");const s=l.fromScaling(l.create(),e),p=t.map((e=>g.isA(e)?g.transform(s,e):h.isA(e)?h.transform(s,e):f.isA(e)?f.transform(s,e):e));return 1===p.length?p[0]:p};t.exports={scale:scale,scaleX:(e,...t)=>scale([e,1,1],t),scaleY:(e,...t)=>scale([1,e,1],t),scaleZ:(e,...t)=>scale([1,1,e],t)}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../maths/mat4":142,"../../utils/flatten":396}],364:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../geometries/geom2"),h=e("../../geometries/geom3"),f=e("../../geometries/path2");t.exports=(e,...t)=>{if(0===(t=c(t)).length)throw new Error("wrong number of arguments");const s=t.map((t=>f.isA(t)?f.transform(e,t):l.isA(t)?l.transform(e,t):h.isA(t)?h.transform(e,t):t));return 1===s.length?s[0]:s}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../utils/flatten":396}],365:[function(e,t,s){const c=e("../../utils/flatten"),l=e("../../maths/mat4"),h=e("../../geometries/geom2"),f=e("../../geometries/geom3"),g=e("../../geometries/path2"),translate=(e,...t)=>{if(!Array.isArray(e))throw new Error("offset must be an array");if(0===(t=c(t)).length)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(0);const s=l.fromTranslation(l.create(),e),p=t.map((e=>g.isA(e)?g.transform(s,e):h.isA(e)?h.transform(s,e):f.isA(e)?f.transform(s,e):e));return 1===p.length?p[0]:p};t.exports={translate:translate,translateX:(e,...t)=>translate([e,0,0],t),translateY:(e,...t)=>translate([0,e,0],t),translateZ:(e,...t)=>translate([0,0,e],t)}},{"../../geometries/geom2":25,"../../geometries/geom3":40,"../../geometries/path2":61,"../../maths/mat4":142,"../../utils/flatten":396}],366:[function(e,t,s){const{EPS:c,TAU:l}=e("../maths/constants"),h=e("../maths/vec2"),f=e("../geometries/path2"),{isGT:g,isGTE:p,isNumberArray:d}=e("./commonChecks");t.exports=e=>{const t={center:[0,0],radius:1,startAngle:0,endAngle:l,makeTangent:!1,segments:32};let{center:s,radius:x,startAngle:w,endAngle:b,makeTangent:E,segments:A}=Object.assign({},t,e);if(!d(s,2))throw new Error("center must be an array of X and Y values");if(!g(x,0))throw new Error("radius must be greater than zero");if(!p(w,0))throw new Error("startAngle must be positive");if(!p(b,0))throw new Error("endAngle must be positive");if(!p(A,4))throw new Error("segments must be four or more");let M=l;(w%=l)<(b%=l)&&(M=b-w),w>b&&(M=b+(l-w));const S=Math.acos((x*x+x*x-c*c)/(2*x*x)),k=h.clone(s);let N;const C=[];if(M<S)N=h.fromAngleRadians(h.create(),w),h.scale(N,N,x),h.add(N,N,k),C.push(N);else{const e=Math.max(1,Math.floor(A*(M/l)))+1;let t=.5*e/M;t>.25&&(t=.25);const s=E?e+2:e;for(let c=0;c<=s;c++){let s=c;E&&((s=(c-1)*(e-2*t)/e+t)<0&&(s=0),s>e&&(s=e));const l=w+s*(M/e);N=h.fromAngleRadians(h.create(),l),h.scale(N,N,x),h.add(N,N,k),C.push(N)}}return f.fromPoints({closed:!1},C)}},{"../geometries/path2":61,"../maths/constants":93,"../maths/vec2":190,"./commonChecks":368}],367:[function(e,t,s){const{TAU:c}=e("../maths/constants"),l=e("./ellipse"),{isGTE:h}=e("./commonChecks");t.exports=e=>{const t={center:[0,0],radius:1,startAngle:0,endAngle:c,segments:32};let{center:s,radius:f,startAngle:g,endAngle:p,segments:d}=Object.assign({},t,e);if(!h(f,0))throw new Error("radius must be positive");return l({center:s,radius:f=[f,f],startAngle:g,endAngle:p,segments:d})}},{"../maths/constants":93,"./commonChecks":368,"./ellipse":373}],368:[function(e,t,s){t.exports={isNumberArray:(e,t)=>!!(Array.isArray(e)&&e.length>=t)&&e.every((e=>Number.isFinite(e))),isGT:(e,t)=>Number.isFinite(e)&&e>t,isGTE:(e,t)=>Number.isFinite(e)&&e>=t}},{}],369:[function(e,t,s){const c=e("./cuboid"),{isGTE:l}=e("./commonChecks");t.exports=e=>{let{center:t,size:s}=Object.assign({},{center:[0,0,0],size:2},e);if(!l(s,0))throw new Error("size must be positive");return c({center:t,size:s=[s,s,s]})}},{"./commonChecks":368,"./cuboid":370}],370:[function(e,t,s){const c=e("../geometries/geom3"),l=e("../geometries/poly3"),{isNumberArray:h}=e("./commonChecks");t.exports=e=>{const{center:t,size:s}=Object.assign({},{center:[0,0,0],size:[2,2,2]},e);if(!h(t,3))throw new Error("center must be an array of X, Y and Z values");if(!h(s,3))throw new Error("size must be an array of width, depth and height values");if(!s.every((e=>e>=0)))throw new Error("size values must be positive");return 0===s[0]||0===s[1]||0===s[2]?c.create():c.create([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map((e=>{const c=e[0].map((e=>[t[0]+s[0]/2*(2*!!(1&e)-1),t[1]+s[1]/2*(2*!!(2&e)-1),t[2]+s[2]/2*(2*!!(4&e)-1)]));return l.create(c)})))}},{"../geometries/geom3":40,"../geometries/poly3":78,"./commonChecks":368}],371:[function(e,t,s){const c=e("../geometries/geom3"),l=e("./cylinderElliptic"),{isGTE:h}=e("./commonChecks");t.exports=e=>{const{center:t,height:s,radius:f,segments:g}=Object.assign({},{center:[0,0,0],height:2,radius:1,segments:32},e);if(!h(f,0))throw new Error("radius must be positive");return 0===s||0===f?c.create():l({center:t,height:s,startRadius:[f,f],endRadius:[f,f],segments:g})}},{"../geometries/geom3":40,"./commonChecks":368,"./cylinderElliptic":372}],372:[function(e,t,s){const{EPS:c,TAU:l}=e("../maths/constants"),h=e("../maths/vec3"),f=e("../geometries/geom3"),g=e("../geometries/poly3"),{sin:p,cos:d}=e("../maths/utils/trigonometry"),{isGT:x,isGTE:w,isNumberArray:b}=e("./commonChecks");t.exports=e=>{const t={center:[0,0,0],height:2,startRadius:[1,1],startAngle:0,endRadius:[1,1],endAngle:l,segments:32};let{center:s,height:E,startRadius:A,startAngle:M,endRadius:S,endAngle:k,segments:N}=Object.assign({},t,e);if(!b(s,3))throw new Error("center must be an array of X, Y and Z values");if(!x(E,0))throw new Error("height must be greater then zero");if(!b(A,2))throw new Error("startRadius must be an array of X and Y values");if(!A.every((e=>e>=0)))throw new Error("startRadius values must be positive");if(!b(S,2))throw new Error("endRadius must be an array of X and Y values");if(!S.every((e=>e>=0)))throw new Error("endRadius values must be positive");if(S.every((e=>0===e))&&A.every((e=>0===e)))throw new Error("at least one radius must be positive");if(!w(M,0))throw new Error("startAngle must be positive");if(!w(k,0))throw new Error("endAngle must be positive");if(!w(N,4))throw new Error("segments must be four or more");let C=l;(M%=l)<(k%=l)&&(C=k-M),M>k&&(C=k+(l-M));const V=Math.min(A[0],A[1],S[0],S[1]),q=Math.acos((V*V+V*V-c*c)/(2*V*V));if(C<q)throw new Error("startAngle and endAngle do not define a significant rotation");const R=Math.floor(N*(C/l)),O=h.fromValues(0,0,-E/2),B=h.fromValues(0,0,E/2),F=h.subtract(h.create(),B,O),z=h.fromValues(1,0,0),D=h.fromValues(0,1,0),j=h.create(),Z=h.create(),G=h.create(),y=(e,t,s)=>{const c=t*C+M;return h.scale(j,z,s[0]*d(c)),h.scale(Z,D,s[1]*p(c)),h.add(j,j,Z),h.scale(G,F,e),h.add(G,G,O),h.add(h.create(),j,G)},T=(...e)=>{const t=e.map((e=>h.add(h.create(),e,s)));return g.create(t)},X=[];for(let e=0;e<R;e++){const t=e/R;let s=(e+1)/R;C===l&&e===R-1&&(s=0),S[0]===A[0]&&S[1]===A[1]?(X.push(T(O,y(0,s,S),y(0,t,S))),X.push(T(y(0,s,S),y(1,s,S),y(1,t,S),y(0,t,S))),X.push(T(B,y(1,t,S),y(1,s,S)))):(A[0]>0&&A[1]>0&&X.push(T(O,y(0,s,A),y(0,t,A))),(A[0]>0||A[1]>0)&&X.push(T(y(0,t,A),y(0,s,A),y(1,t,S))),S[0]>0&&S[1]>0&&X.push(T(B,y(1,t,S),y(1,s,S))),(S[0]>0||S[1]>0)&&X.push(T(y(1,t,S),y(0,s,A),y(1,s,S))))}return C<l&&(X.push(T(O,y(0,0,A),B)),X.push(T(y(0,0,A),y(1,0,S),B)),X.push(T(O,B,y(0,1,A))),X.push(T(y(0,1,A),B,y(1,1,S)))),f.create(X)}},{"../geometries/geom3":40,"../geometries/poly3":78,"../maths/constants":93,"../maths/utils/trigonometry":172,"../maths/vec3":221,"./commonChecks":368}],373:[function(e,t,s){const{EPS:c,TAU:l}=e("../maths/constants"),h=e("../maths/vec2"),f=e("../geometries/geom2"),{sin:g,cos:p}=e("../maths/utils/trigonometry"),{isGTE:d,isNumberArray:x}=e("./commonChecks");t.exports=e=>{const t={center:[0,0],radius:[1,1],startAngle:0,endAngle:l,segments:32};let{center:s,radius:w,startAngle:b,endAngle:E,segments:A}=Object.assign({},t,e);if(!x(s,2))throw new Error("center must be an array of X and Y values");if(!x(w,2))throw new Error("radius must be an array of X and Y values");if(!w.every((e=>e>=0)))throw new Error("radius values must be positive");if(!d(b,0))throw new Error("startAngle must be positive");if(!d(E,0))throw new Error("endAngle must be positive");if(!d(A,3))throw new Error("segments must be three or more");if(0===w[0]||0===w[1])return f.create();let M=l;(b%=l)<(E%=l)&&(M=E-b),b>E&&(M=E+(l-b));const S=Math.min(w[0],w[1]);if(M<Math.acos((S*S+S*S-c*c)/(2*S*S)))throw new Error("startAngle and endAngle do not define a significant rotation");A=Math.floor(A*(M/l));const k=h.clone(s),N=M/A,C=[];A=M<l?A+1:A;for(let e=0;e<A;e++){const t=N*e+b,s=h.fromValues(w[0]*p(t),w[1]*g(t));h.add(s,k,s),C.push(s)}return M<l&&C.push(k),f.fromPoints(C)}},{"../geometries/geom2":25,"../maths/constants":93,"../maths/utils/trigonometry":172,"../maths/vec2":190,"./commonChecks":368}],374:[function(e,t,s){const{TAU:c}=e("../maths/constants"),l=e("../maths/vec3"),h=e("../geometries/geom3"),f=e("../geometries/poly3"),{sin:g,cos:p}=e("../maths/utils/trigonometry"),{isGTE:d,isNumberArray:x}=e("./commonChecks");t.exports=e=>{const{center:t,radius:s,segments:w,axes:b}=Object.assign({},{center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},e);if(!x(t,3))throw new Error("center must be an array of X, Y and Z values");if(!x(s,3))throw new Error("radius must be an array of X, Y and Z values");if(!s.every((e=>e>=0)))throw new Error("radius values must be positive");if(!d(w,4))throw new Error("segments must be four or more");if(0===s[0]||0===s[1]||0===s[2])return h.create();const E=l.scale(l.create(),l.normalize(l.create(),b[0]),s[0]),A=l.scale(l.create(),l.normalize(l.create(),b[1]),s[1]),M=l.scale(l.create(),l.normalize(l.create(),b[2]),s[2]),S=Math.round(w/4);let k;const N=[],C=l.create(),V=l.create();for(let e=0;e<=w;e++){const s=c*e/w,h=l.add(l.create(),l.scale(C,E,p(s)),l.scale(V,A,g(s)));if(e>0){let e,s;for(let d=0;d<=S;d++){const x=c/4*d/S,w=p(x),b=g(x);if(d>0){let c,g=[];c=l.subtract(l.create(),l.scale(C,k,e),l.scale(V,M,s)),g.push(l.add(c,c,t)),c=l.subtract(l.create(),l.scale(C,h,e),l.scale(V,M,s)),g.push(l.add(c,c,t)),d<S&&(c=l.subtract(l.create(),l.scale(C,h,w),l.scale(V,M,b)),g.push(l.add(c,c,t))),c=l.subtract(l.create(),l.scale(C,k,w),l.scale(V,M,b)),g.push(l.add(c,c,t)),N.push(f.create(g)),g=[],c=l.add(l.create(),l.scale(C,k,e),l.scale(V,M,s)),g.push(l.add(l.create(),t,c)),c=l.add(c,l.scale(C,h,e),l.scale(V,M,s)),g.push(l.add(l.create(),t,c)),d<S&&(c=l.add(c,l.scale(C,h,w),l.scale(V,M,b)),g.push(l.add(l.create(),t,c))),c=l.add(c,l.scale(C,k,w),l.scale(V,M,b)),g.push(l.add(l.create(),t,c)),g.reverse(),N.push(f.create(g))}e=w,s=b}}k=h}return h.create(N)}},{"../geometries/geom3":40,"../geometries/poly3":78,"../maths/constants":93,"../maths/utils/trigonometry":172,"../maths/vec3":221,"./commonChecks":368}],375:[function(e,t,s){const c=e("../maths/mat4"),l=e("../maths/vec3"),h=e("../geometries/geom3"),f=e("./polyhedron"),{isGTE:g}=e("./commonChecks");t.exports=e=>{let{radius:t,frequency:s}=Object.assign({},{radius:1,frequency:6},e);if(!g(t,0))throw new Error("radius must be positive");if(!g(s,6))throw new Error("frequency must be six or more");if(0===t)return h.create();s=Math.floor(s/6);const p=[[.850651,0,-.525731],[.850651,-0,.525731],[-.850651,-0,.525731],[-.850651,0,-.525731],[0,-.525731,.850651],[0,.525731,.850651],[0,.525731,-.850651],[0,-.525731,-.850651],[-.525731,-.850651,-0],[.525731,-.850651,-0],[.525731,.850651,0],[-.525731,.850651,0]],d=[[0,9,1],[1,10,0],[6,7,0],[10,6,0],[7,9,0],[5,1,4],[4,1,9],[5,10,1],[2,8,3],[3,11,2],[2,5,4],[4,8,2],[2,11,5],[3,7,6],[6,11,3],[8,7,3],[9,8,4],[11,10,5],[10,11,6],[8,9,7]],n=(e,t,s)=>{const c=e[0],h=e[1],f=e[2];let g=s;const p=[],d=[];for(let e=0;e<t;e++)for(let s=0;s<t-e;s++){const x=e/t,w=(e+1)/t,b=s/(t-e),E=(s+1)/(t-e),A=t-e-1?s/(t-e-1):1,M=[];M[0]=i(i(c,h,b),f,x),M[1]=i(i(c,h,E),f,x),M[2]=i(i(c,h,A),f,w);for(let e=0;e<3;e++){const t=l.length(M[e]);for(let s=0;s<3;s++)M[e][s]/=t}if(p.push(M[0],M[1],M[2]),d.push([g,g+1,g+2]),g+=3,s<t-e-1){const b=t-e-1?(s+1)/(t-e-1):1;M[0]=i(i(c,h,E),f,x),M[1]=i(i(c,h,b),f,w),M[2]=i(i(c,h,A),f,w);for(let e=0;e<3;e++){const t=l.length(M[e]);for(let s=0;s<3;s++)M[e][s]/=t}p.push(M[0],M[1],M[2]),d.push([g,g+1,g+2]),g+=3}}return{points:p,triangles:d,offset:g}},i=(e,t,s)=>{const c=1-s,l=[];for(let h=0;h<3;h++)l[h]=e[h]*c+t[h]*s;return l};let x=[],w=[],b=0;for(let e=0;e<d.length;e++){const t=n([p[d[e][0]],p[d[e][1]],p[d[e][2]]],s,b);x=x.concat(t.points),w=w.concat(t.triangles),b=t.offset}let E=f({points:x,faces:w,orientation:"inward"});return 1!==t&&(E=h.transform(c.fromScaling(c.create(),[t,t,t]),E)),E}},{"../geometries/geom3":40,"../maths/mat4":142,"../maths/vec3":221,"./commonChecks":368,"./polyhedron":379}],376:[function(e,t,s){t.exports={arc:e("./arc"),circle:e("./circle"),cube:e("./cube"),cuboid:e("./cuboid"),cylinder:e("./cylinder"),cylinderElliptic:e("./cylinderElliptic"),ellipse:e("./ellipse"),ellipsoid:e("./ellipsoid"),geodesicSphere:e("./geodesicSphere"),line:e("./line"),polygon:e("./polygon"),polyhedron:e("./polyhedron"),rectangle:e("./rectangle"),roundedCuboid:e("./roundedCuboid"),roundedCylinder:e("./roundedCylinder"),roundedRectangle:e("./roundedRectangle"),sphere:e("./sphere"),square:e("./square"),star:e("./star"),torus:e("./torus"),triangle:e("./triangle")}},{"./arc":366,"./circle":367,"./cube":369,"./cuboid":370,"./cylinder":371,"./cylinderElliptic":372,"./ellipse":373,"./ellipsoid":374,"./geodesicSphere":375,"./line":377,"./polygon":378,"./polyhedron":379,"./rectangle":380,"./roundedCuboid":381,"./roundedCylinder":382,"./roundedRectangle":383,"./sphere":384,"./square":385,"./star":386,"./torus":387,"./triangle":388}],377:[function(e,t,s){const c=e("../geometries/path2");t.exports=e=>{if(!Array.isArray(e))throw new Error("points must be an array");return c.fromPoints({},e)}},{"../geometries/path2":61}],378:[function(e,t,s){const c=e("../geometries/geom2");t.exports=e=>{const{points:t,paths:s,orientation:l}=Object.assign({},{points:[],paths:[],orientation:"counterclockwise"},e);if(!Array.isArray(t)||!Array.isArray(s))throw new Error("points and paths must be arrays");let h=t;Array.isArray(t[0])&&(Array.isArray(t[0][0])||(h=[t])),h.forEach(((e,t)=>{if(!Array.isArray(e))throw new Error("list of points "+t+" must be an array");if(e.length<3)throw new Error("list of points "+t+" must contain three or more points");e.forEach(((e,s)=>{if(!Array.isArray(e))throw new Error("list of points "+t+", point "+s+" must be an array");if(e.length<2)throw new Error("list of points "+t+", point "+s+" must contain by X and Y values")}))}));let f=s;if(0===s.length){let e=0;f=h.map((t=>t.map((t=>e++))))}const g=[];h.forEach((e=>e.forEach((e=>g.push(e)))));let p=[];f.forEach((e=>{const t=e.map((e=>g[e])),s=c.fromPoints(t);p=p.concat(c.toSides(s))}));let d=c.create(p);return"clockwise"==l&&(d=c.reverse(d)),d}},{"../geometries/geom2":25}],379:[function(e,t,s){const c=e("../geometries/geom3"),l=e("../geometries/poly3"),{isNumberArray:h}=e("./commonChecks");t.exports=e=>{const{points:t,faces:s,colors:f,orientation:g}=Object.assign({},{points:[],faces:[],colors:void 0,orientation:"outward"},e);if(!Array.isArray(t)||!Array.isArray(s))throw new Error("points and faces must be arrays");if(t.length<3)throw new Error("three or more points are required");if(s.length<1)throw new Error("one or more faces are required");if(f){if(!Array.isArray(f))throw new Error("colors must be an array");if(f.length!==s.length)throw new Error("faces and colors must have the same length")}t.forEach(((e,t)=>{if(!h(e,3))throw new Error(`point ${t} must be an array of X, Y, Z values`)})),s.forEach(((e,t)=>{if(e.length<3)throw new Error(`face ${t} must contain 3 or more indexes`);if(!h(e,e.length))throw new Error(`face ${t} must be an array of numbers`)})),"outward"!==g&&s.forEach((e=>e.reverse()));const p=s.map(((e,s)=>{const c=l.create(e.map((e=>t[e])));return f&&f[s]&&(c.color=f[s]),c}));return c.create(p)}},{"../geometries/geom3":40,"../geometries/poly3":78,"./commonChecks":368}],380:[function(e,t,s){const c=e("../maths/vec2"),l=e("../geometries/geom2"),{isNumberArray:h}=e("./commonChecks");t.exports=e=>{const{center:t,size:s}=Object.assign({},{center:[0,0],size:[2,2]},e);if(!h(t,2))throw new Error("center must be an array of X and Y values");if(!h(s,2))throw new Error("size must be an array of X and Y values");if(!s.every((e=>e>=0)))throw new Error("size values must be positive");if(0===s[0]||0===s[1])return l.create();const f=[s[0]/2,s[1]/2],g=[f[0],-f[1]],p=[c.subtract(c.create(),t,f),c.add(c.create(),t,g),c.add(c.create(),t,f),c.subtract(c.create(),t,g)];return l.fromPoints(p)}},{"../geometries/geom2":25,"../maths/vec2":190,"./commonChecks":368}],381:[function(e,t,s){const{EPS:c,TAU:l}=e("../maths/constants"),h=e("../maths/vec2"),f=e("../maths/vec3"),g=e("../geometries/geom3"),p=e("../geometries/poly3"),{sin:d,cos:x}=e("../maths/utils/trigonometry"),{isGTE:w,isNumberArray:b}=e("./commonChecks"),E=e("./cuboid"),createCorners=(e,t,s,g,p,w)=>{const b=l/4*p/g,E=x(b),A=d(b),M=g-p;let S=s*E,k=t[2]-(s-s*A);w||(k=s-s*A-t[2]),S=S>c?S:0;const N=f.add(f.create(),e,[t[0]-s,t[1]-s,k]),C=f.add(f.create(),e,[s-t[0],t[1]-s,k]),V=f.add(f.create(),e,[s-t[0],s-t[1],k]),q=f.add(f.create(),e,[t[0]-s,s-t[1],k]),R=[],O=[],B=[],F=[];for(let e=0;e<=M;e++){const t=M>0?l/4*e/M:0,s=h.fromAngleRadians(h.create(),t);h.scale(s,s,S);const c=f.fromVec2(f.create(),s);R.push(f.add(f.create(),N,c)),f.rotateZ(c,c,[0,0,0],l/4),O.push(f.add(f.create(),C,c)),f.rotateZ(c,c,[0,0,0],l/4),B.push(f.add(f.create(),V,c)),f.rotateZ(c,c,[0,0,0],l/4),F.push(f.add(f.create(),q,c))}return w?[R,O,B,F]:(R.reverse(),O.reverse(),B.reverse(),F.reverse(),[F,B,O,R])},stitchCorners=(e,t)=>{const s=[];for(let c=0;c<e.length;c++){const l=e[c],h=t[c];for(let e=0;e<l.length-1;e++)s.push(p.create([l[e],l[e+1],h[e]])),e<h.length-1&&s.push(p.create([h[e],l[e+1],h[e+1]]))}return s},stitchWalls=(e,t)=>{const s=[];for(let c=0;c<e.length;c++){let l=e[c],h=t[c];const f=l[l.length-1],g=h[h.length-1],d=(c+1)%e.length;l=e[d],h=t[d];const x=l[0],w=h[0];s.push(p.create([f,x,w,g]))}return s},stitchSides=(e,t)=>{e=(e=[e[3],e[2],e[1],e[0]]).map((e=>e.slice().reverse()));const s=[];e.forEach((e=>{e.forEach((e=>s.push(e)))}));const c=[];t.forEach((e=>{e.forEach((e=>c.push(e)))}));const l=[];for(let e=0;e<c.length;e++){const t=(e+1)%c.length;l.push(p.create([s[e],s[t],c[t],c[e]]))}return l};t.exports=e=>{let{center:t,size:s,roundRadius:l,segments:h}=Object.assign({},{center:[0,0,0],size:[2,2,2],roundRadius:.2,segments:32},e);if(!b(t,3))throw new Error("center must be an array of X, Y and Z values");if(!b(s,3))throw new Error("size must be an array of X, Y and Z values");if(!s.every((e=>e>=0)))throw new Error("size values must be positive");if(!w(l,0))throw new Error("roundRadius must be positive");if(!w(h,4))throw new Error("segments must be four or more");if(0===s[0]||0===s[1]||0===s[2])return g.create();if(0===l)return E({center:t,size:s});if(l>(s=s.map((e=>e/2)))[0]-c||l>s[1]-c||l>s[2]-c)throw new Error("roundRadius must be smaller then the radius of all dimensions");h=Math.floor(h/4);let f=null,d=null,x=[];for(let e=0;e<=h;e++){const c=createCorners(t,s,l,h,e,!0),g=createCorners(t,s,l,h,e,!1);if(0===e&&(x=x.concat(stitchSides(g,c))),f&&(x=x.concat(stitchCorners(f,c),stitchWalls(f,c))),d&&(x=x.concat(stitchCorners(d,g),stitchWalls(d,g))),e===h){let e=c.map((e=>e[0]));x.push(p.create(e)),e=g.map((e=>e[0])),x.push(p.create(e))}f=c,d=g}return g.create(x)}},{"../geometries/geom3":40,"../geometries/poly3":78,"../maths/constants":93,"../maths/utils/trigonometry":172,"../maths/vec2":190,"../maths/vec3":221,"./commonChecks":368,"./cuboid":370}],382:[function(e,t,s){const{EPS:c,TAU:l}=e("../maths/constants"),h=e("../maths/vec3"),f=e("../geometries/geom3"),g=e("../geometries/poly3"),{sin:p,cos:d}=e("../maths/utils/trigonometry"),{isGTE:x,isNumberArray:w}=e("./commonChecks"),b=e("./cylinder");t.exports=e=>{const{center:t,height:s,radius:E,roundRadius:A,segments:M}=Object.assign({},{center:[0,0,0],height:2,radius:1,roundRadius:.2,segments:32},e);if(!w(t,3))throw new Error("center must be an array of X, Y and Z values");if(!x(s,0))throw new Error("height must be positive");if(!x(E,0))throw new Error("radius must be positive");if(!x(A,0))throw new Error("roundRadius must be positive");if(A>E)throw new Error("roundRadius must be smaller then the radius");if(!x(M,4))throw new Error("segments must be four or more");if(0===s||0===E)return f.create();if(0===A)return b({center:t,height:s,radius:E});const S=[0,0,-s/2],k=[0,0,s/2],N=h.subtract(h.create(),k,S);if(2*A>h.length(N)-c)throw new Error("height must be larger than twice roundRadius");let C;C=Math.abs(N[0])>Math.abs(N[1])?h.fromValues(0,1,0):h.fromValues(1,0,0);const V=h.scale(h.create(),h.normalize(h.create(),N),A),q=h.scale(h.create(),h.normalize(h.create(),h.cross(h.create(),V,C)),E),R=h.scale(h.create(),h.normalize(h.create(),h.cross(h.create(),q,V)),E);h.add(S,S,V),h.subtract(k,k,V);const O=Math.floor(.25*M),m=e=>{const s=e.map((e=>h.add(e,e,t)));return g.create(s)},B=[],F=h.create(),z=h.create();let D;for(let e=0;e<=M;e++){const t=l*e/M,s=h.add(h.create(),h.scale(F,q,d(t)),h.scale(z,R,p(t)));if(e>0){let e,t,c=[];c.push(h.add(h.create(),S,s)),c.push(h.add(h.create(),S,D)),c.push(h.add(h.create(),k,D)),c.push(h.add(h.create(),k,s)),B.push(m(c));for(let f=0;f<=O;f++){const g=l/4*f/O,x=d(g),w=p(g);if(f>0){let l;c=[],l=h.add(h.create(),S,h.subtract(F,h.scale(F,D,e),h.scale(z,V,t))),c.push(l),l=h.add(h.create(),S,h.subtract(F,h.scale(F,s,e),h.scale(z,V,t))),c.push(l),f<O&&(l=h.add(h.create(),S,h.subtract(F,h.scale(F,s,x),h.scale(z,V,w))),c.push(l)),l=h.add(h.create(),S,h.subtract(F,h.scale(F,D,x),h.scale(z,V,w))),c.push(l),B.push(m(c)),c=[],l=h.add(h.create(),h.scale(F,D,e),h.scale(z,V,t)),h.add(l,l,k),c.push(l),l=h.add(h.create(),h.scale(F,s,e),h.scale(z,V,t)),h.add(l,l,k),c.push(l),f<O&&(l=h.add(h.create(),h.scale(F,s,x),h.scale(z,V,w)),h.add(l,l,k),c.push(l)),l=h.add(h.create(),h.scale(F,D,x),h.scale(z,V,w)),h.add(l,l,k),c.push(l),c.reverse(),B.push(m(c))}e=x,t=w}}D=s}return f.create(B)}},{"../geometries/geom3":40,"../geometries/poly3":78,"../maths/constants":93,"../maths/utils/trigonometry":172,"../maths/vec3":221,"./commonChecks":368,"./cylinder":371}],383:[function(e,t,s){const{EPS:c,TAU:l}=e("../maths/constants"),h=e("../maths/vec2"),f=e("../geometries/geom2"),{isGTE:g,isNumberArray:p}=e("./commonChecks"),d=e("./rectangle");t.exports=e=>{let{center:t,size:s,roundRadius:x,segments:w}=Object.assign({},{center:[0,0],size:[2,2],roundRadius:.2,segments:32},e);if(!p(t,2))throw new Error("center must be an array of X and Y values");if(!p(s,2))throw new Error("size must be an array of X and Y values");if(!s.every((e=>e>=0)))throw new Error("size values must be positive");if(!g(x,0))throw new Error("roundRadius must be positive");if(!g(w,4))throw new Error("segments must be four or more");if(0===s[0]||0===s[1])return f.create();if(0===x)return d({center:t,size:s});if(x>(s=s.map((e=>e/2)))[0]-c||x>s[1]-c)throw new Error("roundRadius must be smaller then the radius of all dimensions");const b=Math.floor(w/4),E=h.add(h.create(),t,[s[0]-x,s[1]-x]),A=h.add(h.create(),t,[x-s[0],s[1]-x]),M=h.add(h.create(),t,[x-s[0],x-s[1]]),S=h.add(h.create(),t,[s[0]-x,x-s[1]]),k=[],N=[],C=[],V=[];for(let e=0;e<=b;e++){const t=l/4*e/b,s=h.fromAngleRadians(h.create(),t);h.scale(s,s,x),k.push(h.add(h.create(),E,s)),h.rotate(s,s,h.create(),l/4),N.push(h.add(h.create(),A,s)),h.rotate(s,s,h.create(),l/4),C.push(h.add(h.create(),M,s)),h.rotate(s,s,h.create(),l/4),V.push(h.add(h.create(),S,s))}return f.fromPoints(k.concat(N,C,V))}},{"../geometries/geom2":25,"../maths/constants":93,"../maths/vec2":190,"./commonChecks":368,"./rectangle":380}],384:[function(e,t,s){const c=e("./ellipsoid"),{isGTE:l}=e("./commonChecks");t.exports=e=>{let{center:t,radius:s,segments:h,axes:f}=Object.assign({},{center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},e);if(!l(s,0))throw new Error("radius must be positive");return c({center:t,radius:s=[s,s,s],segments:h,axes:f})}},{"./commonChecks":368,"./ellipsoid":374}],385:[function(e,t,s){const c=e("./rectangle"),{isGTE:l}=e("./commonChecks");t.exports=e=>{let{center:t,size:s}=Object.assign({},{center:[0,0],size:2},e);if(!l(s,0))throw new Error("size must be positive");return c({center:t,size:s=[s,s]})}},{"./commonChecks":368,"./rectangle":380}],386:[function(e,t,s){const{TAU:c}=e("../maths/constants"),l=e("../maths/vec2"),h=e("../geometries/geom2"),{isGT:f,isGTE:g,isNumberArray:p}=e("./commonChecks"),getPoints=(e,t,s,h)=>{const f=c/e,g=[];for(let c=0;c<e;c++){const e=l.fromAngleRadians(l.create(),f*c+s);l.scale(e,e,t),l.add(e,h,e),g.push(e)}return g};t.exports=e=>{let{center:t,vertices:s,outerRadius:d,innerRadius:x,density:w,startAngle:b}=Object.assign({},{center:[0,0],vertices:5,outerRadius:1,innerRadius:0,density:2,startAngle:0},e);if(!p(t,2))throw new Error("center must be an array of X and Y values");if(!g(s,2))throw new Error("vertices must be two or more");if(!f(d,0))throw new Error("outerRadius must be greater than zero");if(!g(x,0))throw new Error("innerRadius must be greater than zero");if(!g(b,0))throw new Error("startAngle must be greater than zero");if(s=Math.floor(s),w=Math.floor(w),b%=c,0===x){if(!g(w,2))throw new Error("density must be two or more");x=d*((e,t)=>e>0&&t>1&&t<e/2?Math.cos(Math.PI*t/e)/Math.cos(Math.PI*(t-1)/e):0)(s,w)}const E=l.clone(t),A=getPoints(s,d,b,E),M=getPoints(s,x,b+Math.PI/s,E),S=[];for(let e=0;e<s;e++)S.push(A[e]),S.push(M[e]);return h.fromPoints(S)}},{"../geometries/geom2":25,"../maths/constants":93,"../maths/vec2":190,"./commonChecks":368}],387:[function(e,t,s){const{TAU:c}=e("../maths/constants"),l=e("../operations/extrusions/extrudeRotate"),{rotate:h}=e("../operations/transforms/rotate"),{translate:f}=e("../operations/transforms/translate"),g=e("./circle"),{isGT:p,isGTE:d}=e("./commonChecks");t.exports=e=>{const t={innerRadius:1,innerSegments:32,outerRadius:4,outerSegments:32,innerRotation:0,startAngle:0,outerRotation:c},{innerRadius:s,innerSegments:x,outerRadius:w,outerSegments:b,innerRotation:E,startAngle:A,outerRotation:M}=Object.assign({},t,e);if(!p(s,0))throw new Error("innerRadius must be greater than zero");if(!d(x,3))throw new Error("innerSegments must be three or more");if(!p(w,0))throw new Error("outerRadius must be greater than zero");if(!d(b,3))throw new Error("outerSegments must be three or more");if(!d(A,0))throw new Error("startAngle must be positive");if(!p(M,0))throw new Error("outerRotation must be greater than zero");if(s>=w)throw new Error("inner circle is two large to rotate about the outer circle");let S=g({radius:s,segments:x});return 0!==E&&(S=h([0,0,E],S)),S=f([w,0],S),l({startAngle:A,angle:M,segments:b},S)}},{"../maths/constants":93,"../operations/extrusions/extrudeRotate":315,"../operations/transforms/rotate":362,"../operations/transforms/translate":365,"./circle":367,"./commonChecks":368}],388:[function(e,t,s){const{NEPS:c}=e("../maths/constants"),l=e("../maths/vec2"),h=e("../geometries/geom2"),{isNumberArray:f}=e("./commonChecks"),solveAngleFromSSS=(e,t,s)=>Math.acos((e*e+t*t-s*s)/(2*e*t)),solveSAS=e=>{const t=e[0],s=e[1],l=e[2],h=((e,t,s)=>t>c?Math.sqrt(e*e+s*s-2*e*s*Math.cos(t)):Math.sqrt((e-s)*(e-s)+e*s*t*t*(1-t*t/12)))(t,s,l),f=solveAngleFromSSS(h,t,l),g=Math.PI-f-s;return createTriangle(f,s,g,l,h,t)},createTriangle=(e,t,s,c,f,g)=>{const p=l.fromValues(0,0),d=l.fromValues(g,0),x=l.fromValues(c,0);return l.add(x,l.rotate(x,x,[0,0],Math.PI-t),d),h.fromPoints([p,d,x])};t.exports=e=>{let{type:t,values:s}=Object.assign({},{type:"SSS",values:[1,1,1]},e);if("string"!=typeof t)throw new Error("triangle type must be a string");if("A"!==(t=t.toUpperCase())[0]&&"S"!==t[0]||"A"!==t[1]&&"S"!==t[1]||"A"!==t[2]&&"S"!==t[2])throw new Error("triangle type must contain three letters; A or S");if(!f(s,3))throw new Error("triangle values must contain three values");if(!s.every((e=>e>0)))throw new Error("triangle values must be greater than zero");switch(t){case"AAA":return(e=>{if(Math.abs(e[0]+e[1]+e[2]-Math.PI)>c)throw new Error("AAA triangles require angles that sum to PI");const t=e[0],s=e[1],l=Math.PI-t-s,h=1/Math.sin(l)*Math.sin(t),f=1/Math.sin(l)*Math.sin(s);return createTriangle(t,s,l,h,f,1)})(s);case"AAS":return(e=>{const t=e[0],s=e[1],l=Math.PI+c-t-s;if(l<c)throw new Error("AAS triangles require angles that sum to PI");const h=e[2],f=h/Math.sin(t)*Math.sin(s),g=h/Math.sin(t)*Math.sin(l);return createTriangle(t,s,l,h,f,g)})(s);case"ASA":return(e=>{const t=e[0],s=e[2],l=Math.PI+c-t-s;if(l<c)throw new Error("ASA triangles require angles that sum to PI");const h=e[1],f=h/Math.sin(l)*Math.sin(t),g=h/Math.sin(l)*Math.sin(s);return createTriangle(t,s,l,f,g,h)})(s);case"SAS":return solveSAS(s);case"SSA":return(e=>{const t=e[0],s=e[1],c=e[2],l=Math.asin(s*Math.sin(c)/t),h=Math.PI-l-c,f=t/Math.sin(c)*Math.sin(h);return createTriangle(l,h,c,s,f,t)})(s);case"SSS":return(e=>{const t=e[1],s=e[2],c=e[0];if(t+s<=c||s+c<=t||c+t<=s)throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");const l=solveAngleFromSSS(s,c,t),h=solveAngleFromSSS(c,t,s),f=Math.PI-l-h;return createTriangle(l,h,f,t,s,c)})(s);default:throw new Error("invalid triangle type, try again")}}},{"../geometries/geom2":25,"../maths/constants":93,"../maths/vec2":190,"./commonChecks":368}],389:[function(e,t,s){t.exports={height:14,32:[16],33:[10,5,21,5,7,void 0,5,2,4,1,5,0,6,1,5,2],34:[16,4,21,4,14,void 0,12,21,12,14],35:[21,11,25,4,-7,void 0,17,25,10,-7,void 0,4,12,18,12,void 0,3,6,17,6],36:[20,8,25,8,-4,void 0,12,25,12,-4,void 0,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],37:[24,21,21,3,0,void 0,8,21,10,19,10,17,9,15,7,14,5,14,3,16,3,18,4,20,6,21,8,21,10,20,13,19,16,19,19,20,21,21,void 0,17,7,15,6,14,4,14,2,16,0,18,0,20,1,21,3,21,5,19,7,17,7],38:[26,23,12,23,13,22,14,21,14,20,13,19,11,17,6,15,3,13,1,11,0,7,0,5,1,4,2,3,4,3,6,4,8,5,9,12,13,13,14,14,16,14,18,13,20,11,21,9,20,8,18,8,16,9,13,11,10,16,3,18,1,20,0,22,0,23,1,23,2],39:[10,5,19,4,20,5,21,6,20,6,18,5,16,4,15],40:[14,11,25,9,23,7,20,5,16,4,11,4,7,5,2,7,-2,9,-5,11,-7],41:[14,3,25,5,23,7,20,9,16,10,11,10,7,9,2,7,-2,5,-5,3,-7],42:[16,8,21,8,9,void 0,3,18,13,12,void 0,13,18,3,12],43:[26,13,18,13,0,void 0,4,9,22,9],44:[10,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],45:[26,4,9,22,9],46:[10,5,2,4,1,5,0,6,1,5,2],47:[22,20,25,2,-7],48:[20,9,21,6,20,4,17,3,12,3,9,4,4,6,1,9,0,11,0,14,1,16,4,17,9,17,12,16,17,14,20,11,21,9,21],49:[20,6,17,8,18,11,21,11,0],50:[20,4,16,4,17,5,19,6,20,8,21,12,21,14,20,15,19,16,17,16,15,15,13,13,10,3,0,17,0],51:[20,5,21,16,21,10,13,13,13,15,12,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],52:[20,13,21,3,7,18,7,void 0,13,21,13,0],53:[20,15,21,5,21,4,12,5,13,8,14,11,14,14,13,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],54:[20,16,18,15,20,12,21,10,21,7,20,5,17,4,12,4,7,5,3,7,1,10,0,11,0,14,1,16,3,17,6,17,7,16,10,14,12,11,13,10,13,7,12,5,10,4,7],55:[20,17,21,7,0,void 0,3,21,17,21],56:[20,8,21,5,20,4,18,4,16,5,14,7,13,11,12,14,11,16,9,17,7,17,4,16,2,15,1,12,0,8,0,5,1,4,2,3,4,3,7,4,9,6,11,9,12,13,13,15,14,16,16,16,18,15,20,12,21,8,21],57:[20,16,14,15,11,13,9,10,8,9,8,6,9,4,11,3,14,3,15,4,18,6,20,9,21,10,21,13,20,15,18,16,14,16,9,15,4,13,1,10,0,8,0,5,1,4,3],58:[10,5,14,4,13,5,12,6,13,5,14,void 0,5,2,4,1,5,0,6,1,5,2],59:[10,5,14,4,13,5,12,6,13,5,14,void 0,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],60:[24,20,18,4,9,20,0],61:[26,4,12,22,12,void 0,4,6,22,6],62:[24,4,18,20,9,4,0],63:[18,3,16,3,17,4,19,5,20,7,21,11,21,13,20,14,19,15,17,15,15,14,13,13,12,9,10,9,7,void 0,9,2,8,1,9,0,10,1,9,2],64:[27,18,13,17,15,15,16,12,16,10,15,9,14,8,11,8,8,9,6,11,5,14,5,16,6,17,8,void 0,12,16,10,14,9,11,9,8,10,6,11,5,void 0,18,16,17,8,17,6,19,5,21,5,23,7,24,10,24,12,23,15,22,17,20,19,18,20,15,21,12,21,9,20,7,19,5,17,4,15,3,12,3,9,4,6,5,4,7,2,9,1,12,0,15,0,18,1,20,2,21,3,void 0,19,16,18,8,18,6,19,5],65:[18,9,21,1,0,void 0,9,21,17,0,void 0,4,7,14,7],66:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,void 0,4,11,13,11,16,10,17,9,18,7,18,4,17,2,16,1,13,0,4,0],67:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5],68:[21,4,21,4,0,void 0,4,21,11,21,14,20,16,18,17,16,18,13,18,8,17,5,16,3,14,1,11,0,4,0],69:[19,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11,void 0,4,0,17,0],70:[18,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11],71:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,18,8,void 0,13,8,18,8],72:[22,4,21,4,0,void 0,18,21,18,0,void 0,4,11,18,11],73:[8,4,21,4,0],74:[16,12,21,12,5,11,2,10,1,8,0,6,0,4,1,3,2,2,5,2,7],75:[21,4,21,4,0,void 0,18,21,4,7,void 0,9,12,18,0],76:[17,4,21,4,0,void 0,4,0,16,0],77:[24,4,21,4,0,void 0,4,21,12,0,void 0,20,21,12,0,void 0,20,21,20,0],78:[22,4,21,4,0,void 0,4,21,18,0,void 0,18,21,18,0],79:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21],80:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,14,17,12,16,11,13,10,4,10],81:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21,void 0,12,4,18,-2],82:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,4,11,void 0,11,11,18,0],83:[20,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],84:[16,8,21,8,0,void 0,1,21,15,21],85:[22,4,21,4,6,5,3,7,1,10,0,12,0,15,1,17,3,18,6,18,21],86:[18,1,21,9,0,void 0,17,21,9,0],87:[24,2,21,7,0,void 0,12,21,7,0,void 0,12,21,17,0,void 0,22,21,17,0],88:[20,3,21,17,0,void 0,17,21,3,0],89:[18,1,21,9,11,9,0,void 0,17,21,9,11],90:[20,17,21,3,0,void 0,3,21,17,21,void 0,3,0,17,0],91:[14,4,25,4,-7,void 0,5,25,5,-7,void 0,4,25,11,25,void 0,4,-7,11,-7],92:[14,0,21,14,-3],93:[14,9,25,9,-7,void 0,10,25,10,-7,void 0,3,25,10,25,void 0,3,-7,10,-7],94:[16,6,15,8,18,10,15,void 0,3,12,8,17,13,12,void 0,8,17,8,0],95:[16,0,-2,16,-2],96:[10,6,21,5,20,4,18,4,16,5,15,6,16,5,17],97:[19,15,14,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],98:[19,4,21,4,0,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],99:[18,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],100:[19,15,21,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],101:[18,3,8,15,8,15,10,14,12,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],102:[12,10,21,8,21,6,20,5,17,5,0,void 0,2,14,9,14],103:[19,15,14,15,-2,14,-5,13,-6,11,-7,8,-7,6,-6,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],104:[19,4,21,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],105:[8,3,21,4,20,5,21,4,22,3,21,void 0,4,14,4,0],106:[10,5,21,6,20,7,21,6,22,5,21,void 0,6,14,6,-3,5,-6,3,-7,1,-7],107:[17,4,21,4,0,void 0,14,14,4,4,void 0,8,8,15,0],108:[8,4,21,4,0],109:[30,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0,void 0,15,10,18,13,20,14,23,14,25,13,26,10,26,0],110:[19,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],111:[19,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3,16,6,16,8,15,11,13,13,11,14,8,14],112:[19,4,14,4,-7,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],113:[19,15,14,15,-7,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],114:[13,4,14,4,0,void 0,4,8,5,11,7,13,9,14,12,14],115:[17,14,11,13,13,10,14,7,14,4,13,3,11,4,9,6,8,11,7,13,6,14,4,14,3,13,1,10,0,7,0,4,1,3,3],116:[12,5,21,5,4,6,1,8,0,10,0,void 0,2,14,9,14],117:[19,4,14,4,4,5,1,7,0,10,0,12,1,15,4,void 0,15,14,15,0],118:[16,2,14,8,0,void 0,14,14,8,0],119:[22,3,14,7,0,void 0,11,14,7,0,void 0,11,14,15,0,void 0,19,14,15,0],120:[17,3,14,14,0,void 0,14,14,3,0],121:[16,2,14,8,0,void 0,14,14,8,0,6,-4,4,-6,2,-7,1,-7],122:[17,14,14,3,0,void 0,3,14,14,14,void 0,3,0,14,0],123:[14,9,25,7,24,6,23,5,21,5,19,6,17,7,16,8,14,8,12,6,10,void 0,7,24,6,22,6,20,7,18,8,17,9,15,9,13,8,11,4,9,8,7,9,5,9,3,8,1,7,0,6,-2,6,-4,7,-6,void 0,6,8,8,6,8,4,7,2,6,1,5,-1,5,-3,6,-5,7,-6,9,-7],124:[8,4,25,4,-7],125:[14,5,25,7,24,8,23,9,21,9,19,8,17,7,16,6,14,6,12,8,10,void 0,7,24,8,22,8,20,7,18,6,17,5,15,5,13,6,11,10,9,6,7,5,5,5,3,6,1,7,0,8,-2,8,-4,7,-6,void 0,8,8,6,6,6,4,7,2,8,1,9,-1,9,-3,8,-5,7,-6,5,-7],126:[24,3,6,3,8,4,11,6,12,8,12,10,11,14,8,16,7,18,7,20,8,21,10,void 0,3,8,4,10,6,11,8,11,10,10,14,7,16,6,18,6,20,7,21,10,21,12]}},{}],390:[function(e,t,s){t.exports={vectorChar:e("./vectorChar"),vectorText:e("./vectorText")}},{"./vectorChar":391,"./vectorText":393}],391:[function(e,t,s){const c=e("./vectorParams");t.exports=(e,t)=>{const{xOffset:s,yOffset:l,input:h,font:f,height:g,extrudeOffset:p}=c(e,t);let d=h.charCodeAt(0);d&&f[d]||(d=63);const x=[].concat(f[d]),w=(g-p)/f.height,b=p/2,E=x.shift()*w,A=[];let M=[];for(let e=0,t=x.length;e<t;e+=2){const t=w*x[e]+s,c=w*x[e+1]+l+b;void 0===x[e]?(A.push(M),M=[],e--):M.push([t,c])}return M.length&&A.push(M),{width:E,height:g,segments:A}}},{"./vectorParams":392}],392:[function(e,t,s){const c={xOffset:0,yOffset:0,input:"?",align:"left",font:e("./fonts/single-line/hershey/simplex.js"),height:14,lineSpacing:2.142857142857143,letterSpacing:1,extrudeOffset:0};t.exports=(e,t)=>{t||"string"!=typeof e||(e={input:e}),e=e||{};const s=Object.assign({},c,e);return s.input=t||s.input,s}},{"./fonts/single-line/hershey/simplex.js":389}],393:[function(e,t,s){const c=e("./vectorChar"),l=e("./vectorParams"),translateLine=(e,t)=>{const{x:s,y:c}=Object.assign({x:0,y:0},e||{}),l=t.segments;let h=null,f=null;for(let e=0,t=l.length;e<t;e++)for(let t=0,g=(h=l[e]).length;t<g;t++)f=h[t],h[t]=[f[0]+s,f[1]+c];return t};t.exports=(e,t)=>{const{xOffset:s,yOffset:h,input:f,font:g,height:p,align:d,extrudeOffset:x,lineSpacing:w,letterSpacing:b}=l(e,t);let E,A,M,S,k,N,[C,V]=[s,h],q={width:0,segments:[]};const R=[];let O=[],B=0;const F=C,P=()=>{R.push(q),B=Math.max(B,q.width),q={width:0,segments:[]}};for(E=0,A=f.length;E<A;E++)M=f[E],S=c({xOffset:C,yOffset:V,font:g,height:p,extrudeOffset:x},M),"\n"!==M?(k=S.width*b,q.width+=k,C+=k," "!==M&&(q.segments=q.segments.concat(S.segments))):(C=F,V-=S.height*w,P());for(q.segments.length&&P(),E=0,A=R.length;E<A;E++)q=R[E],B>q.width&&(N=B-q.width,"right"===d?q=translateLine({x:N},q):"center"===d&&(q=translateLine({x:N/2},q))),O=O.concat(q.segments);return O}},{"./vectorChar":391,"./vectorParams":392}],394:[function(e,t,s){const c=e("../geometries/geom2"),l=e("../geometries/geom3"),h=e("../geometries/path2");t.exports=e=>{let t;for(const s of e){let e=0;if(c.isA(s)&&(e=1),l.isA(s)&&(e=2),h.isA(s)&&(e=3),t&&e!==t)return!1;t=e}return!0}},{"../geometries/geom2":25,"../geometries/geom3":40,"../geometries/path2":61}],395:[function(e,t,s){t.exports=e=>.017453292519943295*e},{}],396:[function(e,t,s){const flatten=e=>e.reduce(((e,t)=>Array.isArray(t)?e.concat(flatten(t)):e.concat(t)),[]);t.exports=flatten},{}],397:[function(e,t,s){t.exports=(e,t)=>e-t},{}],398:[function(e,t,s){t.exports={areAllShapesTheSameType:e("./areAllShapesTheSameType"),degToRad:e("./degToRad"),flatten:e("./flatten"),fnNumberSort:e("./fnNumberSort"),insertSorted:e("./insertSorted"),radiusToSegments:e("./radiusToSegments"),radToDeg:e("./radToDeg")}},{"./areAllShapesTheSameType":394,"./degToRad":395,"./flatten":396,"./fnNumberSort":397,"./insertSorted":399,"./radToDeg":401,"./radiusToSegments":402}],399:[function(e,t,s){t.exports=(e,t,s)=>{let c=0,l=e.length;for(;l>c;){const h=Math.floor((c+l)/2);s(t,e[h])>0?c=h+1:l=h}e.splice(c,0,t)}},{}],400:[function(e,t,s){t.exports=(e,t,s)=>{for(e=e.slice();e.length<s;)e.push(t);return e}},{}],401:[function(e,t,s){t.exports=e=>57.29577951308232*e},{}],402:[function(e,t,s){const{TAU:c}=e("../maths/constants");t.exports=(e,t,s)=>{const l=t>0?e*c/t:0,h=s>0?c/s:0;return Math.ceil(Math.max(l,h,4))}},{"../maths/constants":93}]},{},[91])(91)}));