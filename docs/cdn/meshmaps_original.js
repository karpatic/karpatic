import*as THREE from"/cdn/three/three.js";import{OrbitControls}from"/cdn/three/OrbitControls.js";import{BufferGeometryUtils}from"/cdn/three/BufferGeometryUtils.js";import{CSG}from"/cdn/three/CSG_Three.js";import{STLExporter}from"/cdn/three/STLExporter.js";async function displayOnMap(e){window.map&&window.map.eachLayer?window.map.eachLayer((function(e){window.map.removeLayer(e)})):window.map=L.map("display_map"),L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png",{maxZoom:19,attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'}).addTo(window.map);let t=L.geoJSON(e,{onEachFeature:function(e,t){e?.properties?.id&&t.bindTooltip(`LineString number: ${e.properties.id}`)}}).addTo(window.map);window.map.fitBounds(t.getBounds())}let fmt=e=>Math.floor(e*window.precision);async function getGeoJson(e){const t=await fetch(e);return await t.json()}async function simplifyGeoJSON(e){let t=topojson.topology({collection:e});t=topojson.presimplify(t);let o=topojson.quantile(t,window.simplifyBy);t=topojson.simplify(t,o),e=topojson.feature(t,t.objects.collection);let n={features:[],type:"FeatureCollection"},r=!1;e.features.forEach((e=>{"Polygon"===e.geometry.type?r=r?turf.union(r,e.geometry):e.geometry:"MultiPolygon"===e.geometry.type?e.geometry.coordinates.forEach((e=>{let t={type:"Polygon",coordinates:e};r=r?turf.union(r,t):e})):console.log("err",e)})),n.features.push(r);let i=[];return e.features.forEach(((t,o)=>{e.features.forEach(((e,r)=>{if(!["Polygon","MultiPolygon"].includes(t.geometry.type)||!["Polygon","MultiPolygon"].includes(e.geometry.type)||o===r||i.includes(e))return;let a=turf.lineOverlap(t,e);a.features.length&&(a.features[0].properties.id=o+1.001*r,n.features.push(a.features[0]))})),i.push(t)})),n}async function createLineShapes(e){const getPaths=e=>{let t=e.map((e=>{let[t,o]=e;return t=Math.abs(t-window.minX),o=Math.abs(o-window.minY),t=fmt(t/window.difX)-fmt(2*window.difX),o=fmt(o/window.difY)-fmt(2*window.difY),new THREE.Vector3(t,o,0)}));const o=new THREE.CurvePath;return t.forEach(((e,n)=>{n<t.length-1&&o.add(new THREE.LineCurve3(e,t[n+1]))})),o};let t=[];return e.features.forEach((e=>{"LineString"===e.geometry.type&&e.geometry.coordinates.length>1?t.push(getPaths(e.geometry.coordinates)):e.geometry.coordinates.forEach((o=>{"Polygon"===e.geometry.type?t.push(getPaths(o)):"MultiPolygon"===e.geometry.type&&o.forEach((e=>t.push(getPaths(e))))}))})),t}const createLineBuffers=(e,t=5,o=100)=>{const n=new THREE.Shape;return n.moveTo(0,0).lineTo(0,t).lineTo(o,t).lineTo(o,0),e.map((e=>{const t={depth:1,bevelEnabled:!1,extrudePath:e,steps:e.curves.length*window.stepMultiply};return new THREE.ExtrudeBufferGeometry(n,t)}))},line_mesh_groups=e=>{const t=new THREE.Group,o=new THREE.MeshNormalMaterial;o.color=(new THREE.Color).setHex(16777215*Math.random());const n=BufferGeometryUtils.mergeBufferGeometries(e,!0),r=new THREE.Mesh(n,o);return t.add(r),position(t),t};async function createGeomShapes(e){let t=[];const createShape=e=>{const t=new THREE.Shape;return e.forEach(((e,o)=>{let[n,r]=e;n=Math.abs(n-window.minX),r=Math.abs(r-window.minY),n=fmt(n/window.difX)-fmt(2*window.difX),r=fmt(r/window.difY)-fmt(2*window.difY),0===o?t.moveTo(n,r):t.lineTo(n,r)})),t};return e.features.forEach((e=>{"Polygon"===e.geometry.type?t.push(createShape(e.geometry.coordinates[0])):"MultiPolygon"===e.geometry.type&&e.geometry.coordinates.forEach((e=>{e.forEach((e=>{t.push(createShape(e))}))}))})),t}async function createGeomBuffers(e){return e.map((e=>{let t={depth:window.depth,bevelEnabled:!1};return new THREE.ExtrudeBufferGeometry(e,t)}))}const geom_mesh_groups2=e=>{const t=new THREE.Group;return e.forEach((e=>{const o=new THREE.MeshNormalMaterial;let n=new THREE.Mesh(e,o);n.position.z=0,t.add(n)})),position(t),t},geom_mesh_groups=e=>{const t=new THREE.Group,o=new THREE.MeshNormalMaterial;o.color=(new THREE.Color).setHex(16777215*Math.random());const n=BufferGeometryUtils.mergeBufferGeometries(e,!0),r=new THREE.Mesh(n,o);return t.add(r),position(t),t};function position(e){e.position.x=0,e.position.y=0}function exportScene(e,t){let o=(new STLExporter).parse(e),n=t+".stl",r=new Blob([o],{type:"text/plain"}),i=document.createElement("a");i.style.display="none",i.href=URL.createObjectURL(r),i.download=n,document.body.appendChild(i),i.click(),URL.revokeObjectURL(i.href),document.body.removeChild(i)}const scene=()=>{const e=new THREE.Scene;return e.background=new THREE.Color(3355443),e.add(new THREE.AxesHelper(100)),e},camera=()=>{const e=window.innerWidth/window.innerHeight,t=3*window.precision,o=new THREE.PerspectiveCamera(45,e,1,t);const n=fmt(window.difX),r=fmt(window.difY),i=window.precision;return o.position.set(n,r,i),o.updateMatrixWorld(),o};function subtractMeshes(e,t){let o=e.children[0];o.updateMatrix();let n=CSG.fromMesh(o),r=t.children[0];console.log("subtracthis",t.children);let i=CSG.fromMesh(r);n=n.subtract(i);var a=CSG.toMesh(n,o.matrix,o.material);a.geometry.computeVertexNormals();const s=new THREE.MeshNormalMaterial;var d=(new THREE.BufferGeometry).fromGeometry(a.geometry);return position(a=new THREE.Mesh(d,s)),a}export async function displayMap(){let e=window.formValues.geom,t=await getGeoJson(e),o=await simplifyGeoJSON(t);displayOnMap(JSON.parse(JSON.stringify(o)))}export async function initialize(){const e=window.formValues.geom;window.depth=5;let t=window.wallHeight||100,o=window.exteriorWallHeight||t+8*window.depth,n=window.exteriorLineWidth||10,r=window.interiorLineWidth||5,i=window.engraveWidth||7,a=window.engraveZpos||1.5*depth,s=window.stretchFactor||1.25;window.simplifyBy=window.simplifyBy||.0168,window.stepMultiply=window.stepMultiply||5,window.precision=window.precision||1e3;let d=window.scaleToThisSize||180,c=await getGeoJson(e),l=await simplifyGeoJSON(c);const[p,w,m,u]=turf.bbox(l);window.minX=p,window.minY=w,window.difX=Math.abs(m-p),window.difY=Math.abs(u-w);let f=JSON.parse(JSON.stringify(l));f.features=f.features.slice(0,1);const h=await createGeomShapes(f);let y=await createGeomBuffers(h),E=geom_mesh_groups(y),g=JSON.parse(JSON.stringify(l));g.features=g.features.slice(1);const T=await createLineShapes(g),M=await createLineBuffers(T,r,t);let x=line_mesh_groups(M);x.children.forEach((e=>{e.position.z=0,e.updateMatrix()})),window.stepMultiply=15;let H=JSON.parse(JSON.stringify(l));H.features=H.features.slice(0,1);const S=await createLineShapes(H),b=await createLineBuffers(S,n,o),R=line_mesh_groups(b);R.children.forEach((e=>{e.position.z=0,e.updateMatrix()}));let G=E.clone();G.children.forEach((e=>{e.position.z=-(depth+o),e.updateMatrix()}));const L=await createLineBuffers(T,i,depth),B=line_mesh_groups(L);B.children.forEach((e=>{e.position.z=a,e.updateMatrix()})),console.log("lineGroupSubtract",B.children.length),E=subtractMeshes(E,B);let C=new THREE.Group;C.add(E),C.add(x),C.add(R),C.scale.y*=s,G.scale.y*=s;const O=(new THREE.Box3).setFromObject(C),v=d/(O.max.x-O.min.x),_=d/(O.max.y-O.min.y),N=Math.min(v,_);C.scale.set(N,N*s,N),G.scale.set(N,N*s,N),G.position.x=180;const j=new THREE.Scene;j.background=new THREE.Color(3355443),j.add(new THREE.AxesHelper(100));const J=j;J.add(C),J.add(G);const P=new THREE.WebGLRenderer({antialias:!0}),z=camera();new OrbitControls(z,P.domElement),P.setSize(window.width,window.height);const X=document.getElementById("renderer");X.innerHTML="",X.appendChild(P.domElement);const Y=document.createElement("button");Y.textContent="Export Box Top",Y.addEventListener("click",(()=>{exportScene(C,"geom_box")})),X.appendChild(Y);const U=document.createElement("button");U.textContent="Export Box Base",U.addEventListener("click",(()=>{exportScene(G,"geom_base")})),X.appendChild(U),function animate(){requestAnimationFrame(animate),P.render(J,z)}()}