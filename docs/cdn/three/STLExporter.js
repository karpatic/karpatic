import{Vector3}from"./three.js";class STLExporter{parse(t,e={}){const r=void 0!==e.binary&&e.binary,o=[];let n,i=0;t.traverse((function(t){if(t.isMesh){const e=t.geometry;if(!0!==e.isBufferGeometry)throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");const r=e.index,n=e.getAttribute("position");i+=null!==r?r.count/3:n.count/3,o.push({object3d:t,geometry:e})}}));let s=80;if(!0===r){const t=new ArrayBuffer(2*i+3*i*4*4+80+4);n=new DataView(t),n.setUint32(s,i,!0),s+=4}else n="",n+="solid exported\n";const a=new Vector3,l=new Vector3,f=new Vector3,c=new Vector3,u=new Vector3,x=new Vector3;for(let t=0,e=o.length;t<e;t++){const e=o[t].object3d,r=o[t].geometry,n=r.index,i=r.getAttribute("position");if(null!==n)for(let t=0;t<n.count;t+=3){writeFace(n.getX(t+0),n.getX(t+1),n.getX(t+2),i,e)}else for(let t=0;t<i.count;t+=3){writeFace(t+0,t+1,t+2,i,e)}}return!1===r&&(n+="endsolid exported\n"),n;function writeFace(t,e,o,i,p){a.fromBufferAttribute(i,t),l.fromBufferAttribute(i,e),f.fromBufferAttribute(i,o),!0===p.isSkinnedMesh&&(p.boneTransform(t,a),p.boneTransform(e,l),p.boneTransform(o,f)),a.applyMatrix4(p.matrixWorld),l.applyMatrix4(p.matrixWorld),f.applyMatrix4(p.matrixWorld),function writeNormal(t,e,o){c.subVectors(o,e),u.subVectors(t,e),c.cross(u).normalize(),x.copy(c).normalize(),!0===r?(n.setFloat32(s,x.x,!0),s+=4,n.setFloat32(s,x.y,!0),s+=4,n.setFloat32(s,x.z,!0),s+=4):(n+="\tfacet normal "+x.x+" "+x.y+" "+x.z+"\n",n+="\t\touter loop\n")}(a,l,f),writeVertex(a),writeVertex(l),writeVertex(f),!0===r?(n.setUint16(s,0,!0),s+=2):(n+="\t\tendloop\n",n+="\tendfacet\n")}function writeVertex(t){!0===r?(n.setFloat32(s,t.x,!0),s+=4,n.setFloat32(s,t.y,!0),s+=4,n.setFloat32(s,t.z,!0),s+=4):n+="\t\t\tvertex "+t.x+" "+t.y+" "+t.z+"\n"}}}export{STLExporter};export default null;