{"meta":{"title":"Correlation Networks","summary":"This notebook was made to allow visualizing networks.","toc":"true","prettify":"true","default_exp":"corr","filename":"05_map_correlation_networks"},"content":"<p><a href=\"https://mybinder.org/v2/gh/bnia/dataplay/main?filepath=%2Fnotebooks%2F05_Map_Correlation_Networks.ipynb\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://mybinder.org/badge_logo.svg\" alt=\"Binder\"></a>\n <a href=\"https://colab.research.google.com/github/bnia/dataplay/blob/main/notebooks/05_Map_Correlation_Networks.ipynb\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://pete88b.github.io/fastpages/assets/badges/colab.svg\" alt=\"Binder\"></a>\n <a href=\"https://github.com/bnia/dataplay/tree/main/notebooks/05_Map_Correlation_Networks.ipynb\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://pete88b.github.io/fastpages/assets/badges/github.svg\" alt=\"Binder\"></a>\n <a href=\"https://github.com/ellerbrock/open-source-badges/\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://badges.frapsoft.com/os/v3/open-source.svg?v=103\" alt=\"Open Source Love svg3\"></a></p>\n<p> <a href=\"https://github.com/bnia/dataplay/blob/main/LICENSE\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/npm/l/all-contributors.svg?style=flat\" alt=\"NPM License\"></a>\n <a href=\"https://bnia.github.io\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"http://img.shields.io/badge/Status-Active-green.svg\" alt=\"Active\"></a> \n <a href=\"https://pypi.python.org/pypi/dataplay/\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/pypi/pyversions/dataplay.svg\" alt=\"Python Versions\"></a>\n <a href=\"\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/github/last-commit/bnia/dataplay.svg?style=flat\" alt=\"GitHub last commit\"></a>  </p>\n<p> <a href=\"https://github.com/bnia/dataplay\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/github/stars/bnia/dataplay.svg?style=social&label=Star\" alt=\"GitHub stars\"></a> \n <a href=\"https://github.com/bnia/dataplay\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/github/watchers/bnia/dataplay.svg?style=social&label=Watch\" alt=\"GitHub watchers\"></a> \n <a href=\"https://github.com/bnia/dataplay\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/github/forks/bnia/dataplay.svg?style=social&label=Fork\" alt=\"GitHub forks\"></a> \n <a href=\"https://github.com/bnia/dataplay\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/github/followers/bnia.svg?style=social&label=Follow\" alt=\"GitHub followers\"></a> </p>\n<p> <a href=\"https://twitter.com/intent/tweet?text=Check%20out%20this%20%E2%9C%A8%20colab%20by%20@bniajfi%20https://github.com/bnia/dataplay%20%F0%9F%A4%97\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/twitter/url/https/github.com/bnia/dataplay.svg?style=social\" alt=\"Tweet\"></a> \n <a href=\"https://twitter.com/bniajfi\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"><img src=\"https://img.shields.io/twitter/follow/bniajfi.svg?style=social\" alt=\"Twitter Follow\"></a></p>\n <details open>\n <summary> <h2 id=\"about-this-tutorial\">About this Tutorial:</h2>\n </summary> <p>⚠️ The writing is a work in progress. The functions work but text retouching⚠️</p>\n <p>Please read everything found on the <a href=\"https://bniajfi.org/dataplay/\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">mainpage</a> before continuing; disclaimer and all.</p>\n  <pre class='prettyprint'>import numpy as np\n import pandas as pd\n import matplotlib.pyplot as plt\n import networkx as nx\n import warnings\n warnings.filterwarnings('ignore')</pre> <pre class='prettyprint'>from VitalSigns import acsDownload</pre> <pre class='prettyprint'>from dataplay import merge\n from dataplay import intaker</pre> <blockquote>\n<p>In graph theory, a clustering coefficient is a measure of the degree to which nodes in a graph tend to cluster together. Evidence suggests that in most real-world networks, and in particular social networks, nodes tend to create tightly knit groups characterized by a relatively high density of ties; this likelihood tends to be greater than the average probability of a tie randomly established between two nodes (Holland and Leinhardt, 1971; Watts and Strogatz, 1998).</p>\n<p>Two versions of this measure exist: the global and the local. The global version was designed to give an overall indication of the clustering in the network, whereas the local gives an indication of the embeddedness of single nodes. - <a href=\"https://www.geeksforgeeks.org/clustering-coefficient-graph-theory/\" onclick=\"window.pingServer(this)\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Geek for Geeks</a></p>\n</blockquote>\n <pre class='prettyprint'>\n # this example is from the Geek for Geeks link above\n def average_clustering(G, trials=1000): \n     \"\"\"Estimates the average clustering coefficient of G. \n   \n     The local clustering of each node in `G` is the  \n     fraction of triangles that actually exist over  \n     all possible triangles in its neighborhood. \n     The average clustering coefficient of a graph  \n     `G` is the mean of local clusterings. \n   \n     This function finds an approximate average  \n     clustering coefficient for G by repeating `n`  \n     times (defined in `trials`) the following \n     experiment: choose a node at random, choose  \n     two of its neighbors at random, and check if \n     they are connected. The approximate coefficient  \n     is the fraction of triangles found over the  \n     number of trials [1]_. \n   \n     Parameters \n     ---------- \n     G : NetworkX graph \n   \n     trials : integer \n         Number of trials to perform (default 1000). \n   \n     Returns \n     ------- \n     c : float \n         Approximated average clustering coefficient. \n   \n      \n   \n     \"\"\"\n     n = len(G) \n     triangles = 0\n     nodes = G.nodes() \n     for i in [int(random.random() * n) for i in range(trials)]: \n         nbrs = list(G[nodes[i]]) \n         if len(nbrs) < 2: \n             continue\n         u, v = random.sample(nbrs, 2) \n         if u in G[v]: \n             triangles += 1\n     return triangles / float(trials) </pre> <pre class='prettyprint'>G=nx.erdos_renyi_graph(10,0.4) \n cc=nx.average_clustering(G) </pre> <pre class='prettyprint'>c=nx.clustering(G) \n c  \n nx.draw(G)</pre> <details>\n <summary> <h3 id=\"data-prep\">Data Prep</h3>\n </summary> <pre class='prettyprint'>u = intaker.Intake\n rdf = u.getData('https://services1.arcgis.com/mVFRs7NF4iFitgbY/ArcGIS/rest/services/Biz1_/FeatureServer/0/query?where=1%3D1&outFields=*&returnGeometry=true&f=pgeojson')\n # rdf.set_index('CSA2010', drop=True, inplace=True)\n rdf.drop(labels=['OBJECTID_1', 'Shape__Area', 'Shape__Length'], axis=1, inplace=True)\n \n vs10to19Ind = rdf.filter(regex='biz1|CSA2010', axis=1)</pre> <p>Get only the columns we want to work with</p>\n <pre class='prettyprint'>vs10to19Ind.head()</pre> <p>What we want is 1 record for every year and every CSA as a column. To do this, transpose the dataset. Set the CSA labels (first row) as our columns, relabel the index (for clarity) and cast our datatypes.</p>\n <pre class='prettyprint'>vs10to19Indt = vs10to19Ind.T\n vs10to19Indt.columns = vs10to19Indt.iloc[0]\n vs10to19Indt = vs10to19Indt[1:]\n vs10to19Indt.index.name = 'variable'\n vs10to19Indt = vs10to19Indt.astype('float64')</pre> <pre class='prettyprint'>vs10to19Indt</pre> </details>\n <details>\n <summary> <h2 id=\"a-calculate-the-correlation-matrix\">a. Calculate the correlation matrix</h2>\n </summary> <p><em>cor_matrix</em> contains the full correlation matrix. The table below shows a snapshot of the first 5 rows.</p>\n <pre class='prettyprint'>#craetes a correlation matrix\n cor_matrix = vs10to19Indt.iloc[:,:].corr()\n #shows the first 5 rows\n cor_matrix.head(5)</pre> <pre class='prettyprint'>df = vs10to19Indt.copy()\n import matplotlib.pyplot as plt\n f = plt.figure(figsize=(19, 15))\n plt.matshow(df.corr(), fignum=f.number)\n irange = range(df.select_dtypes(['number']).shape[1])\n labels = df.select_dtypes(['number']).columns\n # plt.xticks(irange, labels, fontsize=14, rotation=45)\n plt.yticks(irange, labels, fontsize=14)\n cb = plt.colorbar()\n cb.ax.tick_params(labelsize=14)\n plt.title('Correlation Matrix', fontsize=16);</pre> <pre class='prettyprint'>#extracts the indices from the correlation matrix\n lblVals = cor_matrix.index.values</pre> <pre class='prettyprint'>#Changes from dataframe to matrix, so it is easier to create a graph with networkx\n cor_matrix = np.asmatrix(cor_matrix)</pre> <pre class='prettyprint'>cor_matrix</pre> </details>\n <details>\n <summary> <h2 id=\"b-create-graph\">b. Create graph</h2>\n </summary> <pre class='prettyprint'>#Crates graph using the data of the correlation matrix\n G = nx.from_numpy_matrix(cor_matrix)\n \n #relabels the nodes to match the  stocks names\n G = nx.relabel_nodes(G,lambda x: lblVals[x])\n \n #Shows the first 5 edges with their corresponding edges\n # OLD: G.edges(data=True)[:5]\n list(G.edges(data=True))[0:5]</pre> </details>\n <details>\n <summary> <h2 id=\"c-styling-the-nodes-based-on-the-number-of-edges-linked-degree\">C. Styling the nodes based on the number of edges linked (degree)</h2>\n </summary> <pre class='prettyprint'>#function to create and display networks from the correlatin matrix. \n \n def create_corr_network_5(G, corr_direction, min_correlation):\n     ##Creates a copy of the graph\n     H = G.copy()\n     \n     ##Checks all the edges and removes some based on corr_direction\n     for stock1, stock2, weight in G.edges(data=True):\n         ##if we only want to see the positive correlations we then delete the edges with weight smaller than 0        \n         if corr_direction == \"positive\":\n             ####it adds a minimum value for correlation. \n             ####If correlation weaker than the min, then it deletes the edge\n             if weight[\"weight\"] <0 or weight[\"weight\"] < min_correlation:\n                 H.remove_edge(stock1, stock2)\n         ##this part runs if the corr_direction is negative and removes edges with weights equal or largen than 0\n         else:\n             ####it adds a minimum value for correlation. \n             ####If correlation weaker than the min, then it deletes the edge\n             if weight[\"weight\"] >=0 or weight[\"weight\"] > min_correlation:\n                 H.remove_edge(stock1, stock2)\n                 \n     \n     #crates a list for edges and for the weights\n     edges,weights = zip(*nx.get_edge_attributes(H,'weight').items())\n     \n     ### increases the value of weights, so that they are more visible in the graph\n     weights = tuple([(1+abs(x))**2 for x in weights])\n     \n     #####calculates the degree of each node\n     d = nx.degree(H)\n     #####creates list of nodes and a list their degrees that will be used later for their sizes\n     nodelist, node_sizes = zip(*d)\n \n     #positions\n     positions=nx.circular_layout(H)\n     \n     #Figure size\n     plt.figure(figsize=(15,15))\n \n     #draws nodes\n     nx.draw_networkx_nodes(H,positions,node_color='#DA70D6',nodelist=nodelist,\n                            #####the node size will be now based on its degree\n                            node_size=tuple([x**3 for x in node_sizes]),alpha=0.8)\n     \n     #Styling for labels\n     nx.draw_networkx_labels(H, positions, font_size=8, \n                             font_family='sans-serif')\n     \n     ###edge colors based on weight direction\n     if corr_direction == \"positive\":\n         edge_colour = plt.cm.GnBu \n     else:\n         edge_colour = plt.cm.PuRd\n         \n     #draws the edges\n     nx.draw_networkx_edges(H, positions, edges,style='solid',\n                           ###adds width=weights and edge_color = weights \n                           ###so that edges are based on the weight parameter \n                           ###edge_cmap is for the color scale based on the weight\n                           ### edge_vmin and edge_vmax assign the min and max weights for the width\n                           width=weights, edge_color = weights, edge_cmap = edge_colour,\n                           edge_vmin = min(weights), edge_vmax=max(weights))\n \n     # displays the graph without axis\n     plt.axis('off')\n     #saves image\n     plt.savefig(\"part5\" + corr_direction + \".png\", format=\"PNG\")\n     plt.show() \n</pre> <pre class='prettyprint'>create_corr_network_5(G, corr_direction=\"positive\",min_correlation=0.7)</pre> <pre class='prettyprint'>create_corr_network_5(G, corr_direction=\"negative\",min_correlation=-0.7)</pre> <pre class='prettyprint'># wdf[ wdf['CSA2010']=='Allendale/Irvington/S. Hilton']</pre> <p>We want to create a linear regression for each CSA using {X: year, Y: value} for a given indicator</p>\n <pre class='prettyprint'>import numpy as np\n import matplotlib.pyplot as plt\n import pandas as pd\n from sklearn.linear_model import LinearRegression\n \n # Create 3 columns: CSA2010\tvariable value\n wdf = vs10to19Ind.melt(id_vars='CSA2010', value_vars=vs10to19Ind.columns[1:])\n \n # Convert indicator labels into our X (Year) column \n wdf['variable'] = wdf['variable'].apply(lambda x: int(x.replace('biz1_','') ) )\n \n findf = {'CSA':[], 'B':[], 'M':[] }\n # For each CSA \n for csa in wdf.CSA2010.unique():\n   CsaData = wdf[ wdf['CSA2010']==csa]\n   X = CsaData[['variable']] #.values # returns: [10 11 12 13 14 15 16 17 18 19]\n   y = CsaData[['value']] #.values\n   regressor = LinearRegression()\n   regressor.fit(X, y)\n   y_pred = regressor.predict(X)\n   plt.scatter(X, y, color = 'red')\n   plt.plot(X, regressor.predict(X), color = 'blue')\n   plt.title('biz1: '+ csa)\n   plt.xlabel('YEAR')\n   plt.ylabel('VALUE')\n   display( plt.show() )\n   display( print('B: ', regressor.coef_, 'Y: ', regressor.intercept_) ) \n   findf['CSA'].append(csa)\n   findf['B'].append(regressor.intercept_[0])\n   findf['M'].append(regressor.coef_[0][0])</pre> <pre class='prettyprint'>lin_reg_df = pd.DataFrame(data=findf)</pre> <pre class='prettyprint'>lin_reg_df.head()</pre> <pre class='prettyprint'>lin_reg_dft = lin_reg_df.T\n lin_reg_dft.columns = lin_reg_dft.iloc[0]\n lin_reg_dft = lin_reg_dft[1:]\n lin_reg_dft.index.name = 'variable'\n lin_reg_dft = lin_reg_dft.astype('float64')</pre> <pre class='prettyprint'>lin_reg_dft</pre> <p>We may need to normalize the data for this to be useable</p>\n <pre class='prettyprint'>df = lin_reg_dft.copy()\n import matplotlib.pyplot as plt\n f = plt.figure(figsize=(19, 15))\n plt.matshow(df.corr(), fignum=f.number)\n irange = range(df.select_dtypes(['number']).shape[1])\n labels = df.select_dtypes(['number']).columns\n # plt.xticks(irange, labels, fontsize=14, rotation=45)\n plt.yticks(irange, labels, fontsize=14)\n cb = plt.colorbar()\n cb.ax.tick_params(labelsize=14)\n plt.title('Correlation Matrix', fontsize=16);</pre> <pre class='prettyprint'>t = \"\"\" \"\"\"\n !pip install nbdev\n from google.colab import drive\n drive.mount('/content/drive')\n %cd /content/drive/My Drive/'Software Development Documents'/dataplay/\n \n # !pip install dataplay</pre> </details>\n  <script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\"></script>\n  <link rel=\"stylesheet\" href=\"https://cdn.rawgit.com/google/code-prettify/master/styles/desert.css\"/>\n  "}