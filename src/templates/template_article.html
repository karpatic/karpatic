<div id="tracer"></div>
<svg xmlns="http://www.w3.org/2000/svg" id="svg_bg"></svg> 
<!-- this checkbox holds state of whether modal is visible or not -->
<input type="checkbox" id="toggle-sitemap">
<div id="sitemap"> 
  <label role="button" tabindex="0" for="toggle-sitemap"><span>Hide</span> <span>Show </span>Sitemap</label>
</div>
<link id='template' class='template_article'>
<div id='pageTransitioneer'><p>Don't Look! I'm changing!</p></div>

<div id="gradient_bg"> 
</div>  
<div id="header">
  <div id="header_nav">
    <h1><a href="./">Charles Karpati</a> <span id="head_separator"> | </span> <a href="#title" id="title"></a></h1> 
    <p id="summary"></p>
  </div>
  <span id="header_bg_wrapper"><div id="header_bg"></div></span> 
</div>

<div class='broider' id='content'>
  <div id="outline"></div>
  <div id="content"></div>
</div>
<div id="footer">
  <p id="thanks">Thank's for visiting! - <a href='./legal.html'>Terms of use</a> </p>
  <span id="footer_bg_wrapper"><div id="footer_bg"></div></span> 
</div> 
<!-- <link rel="stylesheet" type="text/css" href="/templates/template_article.css"></link>-->
<script type="text/javascript">

// Onstart: Uncheck & Rollup for mobile Vs. Slide Left on Large Screens
/*
var tsm = document.getElementById("toggle-sitemap");
tsm.checked = !window.innerWidth < 800
var sm = document.getElementById("sitemap");
var size = sm.offsetWidth;
var space = document.querySelector(".broider").getBoundingClientRect().left;
if( space > size ){
  sm.style.left=space-size+"px";
  sm.style.transition = 'left 0.5s ease-in-out';
  setTimeout( ()=>sm.style.transition = 'none',500) // CSS transitions .5 seconds
}
*/

// alternately toggle-sitemap if sitemap-content scroll behaviors is not good.
var inDrag, dragStartX, dragStartY, objInitLeft, objInitTop = 0;
function downFN(e) {
    inDrag = true;
    objInitLeft = sitemap.offsetLeft; objInitTop = sitemap.offsetTop;
    dragStartX = e.pageX || e.targetTouches[0].clientX; 
    dragStartY = e.pageY || e.targetTouches[0].clientY; 
}
function moveFN(e) {
    if (!inDrag) {return;} 
    e.preventDefault();
    document.getElementById('drag').style.display='none';
    dragToX = e.pageX || e.targetTouches[0].clientX; 
    dragToY = e.pageY || e.targetTouches[0].clientY; 
    sitemap.style.left = (objInitLeft + dragToX-dragStartX) + "px";
    sitemap.style.top = (objInitTop + dragToY-dragStartY) + "px";
} 
[  [["mousedown", "touchstart"], downFN],
  [["mousemove", "touchmove"], moveFN],
  [["mouseup", "touchend"], () => inDrag = false],
].forEach(evt => evt[0].forEach(type => sitemap.addEventListener(type, evt[1], { passive: false })));




// Hit em w/ the ol razzle dazzle; and give em the wiggles~! >:D
// IntersectionObserver for animations and Highlighting active TOC Anchor link
// Runs once on load and again on templateRefreshed event
window.activeHeader = null
const observer = new IntersectionObserver((entries) => { 
    entries.forEach((entry) => {let e=entry.target
        let txt = "0.5s ease-in-out 0s 2 normal none running wiggle";
        let pos = e.getBoundingClientRect().top
        let el = (e.parentNode.nodeName == "SUMMARY" && e.parentNode.style || e.style ) 
        if (!entry.isIntersecting){ el.animation == txt && (el.animation = ''); return; }
        el.animation = txt 
        if(pos<300 || pos>300){ /* ' Scrolling', pos>100?'Down: ':'Up */  
            window.activeHeader && (window.activeHeader.style.textDecoration='none')
            let tocLink = document.getElementById('goto_'+e.id)
            tocLink && ( tocLink.style.animation = txt, tocLink.style.textDecoration='line-through' ) 
            window.activeHeader = tocLink
        }
    });
});
loadObserver = (t) =>{ document.querySelectorAll('h2,h3,h4').forEach((el) => observer.observe(el) ) };  
window.addEventListener('templateRefreshed', async () =>{ setTimeout( ()=> loadObserver(), 2000) } );
loadObserver();

// Lazy Load
function throttle(func, wait) { let lastCallTime, timeout; return function(...args) { const now = Date.now();
    if (!lastCallTime || now - lastCallTime >= wait) { clearTimeout(timeout); func.apply(this, args); lastCallTime = now;} 
    else { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait - (now - lastCallTime)); } };
}
window.addEventListener('scroll', throttle(() => { let d = document.documentElement;
  window.loadOnce||((document.head||d).appendChild(document.createElement('script')).src='templates/template_article_lazy.js'); window.loadOnce=true;
  window.tracer?.style.setProperty('--scrollPercent', (d.scrollTop) / (d.scrollHeight - d.clientHeight) * 100 + '%');
}, 50) );

</script>