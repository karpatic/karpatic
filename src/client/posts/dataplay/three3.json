{"meta":{"filename":"three3","title":"Three","summary":"In this chapter, we will learn about three and explore some of its many features.","toc":"true","prettify":"true"},"content":"<div id='renderWindow'></div> <p>&gt;</p>\n <script>\n window.position = (mesh) => {\n   mesh.rotateZ(Math.PI);\n   mesh.translateX(-center.x + 0);\n   mesh.translateY(-center.y + 0);\n }\n \n window.getBoundingBoxCenter = (mesh) => {\n   // Calculate the bounding box of the mesh\n   let boundingBox = new THREE.Box3().setFromObject(mesh);\n   // Return the center of the bounding box\n   return boundingBox.getCenter(new THREE.Vector3());\n }\n </script> <script>\n window.create3dFromSvgV8 = (svg, type, color=false) => {\n   // Get Shapes and Points\n   const loader = new window.SVGLoader();           // Load the svg using three to use it's tooling\n   console.log({loader})\n   let paths = loader.parse(svg.outerHTML).paths; // Parse the SVG file and retrieve all the paths\n   let style = paths[0].userData.style;          // Store the style of the first path in a variable\n   const shapes = []\n   let points = [];\n   // THREE.JS FN Retrieves the shapes for each path, converts it to a threejs 'shape' and add the the 'shapes' array\n   paths.forEach((path, i) => {\n     paths[i].toShapes(true, false).forEach((shape, i) => {\n       shapes.push(shape);\n     });\n     for (let j = 0, jl = path.subPaths.length; j < jl; j++) {\n       points.push(path.subPaths[j].getPoints());\n     }\n   }); \n   const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide }); \n   material.color = new THREE.Color().setStyle( color||'blue' )\n \n   // Create Group\n   const group = new THREE.Group();\n   let extrudeSettings = { depth: depth, bevelEnabled: false }\n \n   // Points: Paint Stroke\n   if( ['lines'].includes(type) ){\n     points.forEach((pointsArr, i) => {\n       const geometry = window.SVGLoader.pointsToStroke( pointsArr, style )\n       const mesh = new THREE.Mesh( geometry, material );\n       group.add( mesh );\n     });\n   }\n   \n   // Shapes: Extrtrude Geometry\n   if( ['geoms'].includes(type) ){\n     shapes.forEach(shape => { \n       const geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);\n       const mesh = new THREE.Mesh(geometry, material);\n       group.add(mesh);\n     });\n   }\n   \n   // Points: Extrude Stroke\n   if ([\"extrude\"].includes(type)) {     \n     const shapeBufferGeometry = [];\n     points.forEach((twoVectorArray, i) => {\n       let threeVectorArray = [];\n       twoVectorArray.forEach((v, i) => { threeVectorArray.push(new THREE.Vector3(v.x, v.y, 0)); });\n       const extrusionPath = new THREE.CurvePath();\n       for (let i = 0; i < threeVectorArray.length - 1; i++) { \n         extrusionPath.add( new THREE.LineCurve3( threeVectorArray[i], threeVectorArray[i + 1] ) );\n       }\n   \n       const squareShape = new THREE.Shape()\n         .moveTo(depth, 0)\n         .lineTo(linewidth, linewidth) // square line widths\n         .lineTo(linewidth, linewidth) \n         .lineTo(linewidth, 0);\n         \n       var geometry = new THREE.ExtrudeBufferGeometry(squareShape, {\n         extrudePath: extrusionPath,\n         curveSegments: 1,\n         steps: 20,\n         bevelEnabled: false,\n       });\n       shapeBufferGeometry.push(geometry);\n     });\n \n     const iconGeometry = window.BufferGeometryUtils.mergeBufferGeometries( shapeBufferGeometry, true);\n     const mesh = new THREE.Mesh(iconGeometry, material); \n     group.add(mesh);\n   }\n \n   position(group) \n   \n   return group;\n }\n </script> <script>\n window.createMeshHullRes = async (res1, res2, res3=false, res4=false) => {\n   let CSG = (await import('../js/CSG.js')).CSG\n \n   let meshA = res1.children[0] //hull3D\n   let meshB = res2 && res2.children[0] //hull3DSmall\n   let meshC = res3 && res3.children[0] //geomBounds3D\n   let meshD = res4 && res4.children[0] //geomBounds3DSmall\n \n   let bb1 = getBoundingBoxCenter(meshA)\n   let bspA = CSG.fromMesh( meshA );  \n   let bspResult = bspA;\n \n   if(meshB){\n     meshB.scale.set(.95, .95, .95);\n     let bb2 = getBoundingBoxCenter(meshB)\n     let translation = new THREE.Vector3().subVectors(bb1, bb2);\n     meshB.position.x += translation.x;\n     meshB.position.y += translation.y;\n     meshB.position.z = bb1.z;\n     meshB.updateMatrix();\n     let bspB = CSG.fromMesh( meshB ); \n     bspResult = bspA.subtract(bspB); \n   }\n   if(meshC){\n     meshC.scale.set(.95, .95, .95);\n     let bb3 = getBoundingBoxCenter(meshC)\n     translation = new THREE.Vector3().subVectors(bb1, bb3);\n     meshC.position.x += translation.x;\n     meshC.position.y += translation.y;\n     meshC.position.z = depth+20\n     meshC.updateMatrix();\n     let bspC = CSG.fromMesh( meshC ); \n     bspResult = bspResult.subtract(bspC); \n   }\n   if(meshD){\n     meshD.scale.set(.95, .95, .95);\n     let bb4 = getBoundingBoxCenter(meshD)\n     translation = new THREE.Vector3().subVectors(bb1, bb4);\n     meshD.position.x += translation.x;\n     meshD.position.y += translation.y;\n     meshD.position.z = depth + 20;\n     meshD.updateMatrix();\n     let bspD = CSG.fromMesh( meshD ); \n     bspResult = bspResult.union(bspD); \n   } \n \n   var mesh = CSG.toMesh( bspResult, meshA.matrix, meshA.material ); \n   mesh.geometry.computeVertexNormals();  \n \n   const material = new THREE.MeshNormalMaterial(); \n   \n   var bufferGeometry = new THREE.BufferGeometry().fromGeometry( mesh.geometry );\n   mesh = new THREE.Mesh( bufferGeometry, material )\n   \n   position(mesh)\n   return mesh\n }\n </script> <p>Prusa has 100 steps per mm. The resolution of a print will depend on the size of the boundary and boundary</p>\n <script>\n let width = height = 600;\n let center = { 'x': width / 2, 'y': height / 2 }\n window.depth = 40;\n window.linewidth = 2;\n window.simplifyBy = 0.025;\n </script> <script> \n (async () => {\n   // Import Tools\n   let { create } = (await import('https://cdn.jsdelivr.net/npm/d3@7.8.4/dist/d3.min.js'));  \n   console.log(d3);\n   let { convex } = await import('https://unpkg.com/@turf/turf/turf.min.js');\n   let version = '0.123';\n   window.THREE = (await import(`https://unpkg.com/three@${version}/build/three.module.js`));\n   window.SVGLoader = (await import(`https://unpkg.com/three@${version}/examples/jsm/loaders/SVGLoader.js`)).SVGLoader;   \n   window.OrbitControls = (await import(`https://unpkg.com/three@${version}/examples/jsm/controls/OrbitControls.js`)).OrbitControls;\n   window.BufferGeometryUtils = (await import(`https://unpkg.com/three@${version}/examples/jsm/utils/BufferGeometryUtils.js`)).BufferGeometryUtils; \n   window.topojsonClient = (await import(`https://cdn.skypack.dev/topojson-client`));\n   window.topojsonSimplify = (await import(`https://cdn.skypack.dev/topojson-simplify`));\n   window.topojsonServer = (await import(`https://cdn.skypack.dev/topojson-server`));  \n   \n   // Import GeoJson\n   let geomUrl=\"https://services1.arcgis.com/mVFRs7NF4iFitgbY/ArcGIS/rest/services/Tpop/FeatureServer/0/query?where=1%3D1&outFields=*&returnGeometry=true&f=pgeojson\";\n   let geojson = await (await fetch(geomUrl) ).json()\n \n   let path = d3.geoPath().projection(d3.geoMercator().fitExtent([[0, 0], [width, height]], geojson) )\n \n   //// ~~~~~~ V\n \n   // Get Hull as baselayer\n   var hull = turf.convex( geojson );   \n   hull.properties['name'] = \"Baltimore City\"\n   let svg = d3.create(\"svg\").attr(\"viewBox\", [0, 0, width, height])\n   svg.append(\"path\").datum(hull).attr(\"d\", path).attr(\"stroke\", \"#000\").attr(\"stroke-width\", 1).attr(\"fill\", \"#ccc\");\n   hull3D = create3dFromSvgV8(svg.node(), 'geoms', 'green');\n   \n   // Simplify Bounds\n   let simplify = (geo, val) => {\n     let simplified = topojsonSimplify.presimplify(geo);\n     let min_weight = topojsonSimplify.quantile(simplified, val); \n     return topojsonSimplify.simplify(simplified, min_weight);\n   }\n   let topoJSON = geojson\n   if (geojson.type !== \"Topology\") {\n     topoJSON = topojsonServer.topology({ name: geojson });\n     topoJSON = simplify(topoJSON, window.simplifyBy) \n   }\n \n   // Get Lines\n   svg = d3.create(\"svg\")\n   svg.append(\"path\").datum(topojsonClient.mesh(topoJSON, topoJSON.objects.name, (a, b) => true))\n     .attr(\"d\", path).attr(\"stroke\", \"#000\")\n     .attr(\"fill\", \"none\").attr(\"stroke-width\", 0.5);\n   geomBounds3D = create3dFromSvgV8(svg.node(), 'extrude', 'pink');\n   \n   //// ~~~~~~ ^ \n \n   window.meshHullRes = await createMeshHullRes(\n     // hull3D, false, false, geomBounds3D\n     // hull3D, hull3D.clone(), geomBounds3D, geomBounds3D.clone()\n     // hull3D, hull3D.clone(), false, false\n     hull3D, false, geomBounds3D, false\n   ) \n  \n   \n   const scene = new THREE.Scene();\n   scene.background = new THREE.Color(0x333333);\n   scene.add(new THREE.AxesHelper(100)); \n   // scene.add(geomBounds3D); \n   //scene.add(hull3D);  \n   scene.add(meshHullRes);\n   let viewH = viewW = 750 \n   // Set up the camera and renderer\n   const fov = 65;\n   const aspect = viewW/ viewH;\n   const near = 100;\n   const far = 3000;\n   const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n   camera.position.set(50, 100, 1000); \n   camera.updateMatrixWorld(); \n \n \n   const renderer = new THREE.WebGLRenderer({ antialias: true });\n   const controls = new OrbitControls(camera, renderer.domElement);\n   // invalidation.then(() => (controls.dispose(), renderer.dispose()));\n \n   renderer.setSize( viewW, viewH );\n   //renderer.setPixelRatio(devicePixelRatio);\n   controls.addEventListener(\"change\", () => renderer.render(scene, camera));\n   renderer.render(scene, camera);\n   window.renderWindow.appendChild(renderer.domElement);\n })()\n </script> <script>\n window.exportScene = () => {};\n window.exportScene = async (name) => {\n     window.STLExporter = (await import(\"https://cdn.skypack.dev/three@0.136.0/examples/jsm/exporters/STLExporter.js\")).STLExporter;\n     let exporter = new STLExporter(); \n     let meshThis = window[name]\n     // console.log('exportScene', meshThis)\n     let buffer = exporter.parse( meshThis )\n     let filename = name+'.stl'\n     let blobby = new Blob( [ buffer ], { type: \"text/stl\" } )\n     \n     const link = document.createElement(\"a\");\n     link.href = window.URL.createObjectURL(blobby);\n     link.setAttribute(\"download\", filename);\n     document.body.appendChild(link);\n     link.click();\n     link.remove();\n } \n </script>\n <span>\n     <a onClick=\"window.exportScene('hull3D')\" ><button>Download hull3D</button></a>\n     <a onClick=\"window.exportScene('geomBounds3D')\" ><button>Download geomBounds3D</button></a> \n     <a onClick=\"window.exportScene('meshHullRes')\" ><button>Download meshHullRes</button></a>\n </span> <p>&lt;</p>\n <pre class='prettyprint'># hello this is a comment \n let 1 = 2;\n console.log(1)</pre>\n  <script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\"></script>\n  <link rel=\"stylesheet\" href=\"https://cdn.rawgit.com/google/code-prettify/master/styles/desert.css\"/>\n  "}